<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>B站大学-Spring Boot2</title>
    <link href="/2022/04/04/SpringBoot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/04/SpringBoot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="B站大学-Spring-Boot2"><a href="#B站大学-Spring-Boot2" class="headerlink" title="B站大学-Spring Boot2"></a>B站大学-Spring Boot2</h1>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring Boot2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔记</tag>
      
      <tag>Spring Boot2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板引擎Thymeleaf</title>
    <link href="/2022/04/03/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8EThymeleaf/"/>
    <url>/2022/04/03/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8EThymeleaf/</url>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/04/04/gxQAuC9npN7arS1.png"></p><h1 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h1><p><a href="https://www.thymeleaf.org/index.html">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Thymeleaf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode practise</title>
    <link href="/2021/12/26/LeetCode/"/>
    <url>/2021/12/26/LeetCode/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode刷题笔记"><a href="#LeetCode刷题笔记" class="headerlink" title="LeetCode刷题笔记"></a>LeetCode刷题笔记</h2><div class="note note-secondary">            <p><strong>26. 删除有序数组中的重复项</strong></p><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成</p>          </div><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-type">int</span> head=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]!=nums[i-<span class="hljs-number">1</span>])&#123;<br>                    nums[head]=nums[i];<br>                    head++;<br>                &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>题目<code>26</code>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/perfect-number">https://leetcode-cn.com/problems/perfect-number</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>leetcode编程练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSM框架-SpringBoot初体验</title>
    <link href="/2021/10/06/2021-10-6-SSM%E6%A1%86%E6%9E%B6-SpringBoot%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/2021/10/06/2021-10-6-SSM%E6%A1%86%E6%9E%B6-SpringBoot%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot初体验"><a href="#SpringBoot初体验" class="headerlink" title="SpringBoot初体验"></a>SpringBoot初体验</h1><p><code>Java</code>语言从诞生之日起，就被广泛的应用在了服务器端，它接收来自浏览器的请求（<code>request</code>），在经过一系列的逻辑处理之后，向浏览器返回响应（<code>response</code>），这是典型的浏览器（<code>B</code>）&#x2F;服务器（<code>S</code>）工作模式，<code>Java</code>在服务器端扮演主要角色。</p><p>伴随着<code>Spring</code>和<code>Struts</code>的诞生，一种新的组合式框架<code>SSH</code> 得到了广泛的使用，其中的<code>H</code> 指的<code>Hibernate</code> 。 <code>Servlet</code>有一个很大的问题，就是不够模块化，所有的代码杂合在一起。比如业务处理和数据库操作放在一起，这样的代码维护性差。 <code>SSH</code>中的三个框架分别承担了一定的角色，互相之间耦合性较低。其中<code>Struts</code>负责流程控制，<code>Spring</code>负责业务控制，<code>Hibernate</code> 负责和数据库交接。</p><p><code>SSH</code>及其衍生框架也有一个问题，它们需要配置很多东西，比如数据源、数据库事务、日志、服务器等等。<code>SpringBoot</code>的出现解决了这个问题，基于“约定大于配置”的思想，<code>SpringBoot</code>提供了很多默认的配置，通常情况下，如果你没有特殊的要求，就不需要再考虑配置的事情。</p><h2 id="第1关：第一个Spring-Boot程序"><a href="#第1关：第一个Spring-Boot程序" class="headerlink" title="第1关：第一个Spring Boot程序"></a>第1关：第一个Spring Boot程序</h2><div class="note note-success">            <ul><li>如何创建一个<code>Spring Boot</code>程序；</li><li>如何创建一个<code>web</code>程序。</li></ul><p>具体创建过程此处不再赘述</p>          </div><p>课程视频 - 搭建一个SpringBoot 程序</p><p><video src="http://outin-396971199eed11e991a100163e1c7426.oss-cn-shanghai.aliyuncs.com/sv/e30d770-16d7bc98f14/e30d770-16d7bc98f14.mp4" controls="true" controlslist="nodownload" width="90%" height="55%" poster="http://video.educoder.net/00b6c9d22a644083ad2e4994156f960b/snapshots/98c3bcf9619c4525889a782a08944dfd-00005.jpg" __idm_id__="1063996417">您的浏览器不支持 video 标签。</video></p><h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><h4 id="项目启动类DemoApplication"><a href="#项目启动类DemoApplication" class="headerlink" title="项目启动类DemoApplication"></a><strong>项目启动类DemoApplication</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-comment">//注解SpringBootApplication表明项目基于SpringBoot，同时下面的类是整个项目的启动类。</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NetApplication</span> &#123;<br>    <span class="hljs-comment">//启动类有一个main函数是SpringBoot的特点之一，和普通的Java工程一样是使用main函数启动的。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//SpringApplication是SpringBoot框架的一个核心类，run是它的一个静态方法，方法的参数为当前类的Class对象和用户输入args</span><br>        SpringApplication.run(NetApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建一个Web程序"><a href="#创建一个Web程序" class="headerlink" title="创建一个Web程序"></a>创建一个Web程序</h4><p>首先，我们在导入的项目的<code>pom.xml</code>文件里加入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>注：该依赖引入了<code>web</code>模块开发需要的相关<code>jar</code>包，版本信息都由<code>spring-boot-starter-parent</code>控制。</p>          </div><p>接着创建一个<code>controller</code>包，并在下面创建一个<code>HelloController</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello Spring Boot!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该类被标记为@RestController，这意味着<code>Spring MVC</code>可以使用它来处理<code>Web</code>请求。 @RequestMapping 注释提供“路由”信息。它告诉<code>Spring</code>，任何带有<code>/</code>路径的<code>HTTP</code>请求都应该映射到<code>index（）</code>方法。 从浏览器调用或在命令行上使用<code>curl</code>时，该方法返回纯文本。 这是因为@RestController结合了@Controller和@ResponseBody，两个注释导致<code>Web</code>请求返回数据而不是视图。</p><p>这样一个简单的<code>Web</code>程序就搭建起来了，然后就可以运行该程序了，运行成功后，打开浏览器，输入<code>http://localhost:8080</code>，得到的页面如下：</p><p><img src="https://data.educoder.net/api/attachments/394623"></p><h3 id="任务代码"><a href="#任务代码" class="headerlink" title="任务代码"></a>任务代码</h3><div class="note note-secondary">            <p><strong>编程要求</strong></p><ul><li>补全代码，当在浏览器输入<code>http://localhost:8080/hello</code>时，页面返回<code>Say Hello!</code>.</li></ul>          </div><p><code>HelloController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-comment">//添加路由并编写相应方法</span><br><span class="hljs-comment">/**********   Begin   **********/</span><br>     <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>     <span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Say Hello!&quot;</span>;<br>     &#125;<br>   <span class="hljs-comment">/**********   End   **********/</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>DemoApplication.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoApplication</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//启动Spring Boot</span><br><span class="hljs-comment">/**********   Begin   **********/</span><br>       SpringApplication.run(DemoApplication.class,args);<br><span class="hljs-comment">/**********   End   **********/</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第2关：实现登录、注册、下线功能"><a href="#第2关：实现登录、注册、下线功能" class="headerlink" title="第2关：实现登录、注册、下线功能"></a>第2关：实现登录、注册、下线功能</h2><p><code>Spring Boot</code>非常适合<code>Web</code>应用程序开发，你可以使用其自带的<code>Tomcat</code>，<code>Jetty</code>，<code>Undertow</code>或<code>Netty</code>创建<code>HTTP</code>服务器。</p><h3 id="相关知识-1"><a href="#相关知识-1" class="headerlink" title="相关知识"></a>相关知识</h3><h4 id="Web-请求"><a href="#Web-请求" class="headerlink" title="Web 请求"></a>Web 请求</h4><p><code> Spring Boot</code>既然是<code>Web</code>后台框架，那么它就需要处理<code>Web</code>请求，我们来看一个典型的<code>Web</code>请求（按下<code>F12</code>键，选择网络，然后点击本网站的登录按钮，你看到的第一个请求如下）：</p><p><img src="https://data.educoder.net/api/attachments/358995" alt="图 1 Web请求图"></p><p>请求网址和地址栏的网址没有本质的区别，地址栏网址请求的是整个页面，而上面的这种网址请求的一般是页面中的一个具体的元素：一张图片，一段音乐等，它的粒度更小。</p><p>用<code>Spring Boot</code>处理这种请求的时候，关键是把不同的请求映射到不同的<code>Java</code> 方法上，比如我们可能会用<code>LoginAction()</code>方法来处理<code>/login</code>请求，而用<code>RegisterAction()</code>来处理<code>/register</code>请求。</p><h4 id="用-Spring-Boot-处理-Web-请求，添加-Java-类"><a href="#用-Spring-Boot-处理-Web-请求，添加-Java-类" class="headerlink" title="用 Spring Boot 处理 Web 请求，添加 Java 类"></a>用 Spring Boot 处理 Web 请求，添加 Java 类</h4><p>在上一关的代码的基础上做如下修改，我们的项目就能实现登录处理功能。</p><p>第一步，我们在<code>controller</code>包下新建一个类<code>BlogController</code>，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><span class="hljs-comment">//这里也可以有一个@RequestMapping(&quot;/test&quot;)，如果有，那么下面的第一个方法拦截的就是/test/login结尾的请求，也就是说，这里的注解配置的是上一层的拦截地址。</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogController</span> &#123;<br>    <span class="hljs-comment">//表示下面的方法处理的是以/login结尾的请求。</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">Login</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Welcome Login!&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">//表示下面的方法处理的是以/register结尾的请求。</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/register&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">Register</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Welcome Register!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还是按照上一关介绍的方法运行这个项目，运行成功后，打开浏览器，输入<code>http://localhost:8080/login</code>，得到的页面如下：</p><p><img src="https://data.educoder.net/api/attachments/359032" alt="图 2 页面一"><br>我们再输入<code>http://localhost:8080/register</code> ，得到的页面如下：</p><p><img src="https://data.educoder.net/api/attachments/359035" alt="图 3 页面二"></p><p>不同的请求被不同的方法做了处理，最终返回相应的结果。</p><h3 id="任务代码-1"><a href="#任务代码-1" class="headerlink" title="任务代码"></a>任务代码</h3><div class="note note-secondary">            <p><strong>编程要求</strong></p><p>本关的编程任务是在右侧的<code>Begin</code>和<code>End</code>中间添加一个具有下线功能的<code>Java</code>方法，要求该方法能处理以<code>/logout</code>结尾的<code>Web</code>请求，然后返回字符串<code>GoodBye!</code>。（方法的名字不做限制）</p>          </div><p><code>MyController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.educoder.net;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;<br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyController</span> &#123;<br><span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">Login</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Welcome Login!&quot;</span>;<br>&#125;<br><span class="hljs-meta">@RequestMapping(&quot;/register&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">Register</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Welcome Register!&quot;</span>;<br>&#125;<br><span class="hljs-comment">/********* Begin *********/</span><br><span class="hljs-meta">@RequestMapping(&quot;/logout&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">Logout</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;GoodBye!&quot;</span>;<br>&#125;<br><span class="hljs-comment">/********* End *********/</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第3关：Spring-Boot练习题"><a href="#第3关：Spring-Boot练习题" class="headerlink" title="第3关：Spring Boot练习题"></a>第3关：Spring Boot练习题</h2><div class="note note-primary">            <ul><li>如何获取<code>Web</code>请求对象；</li><li>如何获取<code>Web</code>请求返回的内容。</li></ul>          </div><h3 id="相关知识-2"><a href="#相关知识-2" class="headerlink" title="相关知识"></a>相关知识</h3><h4 id="Sprig-Boot整合AOP"><a href="#Sprig-Boot整合AOP" class="headerlink" title="Sprig Boot整合AOP"></a>Sprig Boot整合AOP</h4><p>在<code>pom.xml</code>中添加相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="如何获取-Web-请求对象"><a href="#如何获取-Web-请求对象" class="headerlink" title="如何获取 Web 请求对象"></a>如何获取 Web 请求对象</h4><p>在<code>Spring Boot</code>中我们可以通过<code>RequestContextHolder</code>很方便的获取请求对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletRequestAttributes</span> <span class="hljs-variable">attributes</span> <span class="hljs-operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();<br><span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> attributes.getRequest();<br></code></pre></td></tr></table></figure><p>获取<code>HttpServletRequest</code>对象后，我们可以获取其中的许多信息，比如：</p><ul><li><p><code>request.getRequestURL()</code>可以获取<code>URL</code>；</p></li><li><p><code>request.getMethod()</code>可以获取请求方式。</p></li><li><p>#####如何获取 Web 请求返回的内容 </p></li><li><p>使用<code>@AfterReturning</code>通知在切入点返回内容之后切入内容（用来对处理返回值做一些加工处理）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;webLog()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAfterReturning</span><span class="hljs-params">(Object ret)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// 获取处理完请求后的返回内容</span><br>        logger.info(<span class="hljs-string">&quot;RESPONSE : &quot;</span> + ret);<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="任务代码-2"><a href="#任务代码-2" class="headerlink" title="任务代码"></a>任务代码</h3><div class="note note-secondary">            <p><strong>编程要求</strong></p><p>请仔细阅读右侧代码，根据方法内的提示，在<code>Begin - End</code>区域内进行代码补充（有个<code>pom.xml</code>需要填充相关依赖），使用<code>AOP</code>记录<code>Web</code>登录请求日志，获取请求<code>URL</code>，请求方式以及请求后的返回内容。 </p><p>并在请求内容前后输出<code>---------------请求内容----------------</code> </p><p>在返回内容前后输出<code>---------------返回内容----------------</code>。 </p><p>后台会自动启动该<code>Spring Boot</code>工程并请求以<code>/Login</code>结尾的<code>Web</code>请求。</p>          </div><p><code>BlogAspect.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yy.hello;<br><span class="hljs-keyword">import</span> java.util.Enumeration;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.aspectj.lang.JoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.AfterReturning;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.context.request.RequestContextHolder;<br><span class="hljs-keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;<br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogAspect</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(getClass());<br>    <span class="hljs-comment">//定义切点</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(public * com.yy.hello.controller.Blog.Login())&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">webLog</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>    <span class="hljs-comment">//前置通知，方法调用前被调用</span><br>    <span class="hljs-meta">@Before(&quot;webLog()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBefore</span><span class="hljs-params">(JoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>  <span class="hljs-comment">/**********   Begin   **********/</span><br>        <span class="hljs-comment">// 获取HttpServletRequest对象</span><br>        <span class="hljs-type">ServletRequestAttributes</span> <span class="hljs-variable">attributes</span> <span class="hljs-operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> attributes.getRequest();<br>        <span class="hljs-comment">// 打印所给要求中的固定格式</span><br>        logger.info(<span class="hljs-string">&quot;---------------请求内容----------------&quot;</span>);<br>        <span class="hljs-comment">//打印URL</span><br>        logger.info(<span class="hljs-string">&quot;URL : &quot;</span>+request.getRequestURL());<br>        <span class="hljs-comment">//打印请求方式</span><br>        logger.info(<span class="hljs-string">&quot;HTTP_METHOD : &quot;</span>+request.getMethod());<br>        <span class="hljs-comment">// 打印所给要求中的固定格式</span><br>        logger.info(<span class="hljs-string">&quot;---------------请求内容----------------&quot;</span>);<br>  <span class="hljs-comment">/**********   End   **********/</span><br>    &#125;<br>    <span class="hljs-comment">//在方法执行完结后打印返回内容</span><br>    <span class="hljs-meta">@AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;webLog()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAfterReturning</span><span class="hljs-params">(Object ret)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>  <span class="hljs-comment">/**********   Begin   **********/</span><br>        <span class="hljs-comment">// 打印所给要求中的固定格式</span><br>        logger.info(<span class="hljs-string">&quot;---------------返回内容----------------&quot;</span>);<br>        <span class="hljs-comment">// 处理完请求，打印返回内容</span><br>        logger.info(<span class="hljs-string">&quot;RESPONSE : &quot;</span> + ret);<br><span class="hljs-comment">// 打印所给要求中的固定格式</span><br>        logger.info(<span class="hljs-string">&quot;---------------返回内容----------------&quot;</span>);<br>  <span class="hljs-comment">/**********   End   **********/</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Blog.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yy.hello.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Blog</span> &#123;<br><br>    <span class="hljs-comment">//添加路由映射到/Login并编写相应方法返回Welcome Login!</span><br><span class="hljs-comment">/**********   Begin   **********/</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/Login&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">Login</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Welcome Login!&quot;</span>; <br>    &#125;<br>   <span class="hljs-comment">/**********   End   **********/</span><br>&#125;<br></code></pre></td></tr></table></figure><center><b>END</b></center><center><img src="https://cdn.jsdelivr.net/gh/Manchesterss/picx-image@main/2020/幻想逍遥侠_20210907_191550.7eshnl3j6gc0.gif" style="zoom:200%;" /></center><blockquote><p>头歌编程：<a href="https://www.educoder.net/shixuns/mgjhuns8/challenges">SpringBoot初体验</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>SSM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSM框架-Redis</title>
    <link href="/2021/10/06/SSM%E5%85%B3%E4%BA%8ERedis/"/>
    <url>/2021/10/06/SSM%E5%85%B3%E4%BA%8ERedis/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Redis概述"><a href="#1-Redis概述" class="headerlink" title="1.Redis概述"></a>1.Redis概述</h1><h2 id="第1关：Redis简介"><a href="#第1关：Redis简介" class="headerlink" title="第1关：Redis简介"></a>第1关：Redis简介</h2><p><img src="https://data.educoder.net/api/attachments/236592"></p><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。</p><p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><h4 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a><strong>Redis是什么？</strong></h4><p><code>Redis</code>是一个完全开源免费、高性能的<code>key-value</code>数据库。所谓<code>key-value</code>数据库是一种以<strong>键值对</strong>存储数据的数据库。类比于<code>Java</code>中的<code>Map</code>，可以将整个数据库理解为一个大型的<code>Map</code>，每个键都会对应一个唯一的值。 <code>Redis</code>与其他<code>key-value</code>产品相比有以下三个特点：</p><ul><li><code>Redis</code>支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用；</li><li><code>Redis</code>不仅仅支持简单的<code>key-value</code>类型的数据，同时还提供<code>list</code>，<code>set</code>，<code>zset</code>，<code>hash</code>等数据结构的存储；</li><li><code>Redis</code>支持数据的备份，即<code>master-slave</code>(主从)模式的数据备份。</li></ul><p><code>Redis</code>数据库的下载安装请参考<code>Redis</code><a href="http://www.redis.cn/">中文官方网站</a>。</p><h4 id="Redis-的优势"><a href="#Redis-的优势" class="headerlink" title="Redis 的优势"></a>Redis 的优势</h4><ul><li>性能极高，官方数据表示<code>Redis</code>能读的速度是<code>110000</code>次每秒，写的速度是<code>81000</code>次&#x2F;秒 ；</li><li>丰富的数据类型， <code>Redis</code>支持二进制案例的<code>Strings</code>， <code>Lists</code>， <code>Hashes</code>， <code>Sets</code> 及 <code>Ordered Sets</code> 数据类型操作；</li><li>原子性，<code>Redis</code>的所有操作都是原子性的，意思就是要么成功执行，要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过<code>MULTI</code>和<code>EXEC</code>指令包起来；</li><li>丰富的特性，<code>Redis</code>还支持 <code>publish/subscribe</code>(发布订阅)， 通知， <code>key</code>过期等等特性。</li></ul><h4 id="Redis-的用途"><a href="#Redis-的用途" class="headerlink" title="Redis 的用途"></a>Redis 的用途</h4><p><code>Redis</code>的所有数据在使用时都存放在内存中，由于<code>Redis</code>的性能极高，且数据类型丰富等优势，<code>Redis</code>通常被用来缓存应用经常被访问的热点数据。当然，<code>Redis</code>还有其它用途，如分布式锁、计数器等等，不详细介绍。</p><h4 id="Java-中连接Redis"><a href="#Java-中连接Redis" class="headerlink" title="Java 中连接Redis"></a>Java 中连接Redis</h4><p>在<code>Java</code>中使用<code>Redis</code>前，我们需要确保已经安装了<code>Redis</code>服务及对应的<code>Java Redis</code>驱动，并且在你的机器上配置好了<code>Java</code>环境。这些环境配置在实训环境中已经为你配置好了，在此不需要关注。如果在自己电脑上使用，需要从官网下载<code>Redis</code>安装，并把<code>Java Redis</code>驱动文件<code>Jedis.jar</code>添加到<code>ClassPath</code>中。</p><p>下面代码是完成环境配置后，在<code>Java</code>代码中连接<code>Redis</code>的示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> step3;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnRedisDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//redis数据所在的主机，如果是redis安装在本机，则是localhost或127.0.0.1</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">redisHost</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.1.134&quot;</span>;<br>        <span class="hljs-type">int</span> redisPort=<span class="hljs-number">6379</span>;<span class="hljs-comment">//Redis监听的端口，默认为6379</span><br>        <span class="hljs-comment">//创建1个Jedis对象。这是用来操作Redis数据库</span><br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(redisHost,redisPort);<br>        System.out.println(<span class="hljs-string">&quot;连接成功&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">resp</span> <span class="hljs-operator">=</span> jedis.ping();<span class="hljs-comment">//调用jedis的方法，查看服务是否运行</span><br>        System.out.println(<span class="hljs-string">&quot;Redis服务正在运行&quot;</span> + resp);<span class="hljs-comment">//</span><br>        jedis.close();<span class="hljs-comment">//关闭redis连接</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，我们连接的是位于主机<code>192.168.1.134</code>上的<code>Redis</code>数据库，<code>Redis</code>数据库监听的端口号为<code>6379</code>（默认端口）。如果<code>Redis</code>服务正常运行，上面代码输出如下。</p><div class="note note-info">            <ol><li><code>连接成功</code></li><li><code>Redis服务正在运行PONG</code></li></ol>          </div><h4 id="Redis-字符串实例"><a href="#Redis-字符串实例" class="headerlink" title="Redis 字符串实例"></a>Redis 字符串实例</h4><p><code>Redis</code>支持的数据类型非常丰富，下面是一个操作字符串类型<code>key-value</code>的示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> step3;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> zpengx@outlook.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisStrDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">redisHost</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.1.128&quot;</span>;<span class="hljs-comment">//Redis数据所在的主机</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">redisPort</span> <span class="hljs-operator">=</span> <span class="hljs-number">6379</span>;<span class="hljs-comment">//Redis监听的端口，默认为6379</span><br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(redisHost, redisPort);<br>        System.out.println(<span class="hljs-string">&quot;连接成功&quot;</span>);<br>        <span class="hljs-comment">//保存一个字符串类型的key-value对到Redis中</span><br>        jedis.set(<span class="hljs-string">&quot;educoder&quot;</span>, <span class="hljs-string">&quot;www.educoder.net&quot;</span>);<br>        <span class="hljs-comment">//根据key从Redis中取出数据输出</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;educoder&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">val2</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;educoder2&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Redis存储的字符串为: &quot;</span> + val);<br>        System.out.println(<span class="hljs-string">&quot;Redis存储的字符串为: &quot;</span> + val2);<br>        jedis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们通过指定<code>IP</code>和端口连接上对应的<code>Redis</code>数据库，然后把一个<code>key</code>为<code>educoder</code>，<code>value</code>为<code>www.educoder.net</code>的键值对存入<code>Redis</code>中，然后通过<code>key</code>获取对应的<code>value</code>的值。而对于<code>jedis.get(&quot;educoder2&quot;)</code>，因为<code>Redis</code>中没有<code>key</code>为<code>educoder2</code>的键值对，所以返回<code>null</code>。上面代码的输出结果如下：</p><div class="note note-info">            <ol><li><code>连接成功</code></li><li><code>Redis存储的字符串为: www.educoder.net</code></li><li><code>Redis存储的字符串为: null</code></li></ol>          </div><h3 id="任务代码"><a href="#任务代码" class="headerlink" title="任务代码"></a>任务代码</h3><div class="note note-secondary">            <p><strong>编程要求</strong></p><p>现有键值对：<code>key1</code>:<code>welcome</code>，<code>key2</code>:<code>to</code>，<code>key3</code>:<code>www</code>，<code>key4</code>:<code>educoder</code>，<code>key5</code>:<code>net</code>。根据提示，在右侧编辑器 Begin-End 区间补充<code>redisExec(Jedis jedis)</code>方法的代码，实现如下功能：</p><ul><li>把上面这些键值对存入<code>Redis</code>中；</li><li>根据<code>key</code>从<code>Redis</code>中取出<code>value</code>的值，拼成一个字符串并返回，相邻<code>value</code>之间有空格。</li></ul><p>返回的字符串为<code>welcome to www educoder net </code>，测试代码会输出返回的字符串。</p>          </div><p class="note note-light">RedisDemo.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String[] keys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-string">&quot;key4&quot;</span>, <span class="hljs-string">&quot;key5&quot;</span>&#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String[] values = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;welcome&quot;</span>, <span class="hljs-string">&quot;to&quot;</span>, <span class="hljs-string">&quot;www&quot;</span>, <span class="hljs-string">&quot;educoder&quot;</span>, <span class="hljs-string">&quot;net&quot;</span>&#125;;<br><br>    <span class="hljs-comment">//jedis对象已经连接Redis数据库，请直接使用jedis对象操作</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">redisExec</span><span class="hljs-params">(Jedis jedis)</span> &#123;<br>        <br>        <span class="hljs-comment">//retStr保存拼接的字符串</span><br>        <span class="hljs-comment">//期望的返回结果是welcome to www educoder net</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">retStr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>        <span class="hljs-comment">/********** Begin *********/</span><br>        String val=<span class="hljs-string">&quot;&quot;</span>;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;keys.length;i++)&#123;<br>            jedis.set(keys[i],values[i]);<br>            val=val+jedis.get(keys[i])+<span class="hljs-string">&#x27; &#x27;</span>;<br>         &#125;<br>        jedis.close();<br>        retStr.append(val);<br>        <span class="hljs-comment">/********** End *********/</span><br>        <br>        <span class="hljs-keyword">return</span> retStr.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-Redis常用数据结构"><a href="#2-Redis常用数据结构" class="headerlink" title="2.Redis常用数据结构"></a>2.<strong>Redis常用数据结构</strong></h1><h2 id="第1关：Redis中的数据结构"><a href="#第1关：Redis中的数据结构" class="headerlink" title="第1关：Redis中的数据结构"></a>第1关：Redis中的数据结构</h2><h3 id="相关知识-1"><a href="#相关知识-1" class="headerlink" title="相关知识"></a>相关知识</h3><h4 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h4><p><code>Redis </code>是一个速度非常快的非关系型数据库（<code>non-relational database</code>），它可以存储键（<code>key</code>）和五种不同类型的值（<code>value</code>）之间的映射（<code>mapping</code>），可基于内存存储亦可持久化到硬盘的日志型，<code>Key-Value</code> 数据库。</p><h4 id="Redis与其他数据库的对比"><a href="#Redis与其他数据库的对比" class="headerlink" title="Redis与其他数据库的对比"></a>Redis与其他数据库的对比</h4><p>如果你使用过关系型数据库，例如：<code>Mysql</code>，那么你肯定写过关联两张表数据的查询语句。而 <code>Redis </code>属于 <code>NoSQL</code>，它不使用表，也不会预定义数据模式或强制用户对 <code>Redis </code>的各种数据进行关联。</p><blockquote><p><code>NoSQL</code>（<code>Not Only SQL</code>）</p></blockquote><blockquote><p>意指“不仅仅是<code>SQL</code>”，其泛指非关系型数据库，主要分为四类：键值（<code>Key-Value</code>）存储数据库，列存储数据库，文档型数据库，图形（<code>Graph</code>）数据库。</p></blockquote><p><code>Redis </code>也经常与高性能键值缓存服务器 <code>memcached</code> 做比较：两者均可用于存储键值映射，性能相差也甚少，但 <code>Redis </code>能存储除普通字符串值之外的四种数据结构，而 <code>memcached</code> 只能存储普通的字符串值。这些不同使得 <code>Redis </code>能够解决更为广泛的问题，而且既能作为主数据库使用，也可以作为辅助数据库使用。</p><p>我们通过一张表来对比常用的数据库与缓存服务器：</p><table><thead><tr><th>名称</th><th>类型</th><th>数据存储选项</th><th>查询类型</th><th>附加功能</th></tr></thead><tbody><tr><td><code>Redis</code></td><td>基于内存的非关系型数据库</td><td>字符串、列表、集合、哈希、有序集合</td><td>针对数据类型有专属命令，另有批量操作和不完全的事务支持</td><td>发布与订阅、复制、持久化、脚本扩展</td></tr><tr><td><code>memcached</code></td><td>基于内存的键值<strong>缓存</strong></td><td>键值映射</td><td>创建、读取、更新、删除等</td><td>多线程支持</td></tr><tr><td><code>MySQL</code></td><td>关系型数据库</td><td>数据表、视图等</td><td>查询、插入、更新、删除、内置函数、自定义存储过程等</td><td>支持 <code>ACID</code> 性质、复制等</td></tr><tr><td><code>MongoDB</code></td><td>基于硬盘的非关系型文档存储数据库</td><td>无 <code>schema</code> 的 <code>BSON</code> 文档</td><td>创建、读取、更新、删除、条件查询等</td><td>复制、分片、空间索引等</td></tr></tbody></table><h4 id="Redis的特性"><a href="#Redis的特性" class="headerlink" title="Redis的特性"></a>Redis的特性</h4><p>由于 <code>Redis </code>是内存型数据库，在使用之前就要考虑当服务器被关闭时，服务器存储的数据是否能保留。Redis 拥有两种不同形式的持久化方法，都可以用紧凑的格式将数据写入硬盘：</p><ul><li><p><code>RDB</code>持久化</p><ul><li>在指定的时间间隔内生成数据集的时间点快照</li></ul></li><li><p><code>AOF</code> 持久化</p><ul><li>记录服务器执行的所有写操作命令</li><li>新命令会被<strong>追加</strong>到文件的末尾</li><li>在服务器启动时，通过重新执行这些命令还原数据集</li></ul></li></ul><p>除此之外，为了扩展 <code>Redis </code>的读性能，并为 <code>Redis </code>提供故障转移支持，<code>Redis </code>实现了主从复制特性：</p><ul><li>执行复制的从服务器连接主服务器<ul><li>接收主服务器发送的初始副本</li><li>接收主服务器执行的所有写命令</li></ul></li><li>在从服务器上执行所有写命令，实时更新数据库</li><li>读命令可以向任意一个从服务器发送</li></ul><h4 id="快速安装-Redis"><a href="#快速安装-Redis" class="headerlink" title="快速安装 Redis"></a>快速安装 Redis</h4><p>为了避免安装到旧版 <code>Redis </code>的问题，我们直接使用源码编译安装 <code>Redis</code>，首先你需要获取并安装 <code>make</code> 等一系列构建工具：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ sudo apt-get update<br>$ sudo apt-get install make gcc python-dev<br></code></pre></td></tr></table></figure><p>构建工具安装完毕后，你需要执行以下操作：</p><ul><li>从 <code>https://redis.io/download</code> 下载最新的稳定版本 <code>Redis </code>源码</li><li>解压源码，编译、安装并启动 <code>Redis</code></li></ul><p>其中，安装 <code>Redis </code>的过程如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">~:$ wget -q http://download.redis.io/releases/redis-<span class="hljs-number">5.0</span>.<span class="hljs-number">0</span>.tar.gz<br>~:$ tar -xzf redis-<span class="hljs-number">5.0</span>.<span class="hljs-number">0</span>.tar.gz<br>~:$ cd redis-<span class="hljs-number">5.0</span>.<span class="hljs-number">0</span><br><span class="hljs-comment"># 注意观察编译消息，最后不应该产生任何错误（`Error`）</span><br>~/redis-<span class="hljs-number">5.0</span>.<span class="hljs-number">0</span>:$ make<br><span class="hljs-comment"># 注意观察安装消息，最后不应该产生任何错误（`Error`）</span><br>~/redis-<span class="hljs-number">5.0</span>.<span class="hljs-number">0</span>:$ sudo make install<br><span class="hljs-comment"># 启动 Redis 服务器，注意通过日志确认 Redis 顺利启动</span><br>~/redis-<span class="hljs-number">5.0</span>.<span class="hljs-number">0</span>:$ redis-server redis.conf<br></code></pre></td></tr></table></figure><p>除了上述的启动 Redis 服务器方式，你还可以通过 Redis 默认的配置在后台启动它（常用启动方式）：<br><span class="label label-success">$ redis-server &amp;</span></p><h4 id="Redis数据结构简介"><a href="#Redis数据结构简介" class="headerlink" title="Redis数据结构简介"></a>Redis数据结构简介</h4><p><code>Redis </code>的五种数据结构分别是：</p><ul><li>字符串（<code>STRING</code>）</li><li>列表（<code>LIST</code>）</li><li>集合（<code>SET</code>）</li><li>哈希（<code>HASH</code>）</li><li>有序集合（<code>ZSET</code>）</li></ul><p><code>ZSET</code> 可以说是 <code>Redis </code>特有的数据结构，我们会在之后的实训中详细介绍它，在本实训中，我们只简要介绍他们的功能和小部分命令。他们的存储的值如下：</p><table><thead><tr><th>结构类型</th><th>存储的值</th></tr></thead><tbody><tr><td><code>STRING</code></td><td>字符串、整数或浮点数</td></tr><tr><td><code>LIST</code></td><td>一个链表，上面的每个节点都是一个字符串</td></tr><tr><td><code>SET</code></td><td>包含若干个字符串的无序集合，且集合中的元素都是唯一的</td></tr><tr><td><code>HASH</code></td><td>包含键值对的无序散列表</td></tr><tr><td><code>ZSET</code></td><td>成员中的字符串与分值的有序映射，其排序由分值决定</td></tr></tbody></table><p>在安装完 <code>Redis </code>并启动了 <code>redis-server</code> 后，我们可以使用 <code>redis-cli</code> 控制台与 <code>Redis </code>进行交互，其启动方式是在终端中输入：<br><code>$ redis-cli</code></p><p>其会默认连接本机 <code>6379</code> 端口启动的 <code>Redis </code>服务器，接下俩你可以使用它来体验 <code>Redis </code>各种数据结构和其命令的使用。</p><h5 id="Redis中的字符串"><a href="#Redis中的字符串" class="headerlink" title="Redis中的字符串"></a>Redis中的字符串</h5><p><code>STRING</code> 拥有一些和其他键值存储相似的命令，比如 <code>GET</code>（获取值），<code>SET</code>（设置值），<code>DEL</code>（删除值）等，例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ redis-cli<br>redis-cli <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; set hello redis<br>OK<br>redis-cli <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; get hello<br><span class="hljs-string">&quot;redis&quot;</span><br>redis-cli <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; del hello<br>(integer) <span class="hljs-number">1</span><br>redis-cli <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; get hello<br>(nil)<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>SET</code> 命令的第一个参数是键（<code>Key</code>），第二个参数是值（<code>Value</code>）</li><li>尝试获取不存在的键时会得到一个 <code>nil</code></li></ul><h5 id="Redis中的列表"><a href="#Redis中的列表" class="headerlink" title="Redis中的列表"></a>Redis中的列表</h5><p>就像前面所说的，<code>Redis </code>中的列表是一个“链表”，这和大多数编程语言相似。所以他们的操作也十分相似：</p><ul><li><code>LPUSH</code> 命令可用于将元素推入列表的左侧</li><li><code>RPUSH</code> 命令可将元素推入列表的右侧</li><li><code>LPOP</code> 和 <code>RPOP</code> 就分别从列表的左侧和右侧弹出元素</li><li><code>LINDEX</code> 可以获取<strong>指定位置</strong>上的元素</li><li><code>LRANGE</code> 可以获取<strong>指定范围</strong>的全部元素</li></ul><p>我们通过 <code>redis-cli</code> 来亲自体验：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; rpush testlist item<br>(integer) <span class="hljs-number">1</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; rpush testlist item2<br>(integer) <span class="hljs-number">2</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; rpush testlist item<br>(integer) <span class="hljs-number">3</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lrange testlist <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;item&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;item2&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;item&quot;</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lindex testlist <span class="hljs-number">1</span><br><span class="hljs-string">&quot;item2&quot;</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lpop testlist<br><span class="hljs-string">&quot;item&quot;</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lrange testlist <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;item2&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;item&quot;</span><br></code></pre></td></tr></table></figure><p>我们可以看出，在列表中，元素可以重复出现。在后续的实训中，我们还会介绍更多列表命令，现在我们先来了解以下 <code>Redis </code>中的集合。</p><h5 id="Redis中的集合"><a href="#Redis中的集合" class="headerlink" title="Redis中的集合"></a>Redis中的集合</h5><p>集合和列表的区别就在于：列表可以存储多个相同的字符串，而集合通过散列表来保证存储的字符串都是各不相同的（这些散列表只有键，而没有对应的值）。</p><p>由于集合是无序的，所以我们只能通过统一的 <code>SADD</code> 命令将元素添加到集合中，<code>SREM</code> 命令将元素从集合中移除。你还可以通过：</p><ul><li><code>SMEMBERS</code> 命令获取到集合中的所有元素</li><li><code>SISMEMBER</code> 命令来判断一个元素是否已存在在集合中</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; sadd testset item<br>(integer) <span class="hljs-number">1</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; sadd testset item2<br>(integer) <span class="hljs-number">1</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; sadd testset item<br>(integer) <span class="hljs-number">0</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; smembers testset<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;item&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;item2&quot;</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; sismember testset item3<br>(integer) <span class="hljs-number">0</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; sismember testset item<br>(integer) <span class="hljs-number">1</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; srem testset item2<br>(integer) <span class="hljs-number">1</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; srem testset item2<br>(integer) <span class="hljs-number">0</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt;  smembers testset<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;item&quot;</span><br></code></pre></td></tr></table></figure><p>上面示例的集合中包含的元素少，所以执行 <code>SMEMBERS</code> 命令没有问题，一旦集合中包含的元素非常多时，<code>SMEMBERS</code> 命令的执行速度会很慢，所以要谨慎的使用这个命令。</p><h5 id="Redis中的哈希"><a href="#Redis中的哈希" class="headerlink" title="Redis中的哈希"></a>Redis中的哈希</h5><p>哈希可以存储多个键值对之间的映射。和字符串一样，哈希存储的值既可以是字符串又可以是数字值，并且可以对数字值进行自增&#x2F;自减操作。</p><p>哈希就像是一个缩小版的 <code>Redis</code>，有一系列命令对哈希进行插入、获取、删除：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hset testhash key1 value1<br>(integer) <span class="hljs-number">1</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hset testhash key2 value2<br>(integer) <span class="hljs-number">1</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hset testhash key1 newvalue<br>(integer) <span class="hljs-number">0</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hgetall testhash<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;key1&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;newvalue&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;key2&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;value2&quot;</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hdel testhash key2<br>(integer) <span class="hljs-number">1</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hget testhash key1<br><span class="hljs-string">&quot;newvalue&quot;</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hgetall testhash<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;key1&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;newvalue&quot;</span><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>hset</code>用于插入元素<ul><li>第一个参数为该哈希的键名，如果该哈希不存在，则创建一个</li><li>第二个参数为哈希中的<strong>域名</strong><ul><li>如果不存在，则创建该域，并与第三个参数的值进行映射</li><li>如果存在，则使用第三个参数更新该域的值</li></ul></li><li>第三个参数为哈希中的值</li></ul></li><li><code>hgetall</code> 会获取到该哈希的所有<strong>域-值对</strong></li><li><code>hget</code> 用于获取哈希中的某一个域</li><li><code>hdel</code> 用户<strong>删除</strong>哈希中的某一个域</li></ul><h5 id="Redis中的有序集合"><a href="#Redis中的有序集合" class="headerlink" title="Redis中的有序集合"></a>Redis中的有序集合</h5><p>有序集合和哈希一样，也是存储键值对。</p><p>只是有序集合的键被称为成员（<code>member</code>），每个成员都是唯一的，有序集合的值则被称为分值（<code>score</code>），这个分值必须为浮点数。所以有序集合既可以通过成员访问元素，也可以通过分值来排序元素。</p><p>我们可以通过：</p><ul><li><code>ZADD</code> 命令将带有指定分值的成员添加到有序集合中</li><li><code>ZRANGE</code> 命令根据分值有序排列后的集合获取到<strong>指定范围</strong>的元素</li><li><code>ZRANGEBYSCORE</code> 命令获取<strong>指定分值范围</strong>内的元素</li><li><code>ZREM</code> 命令从有序集合中删除<strong>指定成员</strong></li></ul><p>我们也可以在 <code>redis-cli</code> 中验证上述命令的功能：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zadd testzset <span class="hljs-number">100</span> member1<br>(integer) <span class="hljs-number">1</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zadd testzset <span class="hljs-number">200</span> member0<br>(integer) <span class="hljs-number">1</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zrange testzset <span class="hljs-number">0</span> -<span class="hljs-number">1</span> withscores<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;member1&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;100&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;member0&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;200&quot;</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zrangebyscore testzset <span class="hljs-number">0</span> <span class="hljs-number">150</span> withscores<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;member1&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;100&quot;</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zrem testzset member1<br>(integer) <span class="hljs-number">1</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zrange testzset <span class="hljs-number">0</span> -<span class="hljs-number">1</span> withscores<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;member0&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;200&quot;</span><br></code></pre></td></tr></table></figure><h3 id="任务代码-1"><a href="#任务代码-1" class="headerlink" title="任务代码"></a>任务代码</h3><div class="note note-secondary">            <p><strong>编程要求</strong></p><p>根据提示，打开命令行，启动 <code>Redis </code>客户端并创建一些值：</p><ul><li>使用默认配置<strong>后台启动</strong> Redis 服务器</li><li>启动 Redis 客户端 <code>redis-cli</code></li><li>设置<strong>字符串</strong><ul><li>键为 <code>hello</code></li><li>值为 <code>redis</code></li></ul></li><li>设置<strong>列表</strong>，键为 <code>educoder-list</code><ul><li>从列表左侧推入元素 <code>hello</code></li><li>从列表右侧推入元素 <code>educoder</code><br>从列表右侧推入元素 <code>bye</code></li><li>从列表右侧弹出一个元素</li></ul></li><li>设置<strong>集合</strong>，键为 <code>educoder-set</code><ul><li>添加元素<code> c</code></li><li>添加元素 <code>python</code></li><li>添加元素 <code>redis</code></li><li>删除元素 <code>c</code></li></ul></li><li>设置<strong>哈希</strong>，键为 <code>educoder-hash</code><ul><li>添加键：<code>python</code>，值为：<code>language</code></li><li>添加键：<code>ruby</code>，值为：<code>language</code></li><li>添加键:<code> redis</code>，值为：<code>database</code></li><li>删除键<code> ruby</code></li></ul></li><li>设置<strong>有序列表</strong>，键为 <code>educoder-zset</code><ul><li>添加成员 <code>jack</code>，分值为 <code>200</code></li><li>添加成员 <code>rose</code>，分值为 <code>400</code></li><li>添加成员 <code>lee</code>，分值为 <code>100</code></li></ul></li></ul>          </div><p class="note note-light">命令行</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">redis-cli<br>set hello redis<br>rpush educoder-list hello<br>rpush educoder-list educoder<br>sadd educoder-set python<br>sadd educoder-set redis<br>hset educoder-hash python language<br>hset educoder-hash redis database<br>zadd educoder-zset <span class="hljs-number">100.0</span> lee<br>zadd educoder-zset <span class="hljs-number">200.0</span> jack<br>zadd educoder-zset <span class="hljs-number">400.0</span> rose<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>命令行粘贴：<code>Ctrl</code>+<code>Shift</code>+<code>v</code> 或者鼠标右键粘贴</p>          </div><p><img src="https://cdn.jsdelivr.net/gh/Manchesterss/picx-image@main/2020/469A_30VG]KT(515%606K%606XN.716tubmjyzw0.png" alt="示例图"></p><h2 id="第2关：Java操作Redis的数据"><a href="#第2关：Java操作Redis的数据" class="headerlink" title="第2关：Java操作Redis的数据"></a>第2关：Java操作Redis的数据</h2><div class="note note-primary">            <p>连接 Redis</p>          </div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">redisHost</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><span class="hljs-type">int</span> redisPort=<span class="hljs-number">6379</span>;<br><span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(redisHost,redisPort);<br></code></pre></td></tr></table></figure><h3 id="相关知识-2"><a href="#相关知识-2" class="headerlink" title="相关知识"></a>相关知识</h3><h4 id="String数据类型"><a href="#String数据类型" class="headerlink" title="String数据类型"></a>String数据类型</h4><p>字符串是 Redis 最基本的数据结构，它将以一个键和一个值存储于 Redis 内部，它犹如 Java 的 Map 结构，让 Redis 通过键去找到值。常用命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置字符串</span><br>jedis.set(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br><span class="hljs-comment">//使用append 向字符串后面添加</span><br>jedis.append(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot; value2&quot;</span>);<br><span class="hljs-comment">// set覆盖字符串(如果有key的话会直接将value的值替换为当前值)</span><br>jedis.set(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value3&quot;</span>);<br><span class="hljs-comment">//设置数据过期时间(中间数字是秒数，为过期的时间)</span><br>jedis.setex(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;value&quot;</span>);<br><span class="hljs-comment">//一次添加多个key-value对</span><br>jedis.mset(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>);<br><span class="hljs-comment">//获取多个key的value</span><br>jedis.mget(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;key2&quot;</span>);<br><span class="hljs-comment">//批量删除</span><br>jedis.del(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;key2&quot;</span>);<br><span class="hljs-comment">//清除jedis所有key值</span><br>jedis.flushDB()<br></code></pre></td></tr></table></figure><h4 id="linked-list链表"><a href="#linked-list链表" class="headerlink" title="linked-list链表"></a>linked-list链表</h4><p>linked-list与客户端命令用的大概是一致的，<code>Redis </code>中的列表是一个“链表”，链表结构是 Redis 中一个常用的结构，它可以存储多个字符串，而且它是有序的。Redis 链表是双向的，因此即可以从左到右，也可以从右到左遍历它存储的节点。 </p><p>而链表结构的优势在于插入和删除的便利，因为链表的数据节点是分配在不同的内存 区域的，并不连续，只是根据上一个节点保存下一个节点的顺序来索引而己，无需移动元素。常用命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//向右侧添加数据</span><br>jedis.rpush(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>,<span class="hljs-string">&quot;value2&quot;</span>,<span class="hljs-string">&quot;value3&quot;</span>);<br><span class="hljs-comment">//向左侧添加数据</span><br>jedis.lpush(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>,<span class="hljs-string">&quot;value2&quot;</span>,<span class="hljs-string">&quot;value3&quot;</span>);<br><span class="hljs-comment">//获取List集合的长度</span><br>jedis.llen(<span class="hljs-string">&quot;key&quot;</span>);<br><span class="hljs-comment">//打印队列，从索引0开始，到倒数第1个（全部元素）</span><br><span class="hljs-comment">//如果stop比list的实际尾部大的时候，Redis会当它是最后一个元素的下标。</span><br>jedis.lrange(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)<br><span class="hljs-comment">//查找索引为1的值</span><br>jedis.lindex(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">1</span>)<br><span class="hljs-comment">//将索引为1的值替换为value4</span><br>jedis.lset(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;value4&quot;</span>);<br><span class="hljs-comment">//从队列左边弹出一个元素（删除）</span><br>jedis.lpop(<span class="hljs-string">&quot;key&quot;</span>)<br><span class="hljs-comment">//从队列右边弹出一个元素（删除）</span><br>jedis.rpop(<span class="hljs-string">&quot;key&quot;</span>)<br><span class="hljs-comment">/*中间数字为count</span><br><span class="hljs-comment"> count &gt; 0: 从左边开始移除值为 value 的元素，count为移除的个数。</span><br><span class="hljs-comment"> count &lt; 0: 从右侧开始移除值为 value 的元素，count为移除的个数。</span><br><span class="hljs-comment"> count = 0: 移除所有值为 value 的元素。*/</span><br>jedis.lrem(<span class="hljs-string">&quot;key&quot;</span>, -<span class="hljs-number">2</span>, <span class="hljs-string">&quot;value&quot;</span>);<br><span class="hljs-comment">//删除区间以外的元素</span><br>jedis.ltrim(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>Redis的集合是一个哈希表结构，它是无序的。集合可以对于两个或者两个以上的集合进行交集、差集与并集等等。对于集合而言，它的每一个元素都是不能重复的，当插入相同记录的时候都会失败。集合的每一个元素都是 String 数据结构类型。常用命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//新增集合，添加数据</span><br>jedis.sadd(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>, <span class="hljs-string">&quot;v2&quot;</span>, <span class="hljs-string">&quot;v3&quot;</span>);<br>jedis.sadd(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;v2&quot;</span>, <span class="hljs-string">&quot;v3&quot;</span>, <span class="hljs-string">&quot;v4&quot;</span>);<br><span class="hljs-comment">//获取集合中所有元素</span><br>jedis.smembers(<span class="hljs-string">&quot;key&quot;</span>)<br><span class="hljs-comment">//获取集合中的元素数量</span><br>jedis.scard(<span class="hljs-string">&quot;key&quot;</span>);<br><span class="hljs-comment">//获得两个集合的交集，并存储在一个关键的结果集</span><br>jedis.sinterstore(<span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;key2&quot;</span>);<br><span class="hljs-comment">//key1集合中，key2集合没有的元素，并存储在一个关键的结果集</span><br>jedis.sdiffstore(<span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;key2&quot;</span>);<br><span class="hljs-comment">//判断集合是否存在这元素，返回Boolean类型</span><br>jedis.sismember(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>);<br><span class="hljs-comment">//从集合里面随机获取一个元素</span><br>jedis.srandmember(<span class="hljs-string">&quot;key&quot;</span>);<br><span class="hljs-comment">//将集合元素转移到另一个集合中</span><br>jedis.smove(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;v2&quot;</span>);<br><span class="hljs-comment">//删除并获取一个集合里面的元素（从左侧开始）</span><br>jedis.spop(<span class="hljs-string">&quot;key&quot;</span>)<br><span class="hljs-comment">//从集合里删除一个或多个元素（指定）</span><br>jedis.srem( <span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;v2&quot;</span>, <span class="hljs-string">&quot;v3&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="Hash类型集合"><a href="#Hash类型集合" class="headerlink" title="Hash类型集合"></a>Hash类型集合</h4><p>Redis 中哈希结构就如同 Java 的 map 一样， 一个对象里面有许多键值对，它是特别适 合存储对象的，在 Redis 中，hash 是一个 String 类型的 field 和 value 的映射表，因此我们存储的数据实际在 Redis 内存中都是一个个字符串而己。 </p><p>在 Redis 中的哈希结构和字符串有着比较明显的不同。首先， 命令都是以 h 开头，代表操作的是 hash 结构。其次，大多数命令多了一个层级 field，这是 hash 结构的一个内部键，也就是说 Redis 需要通过 key 索引到对应的 hash 结构，再通过 field 来确定使用 hash 结构的哪个键值对。常用命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, String&gt; hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>hash.put(<span class="hljs-string">&quot;k1&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>);<br>hash.put(<span class="hljs-string">&quot;k2&quot;</span>, <span class="hljs-string">&quot;v2&quot;</span>);<br>hash.put(<span class="hljs-string">&quot;k3&quot;</span>, <span class="hljs-string">&quot;v3&quot;</span>);<br><span class="hljs-comment">//添加数据</span><br>jedis.hmset(<span class="hljs-string">&quot;key&quot;</span>, hash);<br><span class="hljs-comment">//追加数据</span><br>jedis.hset(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;k4&quot;</span>, <span class="hljs-string">&quot;100&quot;</span>);<br><span class="hljs-comment">//获取hash的所有元素(key值)</span><br>jedis.hkeys(<span class="hljs-string">&quot;key&quot;</span>);<br><span class="hljs-comment">//获取hash中所有的key对应的value值</span><br>jedis.hvals(<span class="hljs-string">&quot;key&quot;</span>);<br><span class="hljs-comment">//获取hash里所有元素的数量</span><br>jedis.hlen(<span class="hljs-string">&quot;key&quot;</span>);<br><span class="hljs-comment">//获取hash中全部的域和值,以  Map&lt;&gt; 的形式返回</span><br>jedis.hgetAll(<span class="hljs-string">&quot;key&quot;</span>);<br><span class="hljs-comment">//判断给定key值是否存在于 Hash 集中</span><br>jedis.hexists(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;k2&quot;</span>);<br><span class="hljs-comment">//获取hash里面指定字段对应的值</span><br>jedis.hget(key, <span class="hljs-string">&quot;aaa&quot;</span>)<br><span class="hljs-comment">//获取hash里面指定多个字段对应的值</span><br>jedis.hmget(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;k2&quot;</span>,<span class="hljs-string">&quot;k3&quot;</span>);<br><span class="hljs-comment">//删除指定的字段</span><br>jedis.hdel(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;k1&quot;</span>);<br><span class="hljs-comment">//如果字段值为Int类型，可以为值加上增量</span><br>jedis.hincrBy(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;k4&quot;</span>, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><h4 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h4><p>有序集合和集合命令是差不多的，只是在这些命令基础上，有序集合会多一个浮点数的分数，会增加对于排序的操作，这是我们需要注意的地方。常用命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//添加数据</span><br>jedis.zadd(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;k1&quot;</span>);<br>jedis.zadd(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">1500</span>, <span class="hljs-string">&quot;k2&quot;</span>);<br>jedis.zadd(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">2000</span>, <span class="hljs-string">&quot;k3&quot;</span>);<br>jedis.zadd(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">2500</span>, <span class="hljs-string">&quot;k4&quot;</span>);<br><span class="hljs-comment">//也可以直接添加Map集合</span><br>Map&lt;String, Double&gt; keyvalue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>keyvalue.put(<span class="hljs-string">&quot;k1&quot;</span>,<span class="hljs-number">1000.0</span>);<br>keyvalue.put(<span class="hljs-string">&quot;k2&quot;</span>,<span class="hljs-number">1500.0</span>);<br>keyvalue.put(<span class="hljs-string">&quot;k3&quot;</span>,<span class="hljs-number">2000.0</span>);<br>keyvalue.put(<span class="hljs-string">&quot;k4&quot;</span>,<span class="hljs-number">2500.0</span>);<br>jedis.zadd(<span class="hljs-string">&quot;key&quot;</span>,keyvalue);<br><span class="hljs-comment">//获取有序集合的数量</span><br>jedis.zcard(<span class="hljs-string">&quot;key&quot;</span>);<br><span class="hljs-comment">//查询集合所有元素名（左侧）</span><br>jedis.zrange(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br><span class="hljs-comment">//查询集合所有元素名（右侧）</span><br>jedis.zrevrange(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br><span class="hljs-comment">//查询指定范围内元素名</span><br>jedis.zrangeByScore(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">1000.0</span>,<span class="hljs-number">2000.0</span>);<br><span class="hljs-comment">//查询元素下标</span><br>jedis.zscore(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;k3&quot;</span>);<br><span class="hljs-comment">//删除元素</span><br>jedis.zrem(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;k2&quot;</span>);<br><span class="hljs-comment">//查询指定范围内元素的数量</span><br>jedis.zcount(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">1000.0</span>, <span class="hljs-number">2000.0</span>)<br><span class="hljs-comment">//查询集合所有内容（带有序列）</span><br>jedis.zrangeWithScores(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br><span class="hljs-comment">//查询指定范围的内容（带有序列）</span><br>jedis.zrangeByScoreWithScores(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">1000.0</span>,<span class="hljs-number">2000.0</span>);<br></code></pre></td></tr></table></figure><h3 id="任务代码-2"><a href="#任务代码-2" class="headerlink" title="任务代码"></a>任务代码</h3><div class="note note-secondary">            <p><strong>编程要求</strong></p><p>根据提示，在右侧编辑器补充代码，根据以下要求去使用Java 操作 Redis: 1、哈希表名为<code>name_password</code>。</p><ul><li>查询出用户有多少。</li><li>将<code>lisi</code>的密码修改为<code>ls456789</code>。</li></ul><p>2、有序列表名为<code>student_scores</code>。</p><ul><li>查询出分数为600分到800分之间的同学学生姓名和分数</li><li>小红的分数少加了20分，请给她加上去</li></ul>          </div><p class="note note-light">Step2RedisTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Tuple;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Step2RedisTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">redisHost</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">redisPort</span> <span class="hljs-operator">=</span> <span class="hljs-number">6379</span>;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(redisHost, redisPort);<br>        AddRedis addRedis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">AddRedis</span>();<br>        addRedis.add();<br>        <span class="hljs-comment">/**********Begin**********/</span><br>        <span class="hljs-comment">//查询出用户有多少</span><br>        System.out.println(<span class="hljs-string">&quot;用户数量为：&quot;</span>+jedis.hlen(<span class="hljs-string">&quot;name_password&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;------------------------&quot;</span>);<br>        <span class="hljs-comment">//将lisi的密码修改为ls456789</span><br>        jedis.hset(<span class="hljs-string">&quot;name_password&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-string">&quot;ls456789&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;修改后的密码为：&quot;</span>+jedis.hget(<span class="hljs-string">&quot;name_password&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;------------------------&quot;</span>);<br>        <span class="hljs-comment">//查询出分数为600分到800分之间的同学学生姓名和分数</span><br>        Set&lt;Tuple&gt; student_scores = jedis.zrangeByScoreWithScores(<span class="hljs-string">&quot;student_scores&quot;</span>, <span class="hljs-number">600</span>, <span class="hljs-number">800</span>);<br>        System.out.println(<span class="hljs-string">&quot;600分到800分之间的同学为：&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Tuple score:student_scores)&#123;<br>            System.out.println(score.getElement()+<span class="hljs-string">&quot;-&quot;</span>+score.getScore());<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;------------------------&quot;</span>);<br>        <span class="hljs-comment">//小红的分数错误了，少加了20分，请给她加上去</span><br>        jedis.zincrby(<span class="hljs-string">&quot;student_scores&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;xiaohong&quot;</span>);<br>        <span class="hljs-type">Double</span> <span class="hljs-variable">zscore</span> <span class="hljs-operator">=</span> jedis.zscore(<span class="hljs-string">&quot;student_scores&quot;</span>, <span class="hljs-string">&quot;xiaohong&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;小红的修改后的分数为：&quot;</span>+zscore);<br>        <span class="hljs-comment">/**********End**********/</span><br>        <span class="hljs-comment">//删除所有key值</span><br>        jedis.flushDB();<br>        jedis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-Redis一些常用的技术"><a href="#3-Redis一些常用的技术" class="headerlink" title="3.Redis一些常用的技术"></a>3.<strong>Redis一些常用的技术</strong></h1><h2 id="第1关：Redis-事务与锁机制"><a href="#第1关：Redis-事务与锁机制" class="headerlink" title="第1关：Redis 事务与锁机制"></a>第1关：Redis 事务与锁机制</h2><div class="note note-primary">            <p>1.Redis 的基础事务。 2.Redis 事务回滚。 3.使用 watch 命令监控事务。</p>          </div><h3 id="相关知识-3"><a href="#相关知识-3" class="headerlink" title="相关知识"></a>相关知识</h3><p>在 Redis 中，也存在多个客户端同时向 Redis 系统发送命令的并发可能性，因此同一个 数据，可能在不同的时刻被不同的线程所操纵，这样就出现了并发下的数据一致的问题。 为了保证异性数据的安全性，Redis 为提供了事务方案。下面就是Redis事务命令：</p><table><thead><tr><th>命令</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>multi</td><td>开始事务命令，之后的命令进入队列，而不会马上执行</td><td>在事务生存期间，所有的 Redis 关于数据结构的命令都会入队</td></tr><tr><td>watch key1 [key2 ……]</td><td>监听某些键，当被监听的键在事务执行前被修改，则事务会被回滚</td><td>使用乐观锁</td></tr><tr><td>unwatch key1 [key2 ……]</td><td>取消监听某些键</td><td></td></tr><tr><td>exec</td><td>执行事务，如果被监听的键没有被修改，则采用执行命令，否则就回滚命令</td><td>在执行事务队列存储的命令前，Redis 会检测被监听的键值对有没有发生变化，如果没有则执行命令，否则就回滚事务</td></tr><tr><td>discard</td><td>回滚事务</td><td>回滚进入队列的事务命令，之后就不能再用 exec命令提交了</td></tr></tbody></table><h4 id="Redis的基础事务"><a href="#Redis的基础事务" class="headerlink" title="Redis的基础事务"></a>Redis的基础事务</h4><p>multi 到 exec 命令之间的 Redis 命令将采取进入队列的形式，直至 exec 命令的出现，才会一次性发送队列里的命令去执行，而在执行这些命令的时候其他客户端就不能再插入任何命令了。 <img src="https://data.educoder.net/api/attachments/1036163" alt="事务过程演示"> 由上演示图可以看出，multi先开启了事务,然后进入set和get命令，发现传回来一个“QUEUED”的结果，说明Redis将命令放入队列中，但是并不会直接执行，等到执行exec命令时，才会把队列中的命令发给Redis服务器依次执行。最后输出显示出来“OK”和“value”。 也可以利用Java来开启 Redis 事务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Transaction transaction=jedis.multi();<br>transaction.set(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>);<br>transaction.get(<span class="hljs-string">&quot;key&quot;</span>);<br>System.out.println(transaction.exec());<br></code></pre></td></tr></table></figure><p>结果返回:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">[OK, value]<br></code></pre></td></tr></table></figure><h4 id="Redis-事务回滚"><a href="#Redis-事务回滚" class="headerlink" title="Redis 事务回滚"></a>Redis 事务回滚</h4><p>在Redis中，不仅仅需要注意事务处理，其回滚能力也与数据库不太一样。 如果回滚事务，则可以使用 discard 命令，它就会进入在事务队列中的命令，这样事务 中的方法就不会被执行了。 <img src="https://data.educoder.net/api/attachments/1036464" alt="事务回滚演示图"> 由上演示图可以看出，当我们使用了 discard 命令后，再使用 exec 命令时就会报错，因为 discard 命令已经取消了事务中的命令，而到了 exec 命令时，队列里面己经没有命令可以执行了，所以就出现了报错的情况。 Redis里面的事务也可以不使用 discard 自动回滚。分为倆种情况: 一种是数据类型错误。 <img src="https://data.educoder.net/api/attachments/1036941" alt="事务回滚演示2"> 另一种是命令格式错误。 <img src="https://data.educoder.net/api/attachments/1037122" alt="事务回滚演示3"> 通过上面两个例子，可以看出在执行事务命令的时候，在命令入队的时候， Redis 就会 检测事务的命令是否正确，如果不正确则会产生错误。无论之前和之后的命令都会被事务 所回滚，就变为什么都没有执行。当命令格式正确，而因为操作数据结构引起的错误，则 该命令执行出现错误，而其之前和之后的命令都会被正常执行。这点和数据库很不一样， 这是需要读者注意的地方。对于一些重要的操作，我们必须通过程序去检测数据的正确性， 以保证 Redis 事务的正确执行，避免出现数据不一致的情况。 Redis 之所以保持这样简易的 事务，完全是为了保证移动互联网的核心问题一一性能。</p><h4 id="使用-watch-命令监控事务"><a href="#使用-watch-命令监控事务" class="headerlink" title="使用 watch 命令监控事务"></a>使用 watch 命令监控事务</h4><p>在 Redis 中使用 watch 命令可以决定事务是执行还是回滚。 一般而言，可以在 multi 命 令之前使用 watch 命令监控某些键值对，然后使用 multi 命令开启事务，执行各类对数据结 构进行操作的命令，这个时候这些命令就会进入队列。当 Redis 使用 exec 命令执行事务的 时候，它首先会去比对被 watch 命令所监控的键值对，如果没有发生变化，那么它会执行 事务队列中的命令，提交事务；如果发生变化，那么它不会执行任何事务中的命令，而去 事务回滚。无论事务是否回滚， Redis 都会去取消执行事务前的 watch 命令。 例如： <img src="https://data.educoder.net/api/attachments/1037357"><br>watch 命令就是这样的一个功能。 然后，开启线程 业务逻辑，由 multi 命令提供这一功能。在执行更新前，比较当前线程副本保存的旧值和当 前线程共享的值是否一致，如果不一致，那么该数据己经被其他线程操作过，此次更新失 败。为了保持一致，线程就不去更新任何值，而将事务回滚：否则就认为它没有被其他线 程操作过，执行对应的业务逻辑， exec 命令就是执行“类似”这样的一个功能。</p><p>Java使用 watch 命令监控事务，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(redisHost,redisPort);<br>jedis.flushDB();<br>jedis.set(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>jedis.watch(<span class="hljs-string">&quot;key1&quot;</span>);<br>jedis.set(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;va1&quot;</span>);<br><span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> jedis.multi();<br>transaction.set(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>transaction.set(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>);<br>transaction.exec();<br>System.out.println(jedis.get(<span class="hljs-string">&quot;key2&quot;</span>));<br></code></pre></td></tr></table></figure><p>结果返回null值，说明改变监控的值导致事务里的命令全部不会执行。</p><h3 id="任务代码-3"><a href="#任务代码-3" class="headerlink" title="任务代码"></a>任务代码</h3><div class="note note-secondary">            <p><strong>编程要求</strong></p><p>根据提示，在右侧编辑器Begin-End补充代码，根据以下要求完成一个模拟一次银行卡支付扣款的流程： </p><p>1、当余额不足时，放弃所有被监控的键，返回false。</p><p>2、在余额扣除消费的金额，在支付金额里加上消费的金额。</p>          </div><p class="note note-light">TestRedis.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Transaction;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRedis</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">6379</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(host, port);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">payMent</span><span class="hljs-params">(<span class="hljs-type">int</span> deduction)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">int</span> balance=<span class="hljs-number">0</span>;  <span class="hljs-comment">// 余额</span><br>        <span class="hljs-comment">//设置余额金额</span><br>        <br>        jedis.set(<span class="hljs-string">&quot;balance&quot;</span>, <span class="hljs-string">&quot;100&quot;</span>);<br>        jedis.set(<span class="hljs-string">&quot;deduction&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>);<br>        <span class="hljs-comment">//监控扣款和余额</span><br>        jedis.watch(<span class="hljs-string">&quot;balance&quot;</span>, <span class="hljs-string">&quot;deduction&quot;</span>);<br>        <span class="hljs-comment">/***********Begin***********/</span><br>        <span class="hljs-comment">// 余额不足</span><br>        balance=Integer.parseInt(jedis.get(<span class="hljs-string">&quot;balance&quot;</span>));<br>        <span class="hljs-keyword">if</span>(balance&lt;deduction)&#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 开启事务</span><br>        <span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> jedis.multi();<br>        <span class="hljs-comment">//扣钱</span><br>        transaction.set(<span class="hljs-string">&quot;balance&quot;</span>, <span class="hljs-string">&quot;90&quot;</span>);<br>        transaction.set(<span class="hljs-string">&quot;deduction&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>);<br>        <span class="hljs-comment">//事务执行</span><br>        transaction.exec();<br>        <span class="hljs-comment">//返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">/***********End***********/</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">resultValue</span> <span class="hljs-operator">=</span> payMent(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (resultValue==<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;支付成功&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">balance</span> <span class="hljs-operator">=</span> Integer.parseInt(jedis.get(<span class="hljs-string">&quot;balance&quot;</span>));<br>            <span class="hljs-type">int</span> <span class="hljs-variable">deduction</span> <span class="hljs-operator">=</span> Integer.parseInt(jedis.get(<span class="hljs-string">&quot;deduction&quot;</span>));<br>            System.out.printf(<span class="hljs-string">&quot;本次扣款&quot;</span>+deduction+<span class="hljs-string">&quot;元，余额为&quot;</span>+balance+<span class="hljs-string">&quot;元&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;支付失败&quot;</span>);<br>        &#125;<br>    <br>        jedis.close();<br>    &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="第2关：流水线"><a href="#第2关：流水线" class="headerlink" title="第2关：流水线"></a>第2关：流水线</h2><div class="note note-primary">            <p>1.Redis 的流水线技术。</p>          </div><h3 id="相关知识-4"><a href="#相关知识-4" class="headerlink" title="相关知识"></a>相关知识</h3><h4 id="Redis-的流水线技术"><a href="#Redis-的流水线技术" class="headerlink" title="Redis 的流水线技术"></a>Redis 的流水线技术</h4><p>我们了解完 Redis 的基础事务后，也要知道 Redis 中的流水线技术。在事务中 Redis 提供了队列，这是一个可以批量执行任务的队列，这样性能就比较高，但是使用multi… exec 事务命令是有系统开销的，因为它会检测对应的锁和序列化命令。有时候我们希望在没有任何附加条件的场景下去使用队列批量执行一系列的命令，从而提高系统性能，这就是 Redis 的流水线 (pipelined）技术。 现如今Redis 执行读写速度十分快，而系统的瓶颈往往是在网络通信中的延时，例如当命令 1 在时刻 T1 发送到 Redis 服务器后， 服务器就很快执行完了命令 1，而命令 2 在 T2 时刻却没有通过网络送达 Redis 服务器，这 样就变成了 Redis 服务器在等待命令 2 的到来，当命令 2 送达，被执行后，而命令 3 又没 有送达 Redis, Redis 又要继续等待，依此类推，这样 Redis 的等待时间就会很长，很多时候在空闲的状态，而问题出在网络的延迟中，造成了系统瓶颈。 <img src="https://data.educoder.net/api/attachments/1040758"></p><p>为了解决这个问题，可以使用 Redis 的流水线， 但是 Redis 的流水线是一种通信协议，没有办法通过客户端演示给大家，不过我们可以通过 JavaAPI 或者使用 Spring 操作它，先使用 JavaAPI 去测试一下它的性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JedisPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> getPool();<br>       <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> pool.getResource();<br>       <span class="hljs-type">long</span> <span class="hljs-variable">start1</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>           jedis.set(<span class="hljs-string">&quot;k&quot;</span>+i,<span class="hljs-string">&quot;v&quot;</span>+i);<br>           jedis.get(<span class="hljs-string">&quot;k&quot;</span>+i);<br>       &#125;<br>       <span class="hljs-comment">// 结束时间</span><br>       <span class="hljs-type">long</span> <span class="hljs-variable">end1</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>       System.out.println(<span class="hljs-string">&quot;耗时: &quot;</span> + (end1 - start1) + <span class="hljs-string">&quot;毫秒&quot;</span>);<br>       <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>       <span class="hljs-comment">// 开启流水线</span><br>       <span class="hljs-type">Pipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> jedis.pipelined();<br>       <span class="hljs-comment">// 测试十万条读/写操作</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>           pipeline.set(<span class="hljs-string">&quot;k&quot;</span>+i,<span class="hljs-string">&quot;v&quot;</span>+i);<br>           pipeline.get(<span class="hljs-string">&quot;k&quot;</span> + i);<br>       &#125;<br>       <span class="hljs-type">List</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pipeline.syncAndReturnAll();<br>       <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>       System.out.println(<span class="hljs-string">&quot;耗时: &quot;</span> + (end - start) + <span class="hljs-string">&quot;毫秒&quot;</span>);<br>       jedis.close();<br>       <br></code></pre></td></tr></table></figure><p>上面没有用流水线的处理10000次请求时间大概为5000多毫秒，然而使用流水线的处理10000次请求时间大概500毫秒最右，最多快了十倍左右。所以我们平常使用 Redis 时不会经常去使用流水线，但是在企业公司或者较大数量的请求去使用 Redis 时，我们需要去考虑他的性能是不是最优，所以在这里使用流水线会大大减少我们处理的时间。</p><h3 id="任务代码-4"><a href="#任务代码-4" class="headerlink" title="任务代码"></a>任务代码</h3><div class="note note-secondary">            <p><strong>编程要求</strong></p><p>根据提示，在右侧编辑器Begin-End补充代码，按照以下要求开启一次流水线技术：</p><ul><li>开启流水线。</li><li>测试十万条读写操作,设置 key 值为 key0 、 key1 、 key2 …key99998、key99999，对应 value 值为 value0 、value1、value2…value99998、value99999。</li><li>结束流水线。</li></ul>          </div><p class="note note-light">RedisPipeline.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><span class="hljs-keyword">import</span> redis.clients.jedis.*;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisPipeline</span> &#123;<br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">pipeline</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">redisHost</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">redisPort</span> <span class="hljs-operator">=</span> <span class="hljs-number">6379</span>;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(redisHost, redisPort);<br>        jedis.flushDB();<br>        <span class="hljs-comment">/**********Begin**********/</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">// 开启流水线</span><br>        <span class="hljs-type">Pipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> jedis.pipelined();<br>        System.out.println(<span class="hljs-string">&quot;开启流水线&quot;</span>);<br>    <br>        <span class="hljs-comment">// 测试十万条读写操作</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>            pipeline.set(<span class="hljs-string">&quot;key&quot;</span>+i,<span class="hljs-string">&quot;value&quot;</span>+i);<br>            pipeline.get(<span class="hljs-string">&quot;key&quot;</span> + i);<br>        &#125;<br>    <br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">//关闭流水线</span><br>        <span class="hljs-type">List</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pipeline.syncAndReturnAll();<br>        System.out.println(<span class="hljs-string">&quot;消耗时间：&quot;</span>+(end-start)+<span class="hljs-string">&quot;毫秒&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;关闭流水线&quot;</span>);<br>        <span class="hljs-comment">/**********End**********/</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第3关：发布订阅"><a href="#第3关：发布订阅" class="headerlink" title="第3关：发布订阅"></a>第3关：发布订阅</h2><div class="note note-primary">            <p>1.Redis 发布订阅技术。2. 利用 Java 来实现发布订阅的流程。</p>          </div><h3 id="相关知识-5"><a href="#相关知识-5" class="headerlink" title="相关知识"></a>相关知识</h3><h4 id="Redis-发布订阅技术"><a href="#Redis-发布订阅技术" class="headerlink" title="Redis 发布订阅技术"></a>Redis 发布订阅技术</h4><p>其实发布订阅技术我们日常生活中常常见到，每次支付消费时，都会接收到一条交易信息，显示当前这笔消费的时间、金额等信息，这种便是一种发布订阅的模式。这里的发布是交易信息的发布，订阅则是各个渠道。这在 实际工作中十分常用， Redis 支持这样的一个模式。 发布订阅模式首先需要消息源，也就是要有消息发布出来，比如例子中的银行通知。首先是银行的系统，收到了交易的命令，成功记账后，它就会把消息发送出来，这个 时候，订阅者就可以收到这个消息进行处理了，观察者模式就是这个模式的典型应用了。 <img src="https://data.educoder.net/api/attachments/1043294"> </p><p>这里建立了一个消息渠道，短信系统和邮件系统都在监昕这个渠道，一旦记账系统把交易消息发送到消息渠道，则监昕这个渠道的各个系统就可以拿到这个消息，这样就能处理各自的任务了。它也有利于系统的拓展，比如现在新增一个彩信平台，只要让彩信平台去监听这个消息渠道便能得到对应的消息了。 从上面的分析可以知道以下两点：</p><ul><li>要有发送的消息渠道，让记账系统能够发送消息。</li><li>要有订阅者（短信、邮件、微信等系统）订阅这个渠道的消息。</li></ul><p>同样的， Redis 也是如此。首先来注册一个订阅的客户端，这个时候使用 SUBSCRIBE 命令，再用其他客户端使用PUBLISH将消息发布到订阅上，此时订阅的客户端显示被传输的消息。如下演示图： <img src="https://data.educoder.net/api/attachments/1043439" alt="发布订阅演示图"> 我们观察客户端 1 ，就可以发现已经收到了消息， 井有对应的信息打印出来。客户端的数字表示其出现的先后顺序，当发布消息的时候，对应的客户端已经获取到了这个信息。</p><h4 id="利用-Java-来实现发布订阅的流程"><a href="#利用-Java-来实现发布订阅的流程" class="headerlink" title="利用 Java 来实现发布订阅的流程"></a>利用 Java 来实现发布订阅的流程</h4><p>我们首先定义了一个Subscriber类，这个类继承了JedisPubSub类，并重新实现了其中的回调方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> redis.clients.jedis.JedisPubSub;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subscriber</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JedisPubSub</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Subscriber</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String channel, String message)</span> &#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;接收redis发布消息, 频道为 %s, 信息为 %s&quot;</span>, channel, message));<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSubscribe</span><span class="hljs-params">(String channel, <span class="hljs-type">int</span> subscribedChannels)</span> &#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;订阅redis频道成功, 频道为 %s, 订阅频道为 %d&quot;</span>,<br>                channel, subscribedChannels));<br>        System.out.println(<span class="hljs-string">&quot;请输入传输的信息：&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUnsubscribe</span><span class="hljs-params">(String channel, <span class="hljs-type">int</span> subscribedChannels)</span> &#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;取消订阅redis频道, 频道为 %s, 订阅频道为 %d&quot;</span>,<br>                channel, subscribedChannels));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Jedis 中，也提供了一个类 JedisPubSub，用来对订阅的 channel 进行监听。</p><ul><li>onPMessage：监听到订阅模式接受到消息时的回调</li><li>onMessage：监听到订阅频道接受到消息时的回调</li><li>onSubscribe：订阅频道时的回调</li><li>onUnsubscribe：取消订阅频道时的回调</li><li>onPSubscribe：订阅频道模式时的回调</li><li>onPUnsubscribe：取消订阅模式时的回调</li></ul><p>接下来订阅指定频道redis。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Subscriber subscriber=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Subscriber</span>();<br>jedis.subscribe(subscriber,<span class="hljs-string">&quot;redis&quot;</span>);<br></code></pre></td></tr></table></figure><p>然后在另外一台客户端发布订阅消息：</p><p> <img src="https://data.educoder.net/api/attachments/1044128" alt="发布订阅消息"> </p><p>此时控制台输出：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">接收redis发布消息, 频道为 redis, 信息为 hi redis<br>接收redis发布消息, 频道为 redis, 信息为 hi redis<br>接收redis发布消息, 频道为 redis, 信息为 hi redis<br></code></pre></td></tr></table></figure><h3 id="任务代码-5"><a href="#任务代码-5" class="headerlink" title="任务代码"></a>任务代码</h3><div class="note note-secondary">            <p><strong>编程要求</strong></p><p>根据提示，在右侧编辑器Begin-End补充代码，按照以下要求：</p><ul><li>在SubThread类中订阅指定频道<code>redis</code>。</li></ul>          </div><p class="note note-light">SubThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">import</span> redis.clients.jedis.JedisPool;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubThread</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JedisPool jedisPool;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Subscriber</span> <span class="hljs-variable">subscriber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subscriber</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;redis&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SubThread</span><span class="hljs-params">(JedisPool jedisPool)</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;SubThread&quot;</span>);<br>        <span class="hljs-built_in">this</span>.jedisPool = jedisPool;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;订阅redis, 订阅频道为 %s, 线程将被阻塞&quot;</span>, channel));<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        System.out.println(String.format(<span class="hljs-string">&quot;订阅redis频道成功, 频道为 %s, 订阅频道为 1&quot;</span>,<br>                channel));<br>        System.out.println(<span class="hljs-string">&quot;请输入传输的信息：&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">/************* Begin ***************/</span><br>            jedis = jedisPool.getResource();<br>            jedis.subscribe(subscriber, channel);<br>             <span class="hljs-comment">/************* End ***************/</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(String.format(<span class="hljs-string">&quot;订阅频道错误, %s&quot;</span>, e));<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) &#123;<br>                jedis.close();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第4关：超时命令"><a href="#第4关：超时命令" class="headerlink" title="第4关：超时命令"></a>第4关：超时命令</h2><div class="note note-primary">            <p>1.Redis 的超时命令。 2.使用 Spring 操作 Redis 超时命令。</p>          </div><h3 id="相关知识-6"><a href="#相关知识-6" class="headerlink" title="相关知识"></a>相关知识</h3><h4 id="Redis的超时命令"><a href="#Redis的超时命令" class="headerlink" title="Redis的超时命令"></a>Redis的超时命令</h4><p>我们平常使用的 Java 虚拟机，它提供垃圾回收的功能，此功能用来保证 Java 程序使用过的且不再使用的 Java 对象及时从内存中释放掉，使得内存空间还可用。当程序编写不当或者考虑欠缺的时候（比如读入大文件），内存就可能存储不下运行所需要的数据，那么 Java 虚拟机就会抛出内存溢出的异常而导致服务失败。同样， Redis 也是基于内存而运行的数据集合，也存在着对内存垃圾的回收和管理的问题。</p><p>Redis 基于内存，而内存对于一个系统是最宝贵的资源，而且它远远没有磁盘那么大，所以对于 Redis 的键值对的内存回收也是一个十分重要的问题，如果操作不当会产生 Redis 宕机的问题，使得系统性能低下。</p><p>当内存不足时 Redis 会触发自动垃圾回收的机制，而我们程序员可以通过<code>System.gc()</code>去建议 Java 虚拟机回收内存垃圾，他将可能触发一次 Java 虚拟机的回收机制，但是如果这样操作可能导致 Java 虚拟机在回收大量的内存空间的同时，引发性能低下的情况。对于 Redis 而言，del 命令是可以删除一些键值对，所以 Redis 比 Java 虚拟机更加灵活，允许删除一部分的键值对。与此同时，当内存运行空间满了之后，它还会按照回收机制去自动回收一些键值对，这和 Java 虚拟机又有相似之处，但是当垃圾进行回收的时候，又有可能执行回收而引发系统停顿，因此选择适当的回收机制和时间将有利于系统性能的提高，这是我们需要学习的地方。</p><p>我们学习 Redis 内存回收之前，首先要学习的是键值对的超市命令，因为大部分情况下，我们都想回收那些超时的键值对，并不是那些未超时的键值对。我们常用设置超时相关命令如下表：</p><table><thead><tr><th>命令</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>persist key</td><td>持久化key,取消超时时间</td><td>移除key的超时时间</td></tr><tr><td>ttl</td><td>查看key的超时时间</td><td>以秒计算，-1代表没有超时时间，如果不存在key或者key已经超时则为-2</td></tr><tr><td>expire key seconds</td><td>设置超时时间戳</td><td>以秒为单位</td></tr><tr><td>expireat key timestamp</td><td>设置超时时间点</td><td>用unix时间戳确定</td></tr><tr><td>pptl key milliseconds</td><td>查看key的超时时间戳</td><td>用毫秒计算</td></tr><tr><td>pexpire key</td><td>设置键值超时的时间</td><td>以毫秒为单位</td></tr><tr><td>pexpireat key stamptimes</td><td>设置超时时间点</td><td>以毫秒为单位的unix时间戳</td></tr></tbody></table><p>下面展示这些命令在 Redis 客户端的使用：</p><p><img src="https://data.educoder.net/api/attachments/1122999" alt=" 超时命令展示 "></p><p>我们探讨一个问题：如果 key 超时了，<strong>Redis 会回收 key 的存储空间吗？</strong>这也是面试时常常被问到的一个问题。 </p><p>答案是<strong>不会回收</strong>，大家要注意的是： Redis 的 key 超时不会被其自动回收，它只会标识键值对超时了。这样做的好处在于如果一个很大的键值对超时，比如一个列表或者哈希结构，存在数以百万个元素，要对其回收需要很长的时间。如果采用超时回收，则可能产生停顿。坏处也很明显，这些超时的键值对会浪费比较多的空间。</p><p>Redis 提供两种方式回收这些超时键值对，它们是定时回收和惰性回收。</p><ul><li>定时回收是指在确定的某个时间触发一段代码，回收超时的键值对</li><li>惰性回收则是当一个超时的键，被再次用 get 命令访问时，将触发 Redis 将其从内存中清空。</li></ul><p>定时回收可以完全回收那些超时的键值对，但是缺点也很明显，如果这些键值对比较多，则 Redis 需要运行比较长的时间，从而导致停顿，所以系统设计者一般会选择在没有业务发生的时刻触发 Redis 的定时回收，以便清理超时的键值对。对于惰性回收而言，它的优势在于可以指定回收超时的键值对，他的缺点是要执行一个莫名奇妙的 get 操作，或者在某些时候，我们也难以判断哪些键值对已经超时。</p><p>无论是定时回收还是惰性回收，都要一句自身的特点去定制策略，如果一个键值对，存储的是数以千万的数据，使用 expire 命令使其到达一个时间超时，然后用 get 命令访问触发其回收，显然会付出停顿代价，这是我们现实中需要考虑的。</p><h4 id="使用-Spring-操作Redis超时命令"><a href="#使用-Spring-操作Redis超时命令" class="headerlink" title="使用 Spring 操作Redis超时命令"></a>使用 Spring 操作Redis超时命令</h4><p>除了使用客户端，我们也可以使用 Java 执行超时命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.set(<span class="hljs-string">&quot;key1&quot;</span>,<span class="hljs-string">&quot;value1&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;key1值为：&quot;</span>+jedis.get(<span class="hljs-string">&quot;key1&quot;</span>)) ;<br>System.out.println(<span class="hljs-string">&quot;过期时间：&quot;</span>+jedis.ttl(<span class="hljs-string">&quot;key1&quot;</span>));<br>jedis.expire(<span class="hljs-string">&quot;key1&quot;</span>,<span class="hljs-number">120</span>);<br>System.out.println( <span class="hljs-string">&quot;过期时间：&quot;</span>+jedis.ttl(<span class="hljs-string">&quot;key1&quot;</span>)) ;<br>jedis.persist(<span class="hljs-string">&quot;key1&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;过期时间：&quot;</span>+jedis.ttl(<span class="hljs-string">&quot;key1&quot;</span>));<br>jedis.expireAt(<span class="hljs-string">&quot;key1&quot;</span>,<span class="hljs-number">1594185996</span>);<br>System.out.println(<span class="hljs-string">&quot;过期时间：&quot;</span>+jedis.ttl(<span class="hljs-string">&quot;key1&quot;</span>));<br></code></pre></td></tr></table></figure><p>上面这段代码采用的就是 Java 操作Redis超时命令的一个过程，输出为：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">key1值为：value1<br>过期时间：-<span class="hljs-number">1</span><br>过期时间：<span class="hljs-number">120</span><br>过期时间：-<span class="hljs-number">1</span><br>过期时间：<span class="hljs-number">6907</span><br></code></pre></td></tr></table></figure><p>我们也可以结合 Spring 来操作 Redis 超时命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        RedisTemplate redisTemplate=applicationContext.getBean(RedisTemplate.class);<br>        redisTemplate.execute((RedisOperations ops) -&gt; &#123;<br>            ops.boundValueOps(<span class="hljs-string">&quot;key1&quot;</span>).set(<span class="hljs-string">&quot;value1&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (String) ops.boundValueOps(<span class="hljs-string">&quot;key1&quot;</span>).get();<br>            System.out.println(<span class="hljs-string">&quot;value=&quot;</span> + value);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">expSecond</span> <span class="hljs-operator">=</span> ops.getExpire(<span class="hljs-string">&quot;key1&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;expSecond:&quot;</span> + expSecond);<br>            <span class="hljs-comment">// 设置120秒</span><br>            <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> ops.expire(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-number">120L</span>, TimeUnit.SECONDS);<br>            System.out.println(<span class="hljs-string">&quot;设置超时时间：&quot;</span> + flag);<br>            System.out.println(<span class="hljs-string">&quot;过期时间：&quot;</span> + ops.getExpire(<span class="hljs-string">&quot;key1&quot;</span>) + <span class="hljs-string">&quot;秒&quot;</span>);<br>            <span class="hljs-comment">// 持久化 key，取消超时时间</span><br>            flag = ops.persist(<span class="hljs-string">&quot;key1&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;取消超时时间：&quot;</span> + flag);<br>            System.out.println(<span class="hljs-string">&quot;过期时间：&quot;</span> + ops.getExpire(<span class="hljs-string">&quot;key1&quot;</span>));<br>                  <span class="hljs-comment">//System.currentTimeMillis获取的是UNIX时间戳至今的格林尼治时间数</span><br>            <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>            date.setTime(System.currentTimeMillis() + <span class="hljs-number">120000</span>);<br>            <span class="hljs-comment">// 设置超时时间点</span><br>            flag = ops.expireAt(<span class="hljs-string">&quot;key1&quot;</span>, date);<br>            System.out.println(<span class="hljs-string">&quot;设置超时时间：&quot;</span> + flag);<br>            System.out.println(<span class="hljs-string">&quot;过期时间：&quot;</span> + ops.getExpire(<span class="hljs-string">&quot;key1&quot;</span>));<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;);<br></code></pre></td></tr></table></figure><p>上面这段代码采用的就是 Spring 操作Redis超时命令的一个过程，输出为：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">value=value1<br>expSecond:-<span class="hljs-number">1</span><br>设置超时时间：true<br>过期时间：<span class="hljs-number">120</span>秒<br>取消超时时间：true<br>过期时间：-<span class="hljs-number">1</span><br>设置超时时间：true<br>过期时间：<span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><h3 id="任务代码-6"><a href="#任务代码-6" class="headerlink" title="任务代码"></a>任务代码</h3><div class="note note-secondary">            <p><strong>编程要求</strong></p><ul><li>根据提示，在右侧编辑器Begin-End补充代码，按照以下要求使用 Spring 操作 Redis 超时命令过程：<ul><li>创建键值对：key 值为“今天你吃了吗？”</li><li>获取 key 值</li><li>设置 key 的过期时间为 5 秒</li></ul></li></ul>          </div><p class="note note-light">OverTimeRedisTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.redis;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisOperations;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">import</span> redis.clients.jedis.JedisPool;<br><span class="hljs-keyword">import</span> redis.clients.jedis.JedisPoolConfig;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OverTimeRedisTest</span> &#123;<br>    <span class="hljs-meta">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot;, &quot;resource&quot; &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        RedisTemplate redisTemplate=applicationContext.getBean(RedisTemplate.class);<br>        redisTemplate.execute((RedisOperations ops) -&gt; &#123;<br>       <span class="hljs-comment">/************Begin************/</span><br>        ops.boundValueOps(<span class="hljs-string">&quot;key&quot;</span>).set(<span class="hljs-string">&quot;今天你吃了吗？&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (String) ops.boundValueOps(<span class="hljs-string">&quot;key&quot;</span>).get();<br>        System.out.println(value);<br>        ops.expire(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">5L</span>, TimeUnit.SECONDS);<br>        <span class="hljs-comment">/************End************/</span><br>        <span class="hljs-comment">//睡眠6秒，使得key值过期</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">6000</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">//获取key值</span><br>        System.out.println((String)ops.boundValueOps(<span class="hljs-string">&quot;key&quot;</span>).get());<br>        <span class="hljs-comment">//结束所有线程，退出系统</span><br>        System.exit(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第5关：使用Lua语言"><a href="#第5关：使用Lua语言" class="headerlink" title="第5关：使用Lua语言"></a>第5关：使用Lua语言</h2><p>在 Redis 的 2.6 以上版本中，除了可以使用命令外，还可以使用 Lua 语言操作 Redis。从前面的命令可以看出 Redis 命令的计算能力并不算很强大，而使用 Lua 语言则在很大程度上弥补了 Redis 的这个不足。 只是在 Redis 中，执行 Lua 语言是原子性的， 也就说 Redis 执行 Lua 的时候是不会被中断的，具备原子性，这个特性有助于 Redis 对并发数据一致性的支持。 Redis 支持两种方法运行脚本， 一种是直接输入一些 Lua 语言的程序代码：另外一种是 将 Lua 语言编写成文件。在实际应用中， 一些简单的脚本可以采取第一种方式，对于有一 定逻辑的一般采用第二种方式。</p><div class="note note-primary">            <p>1.执行输入 Lua 程序代码。 2.执行 Lua 文件。</p>          </div><h3 id="相关知识-7"><a href="#相关知识-7" class="headerlink" title="相关知识"></a>相关知识</h3><h4 id="执行输入-Lua-程序代码"><a href="#执行输入-Lua-程序代码" class="headerlink" title="执行输入 Lua 程序代码"></a>执行输入 Lua 程序代码</h4><p>我们还是简单介绍下 Lua , Lua 是一种轻量小巧的脚本语言，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p><p>它的命令格式为: </p><p><img src="https://data.educoder.net/api/attachments/1123388" alt="命令"></p><p>我们来分析下这些参数的含义：</p><ul><li>eval代表执行 Lua 语言的命令。</li><li>script代表 Lua 语言脚本。</li><li>numkeys整数代表参数中有多少个 key ,需要注意的是 Redis 中 key 是从1开始的，如果没有 key 的参数，那么写0。</li><li>key[key…]是 key 作为参数传递给 Lua 语言，也可以不填它是 key 的参数，但是需要和 key-num 的个数对应起来。</li><li>arg[arg…]这些参数传递给 Lua 语言，它们是可填可不填的。</li></ul><p>举例说明<img src="https://data.educoder.net/api/attachments/1123424" alt=" Lua展示 "></p><p>这里可以看见执行两个Lua脚本。</p><p><img src="https://data.educoder.net/api/attachments/1123425" alt=","></p><p>这个脚本只是返回一个字符串，并不需要任何参数，所以 numkeys 填写了0，代表着没有任何 key 的参数，按照脚本只返回语句 hello java，所以执行后 Redis 也是这样返回的。这个例子很简单，只是返回一个字符串</p><p><img src="https://data.educoder.net/api/attachments/1123426" alt=","></p><p>设置一个键值对，可以在Lua语言中采用redis.call(command,key[param1,param2…])进行操作，其中：</p><ul><li>command是命令，包括set、get、del等基础命令</li><li>key是被操作的键</li><li>param1,param2…代表给key的参数</li></ul><p>脚本中的 KEYS[1] 代表读取传递给 Lua 脚本的第一个 key 参数，而 ARGV[1] 代表第一个非 key 参数。这里共有一个 key 参数，所以填写的 numkeys 为1，这样 Redis 就知道 key-value 是 key 参数，而 lua-value 是其他参数，它起到的是一种间隔的作用。最后我们可以看到使用 get 命令获取数据是成功的，所以 Lua 脚本运行成功了。</p><p>有时可能需要多次执行同样一段脚本，这个时候可以使用 Redis 缓存脚本的功能，在 Redis 中脚本会通过 SHA-1 签名算法加密脚本，然后返回一个标识字符串，可以通过这个字符串执行加密后的脚本。这样的一个好处在于，如果脚本很长，从客户端传输可能需要很长的时间，那么使用标识字符串，则只需要传递 32 位字符串即可，这样就能提高传输的效率，从而提高性能。</p><p>首先使用命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">script load script <br></code></pre></td></tr></table></figure><p>后面的 script 代表 Lua 语言脚本。这个脚本的返回值是一个 SHA-1 签名过后的标识字符串，我们把它记为 shastring 。通过 shastring 可以使用命令执行签名后的脚本，命令的格式为：</p><p><img src="https://data.educoder.net/api/attachments/1123451" alt=","> </p><p>我们再来演示一下这个过程： <img src="https://data.educoder.net/api/attachments/1124289" alt=" 使用签名运行 Lua 脚本 "></p><p>对于脚本签名后就可以使用 SHA-1 签名标识运行脚本了。我们可以用 Java 中使用 Lua 脚本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>       config.setMaxTotal(<span class="hljs-number">100</span>);<br>       config.setMaxWaitMillis(<span class="hljs-number">1000</span>);<br>       config.setMaxIdle(<span class="hljs-number">10</span>);<br>       <span class="hljs-type">JedisPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(config, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>, <span class="hljs-number">2000</span>, <span class="hljs-literal">null</span>);<br>       Jedis jedis=pool.getResource();<br>       <span class="hljs-comment">//执行简单Lua的脚本</span><br>       String hellojava= (String) jedis.eval(<span class="hljs-string">&quot;return &#x27;hello java&#x27;&quot;</span>);<br>       System.out.println(hellojava);<br>       <span class="hljs-comment">//执行带参数的脚本</span><br>       jedis.eval(<span class="hljs-string">&quot;redis.call(&#x27;set&#x27;,KEYS[1],ARGV[1])&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;lua-key&quot;</span>,<span class="hljs-string">&quot;lua-value&quot;</span>);<br>       System.out.println(jedis.get(<span class="hljs-string">&quot;lua-key&quot;</span>));<br>       <span class="hljs-comment">//缓存脚本，返回SHA-1签名标识</span><br>       String sha1=jedis.scriptLoad(<span class="hljs-string">&quot;redis.call(&#x27;set&#x27;,KEYS[1],ARGV[1])&quot;</span>);<br>       <span class="hljs-comment">//通过签名标识执行脚本</span><br>       jedis.evalsha(sha1,<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;sha-key&quot;</span>,<span class="hljs-string">&quot;sha-val&quot;</span>&#125;);<br>       <span class="hljs-comment">//获取执行脚本后的数据</span><br>       System.out.println(jedis.get(<span class="hljs-string">&quot;sha-key&quot;</span>));<br>       <span class="hljs-comment">//关闭连接</span><br>       jedis.close();<br></code></pre></td></tr></table></figure><p>上面代码演示的是简单字符串的存储，执行输出为：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">hello java<br>lua-value<br>sha-val<br></code></pre></td></tr></table></figure><p>但是现实中可能要存储对象，这个时候我们可以考虑使用 Spring 提供的 RedisScript 接口，它还是提供了一个实现类—— DefaultRedisScript ,让我们来了解他的使用方法。</p><p>先定义一个可序列化的对象 Role ,因为要序列化所以需要实现 Serializable 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Role</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> serialVersionUID=<span class="hljs-number">7247714666080613254L</span>;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String roleName;<br>    <span class="hljs-keyword">private</span> String note;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getSerialVersionUID</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> serialVersionUID;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRoleName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> roleName;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRoleName</span><span class="hljs-params">(String roleName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.roleName = roleName;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNote</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> note;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNote</span><span class="hljs-params">(String note)</span> &#123;<br>        <span class="hljs-built_in">this</span>.note = note;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就可以通过Spring提供的 DefaultRedisScript 对象执行 Lua 脚本来操作对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>   RedisTemplate redisTemplate=applicationContext.getBean(RedisTemplate.class);<br>   <span class="hljs-comment">//定义默认脚本封装类</span><br>   DefaultRedisScript&lt;Role&gt; redisScript = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>   <span class="hljs-comment">//设置脚本</span><br>   redisScript.setScriptText(<span class="hljs-string">&quot;redis.call(&#x27;set&#x27;,KEYS[1],ARGV[1]) return redis.call(&#x27;get&#x27;,KEYS[1])&quot;</span>);<br>   <span class="hljs-comment">//定义操作的key列表</span><br>   List&lt;String&gt; keyList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>   keyList.add(<span class="hljs-string">&quot;role1&quot;</span>);<br>   <span class="hljs-comment">//需要序列化保护和读取的对象</span><br>   Role role=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Role</span>();<br>   role.setId(<span class="hljs-number">1L</span>);<br>   role.setRoleName(<span class="hljs-string">&quot;role_name_1&quot;</span>);<br>   role.setNote(<span class="hljs-string">&quot;note_1&quot;</span>);<br>   <span class="hljs-comment">//获得标识字符串</span><br>   String sha1=redisScript.getSha1();<br>   System.out.println(sha1);<br>   <span class="hljs-comment">//设置返回结果类型，如果没有返回，输出结果为空</span><br>   redisScript.setResultType(Role.class);<br>   <span class="hljs-comment">//定义序列化器</span><br>   JdkSerializationRedisSerializer serializer=<span class="hljs-keyword">new</span> <span class="hljs-title class_">JdkSerializationRedisSerializer</span>();<br>   <span class="hljs-comment">//执行脚本</span><br>   <span class="hljs-comment">//第一个是RedisScript接口对象，第二个是参数序列化器</span><br>   <span class="hljs-comment">//第三个是结果序列化器，第四个是Redis的key列表，最后是参数列表</span><br>   Role obj=(Role) redisTemplate.execute(redisScript, serializer,serializer,keyList,role);<br>   <span class="hljs-comment">//打印结果</span><br>   System.out.println(obj);<br></code></pre></td></tr></table></figure><p>要注意的是，上面两个序列化器第一个是参数序列化器，第二个是结果序列化器。这里配置的是 Spring 提供的 JdkSerializationRedisSerializer ，如果在 Spring 配置文件中将 RedisTemplate 的 valueSerializer 属性设置为 JdkSerializationRedisSerializer ，那么使用默认的序列化器即可。</p><h4 id="执行-Lua-文件"><a href="#执行-Lua-文件" class="headerlink" title="执行 Lua 文件"></a>执行 Lua 文件</h4><p>Lua 可以变成一个字符串传递给 Redis 执行，也可以直接执行Lua文件，尤其是当 Lua 脚本存在较多逻辑的时候，就很有必要单独编写独立的 Lua 文件。比如接下来这一段 Lua 脚本：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua">redis.call (<span class="hljs-string">&#x27;set&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>])<br>redis.call (<span class="hljs-string">&#x27;set&#x27;</span>, KEYS[<span class="hljs-number">2</span>], ARGV[<span class="hljs-number">2</span>])<br><span class="hljs-keyword">local</span> n1=<span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>,KEYS[<span class="hljs-number">1</span>]))<br><span class="hljs-keyword">local</span> n2=<span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>,KEYS[<span class="hljs-number">2</span>]))<br><span class="hljs-keyword">if</span> n1&gt;n2 <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span> n1==n2 <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span> n1&lt;n2 <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这个 Lua 脚本是一个可以输入两个键和两个数字（记为n1和n2）的脚本，其意义就是先按键保存两个数字，然后去比较两个数字的大小。如果两个数字相等时，就返回0，如果 n1&gt;n2 则返回1，如果 n2&gt;n1 则返回2，且把它以文件名  test.lua 保存起来。这个时候可以对其进行测试，在 Windows 或者在 Linux 操作系统上执行下面的命令： <img src="https://data.educoder.net/api/attachments/1124523" alt=","></p><p>这里需要注意命令格式，执行的命令键和参数是使用逗号分隔的，而键之间是通过逗号分隔开的，从上图可以看出 key2 和参数之间是用逗号分隔的，而逗号前后的空格是不可以省略的，一定要注意，一旦左边的空格被省略了，否则Redis 就会认为“key,2”是一个键，一旦右边的空格被省略了，Redis 就会认为“,2”是一个键。</p><p>我们在 Java 中没有办法与客户端一样执行这样的文件脚本，一般使用 evalsha 命令来缓存脚本，并返回32位 SHA-1 标识，我们只需要传递这个标识和参数给 Redis 就可以了，使得通过网络传递给 Redis 的信息较少，从而提高了性能。如果使用 eval 命令去执行文件里的字符串，一旦文件很大，那么就需要通过网络反复传递文件，问题往往就出现在网络上，而不是 Redis 的执行效率上了。参考上面的例子去执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        RedisTemplate redisTemplate=applicationContext.getBean(RedisTemplate.class);<br>        <span class="hljs-comment">//读入文件流</span><br>        File file=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:\\java\\com\\redis\\test.lua&quot;</span>);<br>        <span class="hljs-type">byte</span>[] bytes= getFileToByte(file) ;<br>        Jedis jedis=(Jedis)redisTemplate.getConnectionFactory().getConnection().getNativeConnection();<br>        <span class="hljs-comment">//发送文件二进制给Redis，这样Redis就会返回SHA-1标识</span><br>        <span class="hljs-type">byte</span>[] sha1=jedis.scriptLoad(bytes);<br>        <span class="hljs-comment">//使用返回的标识执行，其中第二个参数2，表示使用2个键</span><br>        <span class="hljs-comment">//而后面的字符串1都转化为二进制字节进行传输</span><br>        Object obj=jedis.evalsha(sha1,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;key1&quot;</span>.getBytes(),<span class="hljs-string">&quot;key2&quot;</span>.getBytes(),<span class="hljs-string">&quot;2&quot;</span>.getBytes(),<span class="hljs-string">&quot;4&quot;</span>.getBytes());<br>        System.out.println(obj);<br>    &#125;<br><span class="hljs-comment">//将文件转换为byte类型</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] getFileToByte(File file) &#123;<br>        <span class="hljs-type">byte</span>[] by=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[(<span class="hljs-type">int</span>) file.length()];<br>        <span class="hljs-keyword">try</span> &#123;<br>            InputStream is=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>            ByteArrayOutputStream bytestream=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">byte</span>[] bb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">2048</span>];<br>            <span class="hljs-type">int</span> ch;<br>            ch=is.read(bb);<br>            <span class="hljs-keyword">while</span> (ch!=-<span class="hljs-number">1</span>)&#123;<br>                bytestream.write(bb,<span class="hljs-number">0</span>,ch);<br>                ch=is.read(bb);<br>            &#125;<br>            by=bytestream.toByteArray();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> by;<br>    &#125;<br></code></pre></td></tr></table></figure><p>如果我们将 SHA-1 这个二进制标识保存下来，那么可以通过这个标识反复执行脚本，只需要传递32位标识和参数即可，无需多次传递脚本。从对 Redis 的流水线的分析可知，系统性能不佳的问题往往并非是 Redis 服务器的处理能力，更多的是网络传递，因此传递更少的内容，有利于系统性能的提高。</p><p>这里采用比较原始的 Java Redis 连接操作 Redis ，还可以采用 Spring 提供 RedisScript 操作文件，这样就可以通过序列化器直接操作对象了。</p><h3 id="任务代码-7"><a href="#任务代码-7" class="headerlink" title="任务代码"></a>任务代码</h3><div class="note note-secondary">            <p><strong>编程要求</strong></p><ul><li>根据提示，在右侧编辑器 Begin - End 处补充代码，根据以下要求完成一次手机销售库存的操作：<ul><li>编写 ItemRedisTest.lua 文件，判断销售量是否比库存数量多，如果库存数量大于这次销售量，将新的库存数量更新到原来的 key 值上。</li><li>编写 ItemRedisTest.java 文件，使用 BufferedReader 读取ItemRedisTest.lua 文件，使用 eval 命令执行文件里的字符串，设置手机销售量为10。</li><li>ItemRedisTest.lua 地址为：<code>/data/workspace/myshixun/step5/ItemRedisTest.lua</code></li></ul></li></ul>          </div><p class="note note-light">ItemRedisTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.redis;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItemRedisTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        RedisTemplate redisTemplate=applicationContext.getBean(RedisTemplate.class);<br>        Jedis jedis=(Jedis)redisTemplate.getConnectionFactory().getConnection().getNativeConnection();<br>        jedis.set(<span class="hljs-string">&quot;phone_item_stock&quot;</span>, <span class="hljs-string">&quot;100&quot;</span>);<br>         <span class="hljs-comment">/************Begin************/</span><br>        BufferedReader in= <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;/data/workspace/myshixun/step5/ItemRedisTest.lua&quot;</span>));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span><span class="hljs-literal">null</span>;<br>        String script=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">null</span> != (context = in.readLine()))&#123;<br>            script+=context+<span class="hljs-string">&quot;\n&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span>  jedis.eval(script, <span class="hljs-number">1</span>,<span class="hljs-string">&quot;phone_item_stock&quot;</span>,<span class="hljs-string">&quot;10&quot;</span>);<br>        <span class="hljs-comment">/************End************/</span><br>        System.out.println(<span class="hljs-string">&quot;手机库存剩余：&quot;</span>+obj);<br>        <span class="hljs-comment">//关闭连接</span><br>        jedis.close();<br>        System.exit(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-light">ItemRedisTest.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> count = redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">local</span> a=<span class="hljs-built_in">tonumber</span>(count)<br><span class="hljs-keyword">local</span> b=<span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">1</span>])<br><span class="hljs-comment">---Begin</span><br><span class="hljs-keyword">if</span> a&gt;=b <span class="hljs-keyword">then</span><br>    redis.call(<span class="hljs-string">&#x27;set&#x27;</span>,KEYS[<span class="hljs-number">1</span>],count-b)<br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">---End</span><br></code></pre></td></tr></table></figure><h1 id="4-Redis的常用配置"><a href="#4-Redis的常用配置" class="headerlink" title="4.Redis的常用配置"></a>4.<strong>Redis的常用配置</strong></h1><div class="note note-success">            <p>Redis 的常用配置，包括备份、回收策略、主从复制和哨兵模式</p>          </div><h3 id="第1关：Redis的基础配置文件"><a href="#第1关：Redis的基础配置文件" class="headerlink" title="第1关：Redis的基础配置文件"></a>第1关：Redis的基础配置文件</h3><div class="note note-primary">            <p>1.Redis常见配置redis.conf</p>          </div><h3 id="相关知识-8"><a href="#相关知识-8" class="headerlink" title="相关知识"></a>相关知识</h3><h4 id="Redis常见配置redis-conf"><a href="#Redis常见配置redis-conf" class="headerlink" title="Redis常见配置redis.conf"></a>Redis常见配置redis.conf</h4><p>Redis的配置文件的使用在当下开发已十分普遍，Redis的配置文件放置在其安装目录下，如果是Windows系统，则默认的配置文件就是redis.window.conf;如果是Linux系统，则是redis.conf。在大部分的情况下我们都会使用到Linux环境，所以本章以Linux为主进行讲述。 </p><p><img src="https://data.educoder.net/api/attachments/1125965"></p><p>编辑redis.conf文件，会看见文件中有很多配置，下面我们一起来看看这些配置代表着什么含义： </p><p>1、redis默认不是以守护进程的方式运行，可以通过该配置项修改，默认为no,可以使用yes启用守护进程：<img src="https://data.educoder.net/api/attachments/1125974"></p><p>2、当redis以守护进程方式运行时，redis默认会把pid写入&#x2F;var&#x2F;run&#x2F;redis.pid文件，可以通过pidfile指定： <img src="https://data.educoder.net/api/attachments/1125976"></p><p>3、指定redis监听端口，默认端口号为6379，作者在自己的一篇博文中解析了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利女歌手Alessia Merz的名字： <img src="https://data.educoder.net/api/attachments/1125977"></p><p>4、绑定的主机地址：<img src="https://data.educoder.net/api/attachments/1125979"></p><p>5、当客户端闲置多长时间后关闭连接，如果指定为0，表示永不关闭：<img src="https://data.educoder.net/api/attachments/1125980"></p><p>6、设置检测客户端网络中断时间间隔，单位为秒，如果设置为0，则不检测，建议设置为60：<img src="https://data.educoder.net/api/attachments/1125981"></p><p>7、指定日志记录级别，redis总共支持四个级别：debug、verbose、notice、warning，</p><ul><li>debug:会打印生成大量信息，适用于开发&#x2F;测试阶段</li><li>verbose:包含很多不太有用的信息，但是不像debug级别那么混乱</li><li>notice:适度冗长，适用于生产环境</li><li>warning:仅记录非常重要、关键的警告消息</li></ul><p>默认为verbose：<img src="https://data.educoder.net/api/attachments/1125982"></p><p>8、日志记录方式，默认为标准输出，如果配置redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给&#x2F;dev&#x2F;null：<img src="https://data.educoder.net/api/attachments/1125984"></p><p>9、设置数据库数量，默认值为16，默认当前数据库为0，可以使用<code>select&lt;dbid&gt;</code>命令在连接上指定数据库id：<img src="https://data.educoder.net/api/attachments/1125986"></p><p>10、指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合：<img src="https://data.educoder.net/api/attachments/1125987"> 这三个配置项的含义分别为：</p><ul><li>当900秒执行1个写命令时，启用快照备份。</li><li>当300秒执行10个写命令时，启用快照备份。</li><li>当60秒执行10000个写命令时，启用快照备份。</li></ul><p>11、指定存储至本地数据库时是否压缩数据，默认为yes，redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变得巨大：<img src="https://data.educoder.net/api/attachments/1126003"></p><p>12、指定本地数据库文件名，默认值为dump.rdb：<img src="https://data.educoder.net/api/attachments/1126008"></p><p>13、指定本地数据库存放目录：<img src="https://data.educoder.net/api/attachments/1126009"></p><p>14、设置当本机为slave服务时，设置master服务的IP地址及端口，在redis启动时，它会自动从master进行数据同步：<img src="https://data.educoder.net/api/attachments/1126014"></p><p>15、当master服务设置了密码保护时，slave服务连接master的密码：<img src="https://data.educoder.net/api/attachments/1126016"></p><p>16、设置redis连接密码，如果配置了连接密码，客户端在连接redis时需要通过<code>auth &lt;password&gt;</code>命令提供密码，默认关闭：<img src="https://data.educoder.net/api/attachments/1126019"></p><p>17、设置同一时间最大客户端连接数，默认无限制，redis可以同时打开的客户端连接数为redis进程可以打开的最大文件描述符数，如果设置maxclients 0，表示不作限制。当客户端连接数到达限制时，redis会关闭新的连接并向客户端返回 max number of clients reached错误消息：<img src="https://data.educoder.net/api/attachments/1126024"></p><p>18、指定redis最大内存限制，redis在启动时会把数据加载到内存中，达到最大内存后，redis会先尝试清除已到期或即将到期的key，当次方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制， 会把key存放内存，value会存放在swap区：<img src="https://data.educoder.net/api/attachments/1126026"></p><p>19、设置缓存过期策略，有6种选择：（LRU算法最近最少使用）</p><ul><li>volatile-lru：使用LRU算法移除key，只对设置了过期时间的key；</li><li>allkeys-lru：使用LRU算法移除key，作用对象所有key；</li><li>volatile-random：在过期集合key中随机移除key，只对设置了过期时间的key;</li><li>allkeys-random：随机移除key，作用对象为所有key；</li><li>volarile-ttl：移除哪些ttl值最小即最近要过期的key；</li><li>noeviction：永不过期，针对写操作，会返回错误信息。</li></ul><p><img src="https://data.educoder.net/api/attachments/1126027"></p><p>20、指定是否在每次更新操作后进行日志记录，redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内数据丢失。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内置存在于内存中。默认为no：<img src="https://data.educoder.net/api/attachments/1126031"></p><p> 21、指定更新日志文件名，默认为appendonly.aof<img src="https://data.educoder.net/api/attachments/1126033"></p><p> 22、指定更新日志条件，共有3个可选值：</p><ul><li>no：表示等操作系统进行数据缓存同步到磁盘（快）；</li><li>always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）；</li><li>everysec：表示每秒同步一次（折中，默认值）。 <img src="https://data.educoder.net/api/attachments/1126037"></li></ul><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><div class="note note-secondary">            <p><strong>编程要求</strong></p><p>根据相关知识，按照要求完成右侧选择题任务，包含单选题和多选题。</p>          </div><p><img src="https://cdn.jsdelivr.net/gh/Manchesterss/picx-image@main/2020/QQ%E5%9B%BE%E7%89%8720211008174624.7h6cmz0up780.png" alt="选择题"></p><h2 id="第2关：Redis-的高级配置"><a href="#第2关：Redis-的高级配置" class="headerlink" title="第2关：Redis 的高级配置"></a>第2关：Redis 的高级配置</h2><div class="note note-primary">            <p>1.Redis备份（持久化）。 </p><p>2.Redis内存回收策略。</p><p>3.复制。 </p><p>4.哨兵模式。</p>          </div><h3 id="相关知识-9"><a href="#相关知识-9" class="headerlink" title="相关知识"></a>相关知识</h3><h4 id="Redis备份（持久化）"><a href="#Redis备份（持久化）" class="headerlink" title="Redis备份（持久化）"></a>Redis备份（持久化）</h4><p>在 Redis 中存在两种方式的备份：一种是快照，它是备份当前瞬间 Redis 在内存中的数据记录；另一种是只追加文件，其作用就是当 Redis 执行写命令后，在一定的条件下将执行过的写命令依次保存在 Redis 的文件中，将来就可以依次执行那些保存的命令恢复 Redis 的数据了。对于快照备份而言，如果当前 Redis 的数据量大，备份可能造成 Redis 卡顿，但是恢复重启时比较快速的；对于 AOF 备份而言，它只是追加写入命令，所以备份一般不会造成 Redis 卡顿，但是恢复重启要执行更多的命令，备份文件可能也很大，使用者使用的时候要注意。在 Redis 中允许使用其中的一种、同时使用两种，或者两者都不用，所以具体使用何种方式进行备份和持久化是用户可以通过配置决定的。 我们来介绍一下这些默认配置：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">save <span class="hljs-number">900</span> <span class="hljs-number">1</span><br>save <span class="hljs-number">300</span> <span class="hljs-number">10</span><br>save <span class="hljs-number">60</span> <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><p>这3个配置项的含义分别为:</p><ul><li>当 900 秒执行 1 个写命令时，启用快照备份。</li><li>当 300 秒执行 10 个写命令时，启用快照备份。</li><li>当 60 秒内执行 10000 个写命令时，启用快照备份。</li></ul><p>Redis 执行 save 命令的时候，将禁止写入命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">stop-writes-on-bgsave-error yes<br></code></pre></td></tr></table></figure><p>这里先谈谈 bgsave 命令，它是一个异步保存命令，也就是系统将启动另外一条进程，把 Redis 的数据保存到对应的数据文件中。它和 save 命令最大的不同是它不会阻塞客户端的写入，也就是在执行 bgsave 的时候，允许客户端继续读&#x2F;写 Redis 。在默认情况下，如果 Redis 执行 bgsave 失败后，Redis 将停止接受写操作，这样以一种强硬的方式让用户知道数据不能正确的持久化到磁盘，否则就会没人注意到灾难的发生，如果后台保存进程重新启动工作了， Redis 也将自动允许写操作。然而如果安装了靠谱的监控，可能不希望 Redis 这样做，那么你可以将其修改为 no。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">rdbchecksum yes<br></code></pre></td></tr></table></figure><p>这个命令意思是是否对 rbd 文件进行检验，如果是将对 rdb 文件检验。从 dfilename 的配置可以知道，rdb 文件实际是 Redis 持久化的数据文件。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">dbfilename dump.rdb<br></code></pre></td></tr></table></figure><p>它是数据文件。当采用快照模式备份（持久化）时，Redis 将使用它保存数据，将来可以使用它恢复数据。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">appendonly no<br></code></pre></td></tr></table></figure><p>如果 appendonly 配置 no，则不启用 AOF 方式进行备份。如果 appendonly 配置为 yes，则以 AOF 方式备份 Redis 数据，那么此时 Redis 会按照配置，在特定的时候执行追加命令，用以备份数据。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">appendfilename <span class="hljs-string">&quot;appendonly.aof&quot;</span><br></code></pre></td></tr></table></figure><p>这里追加的写入文件为 appendonly.aof，采用 AOF 追加文件备份的时候命令都会写到这里。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># appendfsync always</span><br>appendfsync everysec<br><span class="hljs-comment"># appendfsync no</span><br></code></pre></td></tr></table></figure><p>AOF 文件和 Redis 命令是同步频率的，假设配置为 always ，其含义为当 Redis 执行命令的时候，则同时同步到 AOF 文件，这样会使得 Redis 同步刷新 AOF 文件，造成缓慢。而采用 evarysec 则代表每秒同步一次命 令到 AOF 文件。采用 no 的时候，则由客户端调用命令执行备份，Redis 本身不备份文件。对于采用 always 配置的时候，每次命令都会持久化，它的好处在于安全，坏处在于每次都持久化性能较差。采用 evarysec 则每秒同步，安全性不如 always ,备份可能会丢失 1 秒以内的命令，但是隐患也不大，安全度尚可，性能可以得到保障。采用 no ,则性能有所保障，但是由于失去备份，所以安全性比较差。</p><p>建议采用默认配置 everysec ,这样在保证性能的同时，也在一定程度上保证了安全性。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">no-appendfsync-on-rewrite no<br></code></pre></td></tr></table></figure><p>它指定是否在后台 AOF 文件 rewrite (重写)期间调用 fsync ，默认为 no ，表示要调用 fsync（无论后台是否有子进程在刷盘）。Redis 在后台写 RDB 文件或重写 AOF 文件期间会存在大量磁盘I&#x2F;O，此时，在某些 Linux 系统中，调用 fsync 可能会阻塞。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">auto-aof-rewrite-percentage <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>他指定 Redis 重写 AOF 文件的条件，默认为100，标识与上次 rewire 的 AOF 文件大小相比，当前 AOF 文件增长量超过上次 AOF 文件大小的100%时，就会触发 backgroundrewrite 。若配置为 0，则会禁用自动 rewrite 。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">auto-aof-rewrite-min-size <span class="hljs-number">64</span>mb<br></code></pre></td></tr></table></figure><p>它指定触发 rewrite 的 AOF 文件大小。若 AOF 文件小于该值，即使当前文件的增量比例到达 auto-aof-rewrite-percentage 的配置值，也不会触发自动 rewrite。即这两个配置项同时满足时，才会触发 rewrite。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">aof-load-truncated yes<br></code></pre></td></tr></table></figure><p>Redis 在恢复时会忽略最后一条可能存在问题的指令，默认为 yes。即在 AOF 写入时，可能存在指令写错的问题（突然断电），这种情况下 yes会 log 并继续，而 no 会直接恢复失败。</p><h4 id="Redis内存回收策略"><a href="#Redis内存回收策略" class="headerlink" title="Redis内存回收策略"></a>Redis内存回收策略</h4><p>Redis 也会因为内存不足而产生错误，也有时候因为长时间回收导致系统长期的停顿，因此掌握执行回收策略十分有必要。在 Redis 的配置文件中，当Redis的内存到达规定的最大值时，允许配置6种策略中的一种进行淘汰键值，并且将一些键值对进行回收，让我们来看看它们具有哪些特点。</p><p>Redis 对其中一个配置项——maxmemory-policy，提供了这样的一段描述： <img src="https://data.educoder.net/api/attachments/1127790"></p><p>我们来介绍下这 6 种策略的含义：</p><ul><li>valatile-lru：采用最少的淘汰策略删除超时的键值对，作用对象为超时对象。</li><li>allkeys-lru：采用最少的淘汰策略删除键值对，作用对象为所有对象。</li><li>volatile-random：采用随机淘汰策略随机删除超时的键值对，作用对象为超时对象。</li><li>allkeys-random：采用随机淘汰策略随机删除键值对，作用对象为所有对象。</li><li>volatile-ttl：删除存活时间最小即将超时的键值对。</li><li>noeviction：永不过期，当内存已满时，如果读操作正常工作，而写操作，会返回错误信息。</li></ul><p>Redis 默认情况下会采用 noeviction 策略。然而 noeviction 策略当内存已满时，是只能读取不能写入，所以不能满足我们所有的要求，因为对互联网系统而言，常常会涉及数以百万甚至更多的用户，所以往往需要设置回收策略。</p><p>这里需要指出的是：LRU 算法或者 TTL 算法都不是很精确的算法，而是一个近似的算法。 Redis 不会通过对全部的键值对进行比较来确定最精确的时间值，从而确定删除哪个键值对，因为这将消耗太多的时间，导致回收垃圾执行的时间太长，造成服务停顿。而在 Redis 的默认配置文件中，存在着参数 maxmemory-samples ,它的默认值为 3 ，假设采取了 volatile-ttl 算法，让我们去了解这样的一个回收过程，假设当前有 4 个即将超时的键值对:</p><table><thead><tr><th align="center">键值对</th><th align="center">剩余超时秒数</th></tr></thead><tbody><tr><td align="center">a</td><td align="center">5</td></tr><tr><td align="center">b</td><td align="center">4</td></tr><tr><td align="center">c</td><td align="center">6</td></tr><tr><td align="center">d</td><td align="center">3</td></tr></tbody></table><p>因为 maxmemory-samples 的值为 3 ，所以他只会取到前三个样本，然后进行比较。因为 b 剩余秒数最少，所以 b 是最先被删除的。但是剩余超时秒数最短的 d 还在内存中，因为它不属于探测样本中的。这就是 Redis 中采用的近似算法。当设置 maxmemory-samples 越大，则 Redis 探测样本的数量越多，删除的就越精确，但是它的缺点会让使用的时间越长。</p><p>回收超时策略不足的是删除必须指明超时的键值对，这样会让代码量增长，加大开发者的工作任务。但是针对所有的键值对进行回收，有可能把正在使用的键值对删除掉，增加了存储的不稳定性。对于垃圾回收的策略，还需要注意的是回收的时间，因为在 Redis 对垃圾的回收期间，会造成系统缓慢。因此，控制其回收时间有一定好处，只是这个时间不能过短或过长。过短则会造成回收次数过于频繁，过长则导致系统单次垃圾回收停顿时间过长，都不利于系统的稳定性，这些都需要设计者在实际的工作中进行思考。</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>尽管Redis的性能不错，但是面对每秒成千上万的请求，大量的读操作就会到达Redis服务器，触发许许多多的操作，靠一台Redis服务器是完全不够用的。一些服务网站对安全性有较高的要求，当主服务器不能正常工作时，也需要从服务器代替原来的主服务器，作为灾难备份，以保证系统可以继续正常的工作。因此更多的时候我们要将读&#x2F;写分离，因为读操作远远比写操作频繁的多，如果把数据都存放在多台服务器上那么就可以从多台服务器中读取数据，从而消除了单台服务器的压力，我们也可以基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案。</p><h5 id="主从同步基础概念"><a href="#主从同步基础概念" class="headerlink" title="主从同步基础概念"></a>主从同步基础概念</h5><p>互联网系统一般是以主从架构为基础的，所谓主从架构的设计的思路大概是：</p><ul><li>在多台数据服务器中，只有一台主服务器，而主服务器只负责写入数据，不负责外部程序读取数据。</li><li>存在多台从服务器，从服务器不写入数据，只负责同步主服务器的数据，并让外部程序读取数据。</li><li>主服务器写入数据后，即刻将写入数据的命令发送给从服务器，从而使得主从数据同步。</li><li>应用程序可以随机读取某一台从服务器的数据，这样就可以分摊读取数据的压力。</li><li>当从服务器不能工作时，整个系统将不受影响；当主服务器不能工作时，可以方便地从从服务器选举一台来当主服务器。</li></ul><p>大家可以看下主从同步机制图，更加理解 Redis 的复制机制： <img src="https://data.educoder.net/api/attachments/1127798" alt="Redis 的复制机制"></p><p>可以从机制图看出，我们读取数据是在从服务器上读取的，当从服务器是多台的时候，那么单台服务器的压力就大大降低了，这十分有利于系统性能的提高，当主服务器不能工作的情况时，也可以切换为其中的一台从服务器继续让系统稳定运行，所以也有利于系统运行的安全性。当然由于Redis自身具备的特点，所以其也有实现主从同步的特殊方式。</p><h5 id="Redis主从同步配置"><a href="#Redis主从同步配置" class="headerlink" title="Redis主从同步配置"></a>Redis主从同步配置</h5><p>对Redis进行主从同步的配置分为主机与从机，主机是一台，而从机可以是多台。 首先我们要明确主机，关建两个配置是dir和dbfilename选项，dir的默认值为<code>./</code>,dbfilename默认采用Redis当前目录的dump.rbd文件进行同步。其次，明确了从机之后，进行进一步配置所要关注的只有slaveof这个配置选项：<img src="https://data.educoder.net/api/attachments/1127814"> </p><p>其中masterip代表主机地址，masterport代表主机端口。当从机Redis服务重启时，就会同步对应主机的数据了。当不想让从机继续复制主机的数据时，可以在从机的Redis命令客户端发送<code>slaveof no one </code>命令，这样从机就不会再接收主服务器的数据更新了。又或者原来主服务器已经无法工作了，而你可能需要复制新的主机，这个时候执行<code>slaveof masterip masterport </code>就能让从机复制另外一台主机的数据了。 在实际的Linux环境中，配置文件redis.conf中还有一个bind的配置，默认为127.0.0.1，也就是只允许本机访问，把它修改为bind 0.0.0.0，其他的服务器就能够访问了。</p><h5 id="Redis主从同步的过程"><a href="#Redis主从同步的过程" class="headerlink" title="Redis主从同步的过程"></a>Redis主从同步的过程</h5><p>Redis主从同步共分为5步：</p><ol><li>主服务器开启后，从服务器连接主服务器，发送SYNC命令</li><li>主服务器接收到SYNC命名后，开始执行bgsave命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；</li><li>主服务器bgsave执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令,从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；</li><li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；</li><li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令。</li></ol><p>Redis 主从同步的过程图如下： <img src="https://data.educoder.net/api/attachments/1127823" alt="Redis 主从同步的过程图"></p><p>只要在主服务器同步到从服务器的过程中，需要备份文件，所以在配置的时候一般需要预留一些内存空间给主服务器，用来腾出空间执行备份命令。一般来说主服务器使用50%~60%的内存空间，为主从复制留下可用的内存空间。</p><h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p>主从切换技术的方法是：当主机服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，既费时又费力，还会造成一段时间内服务不可用，这不是一个推荐的方式，所以我们考虑哨兵模式，它是当前企业应用的主流方式。</p><h4 id="哨兵模式概述"><a href="#哨兵模式概述" class="headerlink" title="哨兵模式概述"></a>哨兵模式概述</h4><p>Redis可以存在多台服务器，并且实现了主从复制的功能。哨兵模式是一种特殊的模式，首先 Redis 提供了哨兵的命令，哨兵是一个独立的进程。其原理是哨兵通过发送命令，等待Redis服务器相应，从而监控运行的多个Redis实例。如下图：</p><p> <img src="https://data.educoder.net/api/attachments/1127830"></p><p>这里哨兵有两个作用：</p><ol><li>通过发送命令，让Redis服务器返回检测其运行状态，包括主服务器和从服务器。</li><li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知到其他的从服务器，修改配置文件，让它们自动切换主机。</li></ol><p>只是现实中一个哨兵进程对Redis服务器进行监控，也可能出现问题，为了处理这个问题，还可以使用多个哨兵的监控，而各个哨兵之间还会相互监控，这样就变为了多个哨兵模式。多个哨兵不仅监控各个Redis服务器，而且哨兵之间互相监控，看看哨兵们是否还存在着。 论述下故障切换的过程。假设主服务器宕机，哨兵1先检测到这个结果，当时系统并不会马上进行切换操作，而仅仅是哨兵1主观地认为主机不可用，这个现象被称为主观下线。当后面的哨兵监测到了主服务器不可用，并且有了一定的数量的哨兵认为主服务器不可用，那么哨兵之间就会形成一次投票，投票结果由一个哨兵发起，进行故障切换操作，在操作的过程中切换成功后，就会通过发布订阅方式，让各个哨兵把自己监控的服务器实现切换主机，这个过程被称为客观下线。</p><h5 id="搭建哨兵模式"><a href="#搭建哨兵模式" class="headerlink" title="搭建哨兵模式"></a>搭建哨兵模式</h5><p>配置3个哨兵和1主2从的Redis服务器来演示这个过程。</p><table><thead><tr><th>服务类型</th><th>是否主服务器</th><th>IP地址</th><th>端口</th></tr></thead><tbody><tr><td>Redis</td><td>是</td><td>192.168.44.128</td><td>6379</td></tr><tr><td>Redis</td><td>否</td><td>192.168.44.129</td><td>6379</td></tr><tr><td>Redis</td><td>否</td><td>192.168.44.130</td><td>6379</td></tr><tr><td>Sentinel</td><td>-</td><td>192.168.44.128</td><td>26379</td></tr><tr><td>Sentinel</td><td>-</td><td>192.168.44.129</td><td>26379</td></tr><tr><td>Sentinel</td><td>-</td><td>192.168.44.130</td><td>26379</td></tr></tbody></table><p>接下来修改redis.conf文件进行配置：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">＃使得 Redis 服务器可以跨网络访问<br>bind <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span><br>＃设置密码<br>requirepass <span class="hljs-string">&quot;redis123&quot;</span><br><span class="hljs-comment">#指定主服务器，注意:有关slaveof的配置只是配置从服务器，而主服务器不需要配置</span><br>slaveof <span class="hljs-number">192.168</span>.<span class="hljs-number">44.128</span> <span class="hljs-number">6379</span><br>＃主服务器密码，注意：有关 slaveof 的配置只是配置从服务器，而主服务器不需要配置<br>masterauth redis123<br></code></pre></td></tr></table></figure><p>修改<code>sentinel.conf</code>文件进行配置：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment">#禁止保护模式</span><br>protected-mode no<br><span class="hljs-comment">#配置监听的主服务器，这里sentinel monitor 代表监控，</span><br><span class="hljs-comment">#mymaster代表服务器名称，可以自定义</span><br><span class="hljs-comment">#192.168.44.128代表监控的主服务器</span><br><span class="hljs-comment">#6379代表端口</span><br><span class="hljs-comment">#2 代表只有两个或者两个以上的哨兵认为主服务器不可用的时候，才会做故障切换操作</span><br>sentinel monitor mymaster <span class="hljs-number">192.168</span>.<span class="hljs-number">44.128</span> <span class="hljs-number">6379</span> <span class="hljs-number">2</span><br><span class="hljs-comment">#sentinel auth-pass 定义服务的密码</span><br><span class="hljs-comment">#mymaster服务名称</span><br><span class="hljs-comment">#redis123 Redis服务器密码</span><br>sentinel auth-pass mymaster redis123<br></code></pre></td></tr></table></figure><p>上述关闭了保护模式，以便于测试。</p><p>我们启动Redis服务器和哨兵：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment">#启动哨兵进程</span><br>./redis-sentinel ../sentinel.conf<br><span class="hljs-comment">#启动Redis服务器进程</span><br>./redis-server ../redis.conf<br></code></pre></td></tr></table></figure><p>要注意启动的顺序，首先是主机Redis服务进程，然后启动从服务器，最后启动哨兵的服务进程。 <img src="https://data.educoder.net/api/attachments/1128186"></p><h5 id="在Java中使用哨兵模式"><a href="#在Java中使用哨兵模式" class="headerlink" title="在Java中使用哨兵模式"></a>在Java中使用哨兵模式</h5><p>在Java中使用哨兵模式，只需要加入关于哨兵的信息即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//连接池配置</span><br>      <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">jedisPoolConfig</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>      jedisPoolConfig.setMaxTotal(<span class="hljs-number">10</span>) ;<br>      jedisPoolConfig.setMaxIdle(<span class="hljs-number">5</span>);<br>      jedisPoolConfig.setMinIdle(<span class="hljs-number">5</span>);<br>      <span class="hljs-comment">//哨兵信息</span><br>      Set&lt;String&gt; sentinels =<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;(Arrays.asList(<br>             <span class="hljs-string">&quot;192.168.44.128:26379&quot;</span>,<br>              <span class="hljs-string">&quot;192.168.44.129:26379&quot;</span>,<br>              <span class="hljs-string">&quot;192.168.44.130:26379&quot;</span><br>          ));<br>      <span class="hljs-comment">//创建连接池</span><br>      <span class="hljs-comment">//mymaster是我们配置给哨兵的服务名称</span><br>      <span class="hljs-comment">//sentinels是哨兵信息</span><br>      <span class="hljs-comment">//jedisPoolConfig是连接池配置</span><br>      <span class="hljs-comment">//redis123是连接Redis服务器的密码</span><br>      JedisSentinelPool pool=<span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisSentinelPool</span>(<span class="hljs-string">&quot;mymaster&quot;</span>,sentinels,jedisPoolConfig,<span class="hljs-string">&quot;redis123&quot;</span>);<br>      <span class="hljs-comment">//获取客户端</span><br>      <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> pool.getResource();<br>      <span class="hljs-comment">//执行两个命令</span><br>      jedis.set(<span class="hljs-string">&quot;mykey&quot;</span>,<span class="hljs-string">&quot;myvalue&quot;</span>);<br>      String myvalue=jedis.get(<span class="hljs-string">&quot;mykey&quot;</span>);<br>      <span class="hljs-comment">//打印信息</span><br>      System.out.println(myvalue);<br></code></pre></td></tr></table></figure><p>通过上述的代码就能够连接Redis服务器了，这个时候将启动主机提供服务。为了验证哨兵的作用，我们可以把主机上的Redis服务器关闭，Redis哨兵会进行投票切换主机，我们就可以得到下面的日志： <img src="https://data.educoder.net/api/attachments/1128189" alt="日志"> 从从日志可以看到，我们现在使用的是从服务器192.168.44.130，这是因为主服务器192.168.44.128不可用后，哨兵们经过投票最终切换为从服务器192.168.44.130，通过这样的自动切换就保证服务能够持续稳定运行了。 </p><p>同样的，通过配置也可以实现在SpringBoot中测试哨兵：</p><p>配置application.yml文件:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">cluster:</span><br>      <span class="hljs-comment"># 集群模式下，逗号分隔的键值对（主机：端口）形式的服务器列表</span><br>      <span class="hljs-attr">nodes:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.44</span><span class="hljs-number">.128</span><span class="hljs-string">:6379,192.168.44.129:6379,192.168.44.130:6379</span><br>      <span class="hljs-comment">#集群模式下，集群最大转发的数量</span><br>      <span class="hljs-attr">max-redirects:</span> <span class="hljs-number">3</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-comment">#哨兵模式下，逗号分隔的键值对（主机：端口）形式的服务器列表</span><br>      <span class="hljs-attr">nodes:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.44</span><span class="hljs-number">.128</span><span class="hljs-string">:26379,192.168.44.129:26379,192.168.44.130:26379</span><br>      <span class="hljs-comment">#哨兵模式下，Redis主服务器地址</span><br>      <span class="hljs-attr">master:</span> <span class="hljs-string">mymaster</span><br>    <span class="hljs-comment"># 使用数据库的索引编号，一个示例有16个数据库 0 到 15</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-comment"># 连接池最大连接数(使用负值表示没有限制) 默认为8</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span><br>        <span class="hljs-comment"># 连接池最大阻塞等待时间(使用负值表示没有限制) 默认为-1</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-number">-1</span><br>        <span class="hljs-comment"># 连接池中的最大空闲连接 默认为8</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span><br>        <span class="hljs-comment"># 连接池中的最小空闲连接 默认为 0</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span><br>    <span class="hljs-comment"># Redis服务器的密码</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">redis123</span><br>    <span class="hljs-comment"># 连接超时，毫秒为单位</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">6000</span><br></code></pre></td></tr></table></figure><p>要注意这里使用的是 lettuce 客户端而不是 Jedis 客户端，因为在 springboot 1.5.x版本的默认的Redis客户端是 Jedis实现的，springboot 2.x版本中默认客户端是用 lettuce实现的。这两个客户端的区别：</p><ol><li>Jedis是直接连接redis server ,如果在多线程环境下是非线程安全的，这个时候只有使用连接池，为每个 Jedis 实例增加物理连接。</li><li>Lettuce的连接是基于Netty的，连接实例可以在多个线程间并发访问，应为StatefulRedisConnection是线程安全的，所以一个连接实例就可以满足多线程环境下的并发访问，当然这个也是可伸缩的设计，一个连接实例不够的情况也可以按需增加连接实例。</li></ol><p>单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.ValueOperations;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfigurationTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String,String&gt;  redisTemplate;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        ValueOperations&lt;String, String&gt; opsForValue = redisTemplate.opsForValue();<br>        opsForValue.set(<span class="hljs-string">&quot;redisTest&quot;</span>,<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>        System.out.println(opsForValue.get(<span class="hljs-string">&quot;redisTest&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：<code>HelloWorld</code></p><h3 id="任务代码-8"><a href="#任务代码-8" class="headerlink" title="任务代码"></a>任务代码</h3><div class="note note-secondary">            <p><strong>编程要求</strong></p><p>根据提示，在右侧编辑器补充代码，根据以下要求测试连接单节点Redis和哨兵。 在application.yml文件中配置</p><ul><li>spring.redis.cluster.node 为127.0.0.1:6379</li><li>spring.redis.sentinel.nodes为 127.0.0.1:26379</li><li>spring.redis.sentinel.master为mymaster</li></ul><p>在RedisController编写代码，实现设置key值为HelloWorld并返回key值。</p>          </div><p class="note note-light">RedisController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.springredis.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.ValueOperations;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;<br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    RedisTemplate&lt;String,String&gt; redisTemplate;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">()</span>&#123;<br>     ValueOperations&lt;String, String&gt; opsForValue = redisTemplate.opsForValue();<br>        <span class="hljs-comment">//*********** Begin ***********</span><br>        opsForValue.set(<span class="hljs-string">&quot;redisTest&quot;</span>,<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>        <span class="hljs-keyword">return</span> opsForValue.get(<span class="hljs-string">&quot;redisTest&quot;</span>);<br>        <span class="hljs-comment">//*********** End ***********</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-light">application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-comment">#************ Begin ************</span><br>    <span class="hljs-attr">cluster:</span><br>      <span class="hljs-comment"># 集群模式下，逗号分隔的键值对（主机：端口）形式的服务器列表</span><br>     <span class="hljs-attr">nodes:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:6379,127.0.0.1:6379,127.0.0.1:6379</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-comment">#哨兵模式下，逗号分隔的键值对（主机：端口）形式的服务器列表</span><br>      <span class="hljs-attr">nodes:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:26379,127.0.0.1:26379,127.0.0.1:26379</span><br>      <span class="hljs-comment">#哨兵模式下，Redis主服务器地址</span><br>      <span class="hljs-attr">master:</span> <span class="hljs-string">mymaster</span><br>    <span class="hljs-comment">#************ End ************</span><br>    <span class="hljs-comment"># 使用数据库的索引编号，一个示例有16个数据库 0 到 15</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-comment"># 连接池最大连接数(使用负值表示没有限制) 默认为8</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span><br>        <span class="hljs-comment"># 连接池最大阻塞等待时间(使用负值表示没有限制) 默认为-1</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-number">-1</span><br>        <span class="hljs-comment"># 连接池中的最大空闲连接 默认为8</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span><br>        <span class="hljs-comment"># 连接池中的最小空闲连接 默认为 0</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 连接超时，毫秒为单位</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">6000</span><br></code></pre></td></tr></table></figure><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><center><img src="https://cdn.jsdelivr.net/gh/Manchesterss/picx-image@main/2020/幻想逍遥侠_20210907_191550.7eshnl3j6gc0.gif" style="zoom:200%;" /></center><blockquote><p>任务地址：<br>    头歌编程：<a href="https://www.educoder.net/shixuns/rlfms83n/challenges">Redis概述</a><br>    头歌编程：<a href="https://www.educoder.net/shixuns/5f2hgm3f/challenges">Redis常用数据结构</a><br>    头歌编程：<a href="https://www.educoder.net/shixuns/3r8ktfe5/challenges">Redis一些常用的技术</a><br>    头歌编程：<a href="https://www.educoder.net/shixuns/vkszhfgr/challenges">Redis的常用配置</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>SSM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-栈和队列</title>
    <link href="/2021/10/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A0%88/"/>
    <url>/2021/10/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h2><div class="note note-info">            <p>特点：利用一组地址连续的存储单元存放自栈底到栈顶的数据元素,同时附加一个指针(top)指示当前栈顶的位置</p>          </div><h3 id="0-顺序栈的类型描述"><a href="#0-顺序栈的类型描述" class="headerlink" title="0.顺序栈的类型描述"></a>0.顺序栈的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 50</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    Elemtype data[MaxSize];<br>    <span class="hljs-type">int</span> top;<br>&#125;SqStack;<br></code></pre></td></tr></table></figure><h3 id="1-初始化操作"><a href="#1-初始化操作" class="headerlink" title="1.初始化操作"></a>1.初始化操作</h3><p class="note note-success">目标：初始化一个空的顺序栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Void <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;stack)</span></span>&#123;<br>    stack.top=<span class="hljs-number">-1</span>;<span class="hljs-comment">//初始化栈顶指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-判空操作"><a href="#2-判空操作" class="headerlink" title="2.判空操作"></a>2.判空操作</h3><p class="note note-success">目标：判断当前栈是否为空栈，若是返回TRUE,否则返回FALSE</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack stack)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(stack.top==<span class="hljs-number">-1</span>)<span class="hljs-comment">//栈空</span><br>        <span class="hljs-keyword">return</span> TRUE;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-进栈操作"><a href="#3-进栈操作" class="headerlink" title="3.进栈操作"></a>3.进栈操作</h3><p class="note note-success">目标：向顺序栈中插入一个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Push</span><span class="hljs-params">(SqStatck &amp;stack,ElemType x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(stack.top)==MaxSize<span class="hljs-number">-1</span>)<span class="hljs-comment">//栈满，报错</span><br>        retrun FALSE;<br>    stack.data[++stack.top]=x<span class="hljs-comment">//指针先加1再入栈</span><br>        <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>WARNING</p><p>当初始化时<code>stack.top=0;</code>此时入栈代码变为<code>stack.data[stack.top++]=x;</code>    此时栈判空代码变为<code>if(stack.top==0)</code></p><p>此时栈判满代码变为<code>if(stack.top==MaxSize)</code></p>          </div><h3 id="4-出栈操作"><a href="#4-出栈操作" class="headerlink" title="4.出栈操作"></a>4.出栈操作</h3><p class="note note-success">目标：从顺序栈中弹出一个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;stack,ElemType &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(stack.top==<span class="hljs-number">-1</span>)<span class="hljs-comment">//栈空</span><br>        <span class="hljs-keyword">return</span> FALSE;<br>    x=stack.data[stack.top--];<span class="hljs-comment">//先出栈指针再减1</span><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>WARNING</p><p>当初始化时<code>stack.top=0;</code>此时出栈代码变为<code>x=stack.data[--stack.top];</code></p>          </div><h3 id="5-读栈顶元素"><a href="#5-读栈顶元素" class="headerlink" title="5.读栈顶元素"></a>5.读栈顶元素</h3><p class="note note-success">目标：当前顺序栈中栈顶的元素，并用引用变量x返回</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack stack,ElemType &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(stack.top=<span class="hljs-number">-1</span>)<span class="hljs-comment">//栈空</span><br>        <span class="hljs-keyword">return</span> FALSE;<br>    x=stack.data[stack.top];<span class="hljs-comment">//x记录栈顶元素</span><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>WARNING</p><p>当初始化时<code>stack.top=0;</code>此时读栈顶元素代码变为<code>x=stack.data[stack.top-1];</code></p>          </div><h2 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h2><p class="note note-secondary">定义：利用栈底位置相对不变的特性，可以让两个顺序栈共享一个一维数据空间，将两个栈的栈底分别设置共享空间的两端，两个栈顶向共享空间的中间延伸</p><div class="note note-warning">            <p>0号栈判空：<code>top0==-1</code></p><p>1号栈判空：<code>top1==MaxSize</code></p><p>栈满：<code>top1-top0==1</code></p><p>0号栈进栈 <strong>top0先加一再赋值</strong></p><p>1号栈进制<strong>top1先减一再赋值</strong></p><p>0号栈出栈<strong>先取值再top0减一</strong></p><p>1号栈出栈<strong>先取值再top1加一</strong></p>          </div><p>优点：更有效的利用存储空间，两个栈空间相互调节只有整个存储空间被占满才发生上溢</p><h2 id="栈的链式存储"><a href="#栈的链式存储" class="headerlink" title="栈的链式存储"></a>栈的链式存储</h2><p class="note note-info">特点：使用线性表的链式存储即单链表表示栈</p><h3 id="0-链式栈的类型描述"><a href="#0-链式栈的类型描述" class="headerlink" title="0.链式栈的类型描述"></a>0.链式栈的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackNode</span>&#123;<br>    ElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackNode</span> *next;<br>&#125;StackNode,*LinkStack;<br></code></pre></td></tr></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p class="note note-secondary">定义：只允许在一端进行插入操作，而在另一端进行删除操作的<B>线性表</B></p><ul><li>队头：线性表只允许删除的那一端</li><li>队尾：只允许进行插入的那一端</li><li>空队列：不含任何元素的空表</li></ul><div class="note note-warning">            <p>注意：</p><ol><li>队列本质是线性表，是<strong>操作受限的线性表</strong></li><li>线性表可以有空表，队列也有<strong>空队列</strong></li><li>插入：入队、出队</li><li>删除：出队</li><li>队列的操作特性：<span class="label label-primary">先进先出(FIFO)</span></li></ol>          </div><h3 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h3><p class="note note-info">特点：分配一块连续的存储单元存放队列中的元素，并附设两个指针<b>front</b>与<b>rear</b>分别指示队头元素和队尾元素的位置</p><h3 id="0-顺序队列的类型描述"><a href="#0-顺序队列的类型描述" class="headerlink" title="0.顺序队列的类型描述"></a>0.顺序队列的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 50</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    ElemType data[MaxSize];<br>    <span class="hljs-type">int</span> front,rear;<br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><ul><li>初始状态：<strong>Q.front&#x3D;&#x3D;Q.rear&#x3D;&#x3D;0</strong></li><li>进队操作：队不满时，先赋值再<strong>Q.rear++</strong>;</li><li>出队操作：队不空时，先取值再<strong>Q.front++</strong>;</li></ul><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>把顺序队列从<strong>逻辑</strong>上看成一个环，成为循环队列</p><ul><li><p>初始时：<strong>Q.rear&#x3D;Q.front&#x3D;0；</strong></p></li><li><p>入队时：<strong>Q.rear&#x3D;(Q.rear+1)%MaxSize</strong></p></li><li><p>出队时：<strong>Q.front&#x3D;(Q.front+1)%MaxSize</strong></p></li><li><p>队列长度：<b>(Q.rear-Q.front+MaxSize)%MaxSize </b></p></li><li><p>判空：<strong>if(Q.rear&#x3D;&#x3D;Q.front)</strong></p></li><li><p>判满：<strong>if(Q.rear&#x3D;&#x3D;Q.front)</strong></p><ul><li><p>判空和判满重复！！改进：</p><ul><li><p>牺牲一个存储单元来区分队空还是队满</p><p>队空：<strong>Q.front&#x3D;&#x3D;Q.rear</strong></p><p>队满：<b> (Q.rear+1)%MaxSize&#x3D;&#x3D;Q.front</b></p><p>队中元素个数：<b> (Q.rear-Q.front+MaxSize)%MaxSize</b></p></li><li><p>增设一个记录当前数据元素的变量<strong>Q.size</strong></p><p>队空：<strong>Q.size&#x3D;&#x3D;0</strong></p><p>队满：<strong>Q.size&#x3D;&#x3D;MaxSize</strong></p><p>队中元素个数：<strong>Q.size</strong></p></li><li><p>增设tag变量，记录最后一次操作是插入还是删除</p><p>tag&#x3D;0，表示最后一次操作是删除</p><p>tag&#x3D;1，表示最后一次操作是插入</p><p>队空：<strong>if(Q.front&#x3D;&#x3D;Q.rear&amp;&amp;tag&#x3D;&#x3D;0)</strong></p><p>队满：<strong>if(Q.front&#x3D;&#x3D;Q.rear&amp;&amp;tag&#x3D;&#x3D;1)</strong></p><p>队中元素个数：<b> (Q.rear-Q.front+MaxSize)%MaxSize</b></p></li></ul></li></ul></li></ul><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h3><p class="note note-success">目标：初始化一个循环队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span></span>&#123;<br>    Q.rear=Q.front=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始化队首、队尾指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-判队空"><a href="#2-判队空" class="headerlink" title="2.判队空"></a>2.判队空</h3><p class="note note-success">目标：判断给定队列是否为空，若空返回TRUE,否则返回FALSE</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QueueEmpty</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear==Q.front)<span class="hljs-comment">//队空条件(使用方法一改进循环队列)</span><br>        <span class="hljs-keyword">return</span> TRUE;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-入队"><a href="#3-入队" class="headerlink" title="3.入队"></a>3.入队</h3><p class="note note-success">目标：向循环队列入队一个元素，若入队失败返回FALSE，若入队成功返回TRUE</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TURE 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FALSE 0</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q,ElemType x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>((Q.rear+<span class="hljs-number">1</span>)%MaxSize==Q.front)<span class="hljs-comment">//队满(使用方法一改进循环队列)</span><br>        <span class="hljs-keyword">return</span> FALSE;<br>    Q.data[Q.rear]=x;<br>    Q.rear=(Q.rear+<span class="hljs-number">1</span>)%MaxSize;<span class="hljs-comment">//后移循环队列队尾指针</span><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-出队"><a href="#4-出队" class="headerlink" title="4.出队"></a>4.出队</h3><p class="note note-success">目标：从循环队列出队一个元素，若出队失败返回FALSE，若出队成功返回TRUE，并引用变量x返回出队元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TURE 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FALSE 0</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q,ElemType &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>((Q.rear==Q.front)<span class="hljs-comment">//队空(使用方法一改进循环队列)</span><br>        <span class="hljs-keyword">return</span> FALSE;<br>    x=Q.data[Q.front];<br>    Q.front=(Q.front+<span class="hljs-number">1</span>)%MaxSize;<span class="hljs-comment">//后移循环队列队头指针</span><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h2><p class="note note-info">特点：使用链表来表示队列</p><h3 id="0-链式队列的类型描述"><a href="#0-链式队列的类型描述" class="headerlink" title="0.链式队列的类型描述"></a>0.链式队列的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">QNode</span>&#123;<br>    ElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">QNode</span> *next;<br>&#125;QNode,*QueuePtr;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    QueuePtr front;<br>    QueuePtr rear;<br>&#125;LinkQueue;<br></code></pre></td></tr></table></figure><ul><li>链队列本质是一个同时带队头指针和队尾指针的单链表</li><li>判空：<strong>if(Q.front&#x3D;&#x3D;Q.rear)</strong></li></ul><h3 id="1-初始化-1"><a href="#1-初始化-1" class="headerlink" title="1.初始化"></a>1.初始化</h3><p class="note note-success">目标：初始化一个带头结点的链式队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span>&#123;<br>    Q.front=Q.rear=(QNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(QNode));<br>    Q.front-&gt;next=NUll;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-判队空-1"><a href="#2-判队空-1" class="headerlink" title="2.判队空"></a>2.判队空</h3><p class="note note-success">目标：判断队列是否为空，若空返回TRUE，否则返回FALSE</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QueueEmpty</span><span class="hljs-params">(LinkQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front==Q.rear)<br>        <span class="hljs-keyword">return</span> TRUE;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-入队-1"><a href="#3-入队-1" class="headerlink" title="3.入队"></a>3.入队</h3><p class="note note-success">目标：向链式队列中入队一个元素x</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q,ElemType x)</span></span>&#123;<br>    s=(QNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LinkNode));<br>    s-&gt;data=x;<br>    s-&gt;next=<span class="hljs-literal">NULL</span>;<br>    Q.rear-&gt;next=s;<br>    Q.rear=s;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-出队-1"><a href="#4-出队-1" class="headerlink" title="4.出队"></a>4.出队</h3><p class="note note-success">目标：从链式队列中出队一个元素，若出队失败返回FALSE，成功返回TRUE，并用引用变量x保持出队元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q,ElemType &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front==Q.rear)<br>        <span class="hljs-keyword">return</span> FALSE;<br>    p=Q.front-&gt;next;<br>    x=p-&gt;data;<span class="hljs-comment">//保存出队元素</span><br>    Q.front-&gt;next=p-&gt;next;<span class="hljs-comment">//修改头结点指针</span><br>    <span class="hljs-keyword">if</span>(Q.rear=P)<span class="hljs-comment">//额外处理仅有一个元素时的Q.rear指针</span><br>        Q.rear=Q.front;<br>    <span class="hljs-built_in">free</span>(p);<span class="hljs-comment">//释放已出队结点</span><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p class="note note-info">特点：允许两端都进行入队和出队操作的队列，元素的逻辑结果仍是线性结构</p><ul><li><p>输出受限的双端队列</p><ul><li>允许在一端进行插入删除，但在另一端只能插入的双端队列</li></ul></li><li><p>输入受限的双端队列</p><ul><li>允许在一端进行插入删除，但在另一端只能删除的双端队列</li></ul></li></ul><p><strong>END</strong></p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-线性表</title>
    <link href="/2021/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2021/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="线性表的链式表示与基本操作"><a href="#线性表的链式表示与基本操作" class="headerlink" title="线性表的链式表示与基本操作"></a>线性表的链式表示与基本操作</h1><h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h2><p class="note note-primary">初始化带头结点的单链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InitLinkList</span><span class="hljs-params">(LinkList &amp;L)</span></span><br><span class="hljs-function"></span>&#123;<br>    L=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<span class="hljs-comment">//为头结点分配空间</span><br>    <span class="hljs-keyword">if</span>(L!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        L-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//初始化next指针为NULL</span><br>        <span class="hljs-keyword">return</span> OK;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">//分配空间失败，返回ERROR</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-采用头插法建立单链表"><a href="#2-采用头插法建立单链表" class="headerlink" title="2.采用头插法建立单链表"></a>2.采用<code>头插法</code>建立单链表</h2><p class="note note-success">特点：每次在头结点后插入新结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LinkList <span class="hljs-title">CreatList1</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>    LNode *node;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(!L)<br>        <span class="hljs-built_in">InitLinkList</span>(L);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;<br>        node=(LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>        node-&gt;data=x;<br>        node-&gt;next=L-&gt;next;<br>        L-&gt;next=node;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-采用尾插法建立单链表"><a href="#3-采用尾插法建立单链表" class="headerlink" title="3.采用尾插法建立单链表"></a>3.采用尾插法建立单链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LinkList <span class="hljs-title">CreatList2</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>    LNode *node;<span class="hljs-type">int</span> x;LNode *r=L;<br>    <span class="hljs-keyword">if</span>(!L)<br>        <span class="hljs-built_in">InitLinkList</span>(L);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;<br>        node=(LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>        node-&gt;data=x;<br>        r-&gt;next=node;<br>        r=node;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    &#125;<br>    r-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-按序号查找结点值"><a href="#4-按序号查找结点值" class="headerlink" title="4.按序号查找结点值"></a>4.按序号查找结点值</h2><p class="note note-warning">从第一个结点出发，顺着next指针逐个往后搜索，直到找到第i个结点，返回该结点，若不存在，则返回NULL</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LinkList <span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L,<span class="hljs-type">int</span> i)</span></span>&#123;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<span class="hljs-comment">//j为计数变量</span><br>    LNode *p=L-&gt;next;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> L;<span class="hljs-comment">//若i==0，返回头结点</span><br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//i值无效，返回NULL</span><br>    <span class="hljs-keyword">while</span>(p&amp;&amp;j&lt;i)&#123;<br>        p=p-&gt;next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-按值查找结点值"><a href="#5-按值查找结点值" class="headerlink" title="5.按值查找结点值"></a>5.按值查找结点值</h2><p class="note note-warning">从第一个结点出发，顺着next指针逐个往后搜索，直到找到结点值等于e的结点，返回该结点，若不存在，则返回NULL</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LinkList <span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L,ElemType e)</span></span>&#123;<br>    LNode *p=L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p&amp;&amp;p-&gt;data!=e)&#123;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-插入结点操作"><a href="#6-插入结点操作" class="headerlink" title="6.插入结点操作"></a>6.插入结点操作</h2><p class="note note-info">目标：将值为x的新结点插入到单链表的第i个位置上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">LinkList <span class="hljs-title">insertforlist</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> i)</span></span>&#123;<br>    LNode *p=<span class="hljs-built_in">GetElem</span>(L,i<span class="hljs-number">-1</span>);LNode *node;<span class="hljs-comment">//调用GetElem函数</span><br>    node=(LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>    node-&gt;data=x;<br>    node-&gt;next=p-&gt;next;<br>    p-&gt;next=node;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-删除结点操作"><a href="#7-删除结点操作" class="headerlink" title="7.删除结点操作"></a>7.删除结点操作</h2><p class="note note-info">目标：将单链表的第i个位置上结点删除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LinkList <span class="hljs-title">DeleteElem</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> i)</span></span>&#123;<br>LNode * p=<span class="hljs-built_in">GetElem</span>(L,i<span class="hljs-number">-1</span>);LNode *q;<br>    q=p-&gt;next;<br>    p-&gt;next=q-&gt;next;<br>    <span class="hljs-built_in">free</span>(q);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-求单链表长度"><a href="#8-求单链表长度" class="headerlink" title="8.求单链表长度"></a>8.求单链表长度</h2><p class="note note-info">目标：统计单链表的长度（即包含多少节点）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength_L</span><span class="hljs-params">(LinkList L)</span></span>&#123;<br>    <span class="hljs-comment">//返回L中数据元素个数</span><br>    LNode *p;<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    p=L-&gt;next;<span class="hljs-comment">//p指向第一个结点，因为不包含头结点</span><br>    <span class="hljs-keyword">while</span>(p)&#123;<span class="hljs-comment">//遍历单链表，统计节点数</span><br>        i++;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-light">未完待续。。</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSM框架-MyBatis</title>
    <link href="/2021/09/25/MyBatis/"/>
    <url>/2021/09/25/MyBatis/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p>MyBatis 是当前主流的 Java 持久层框架之一，它与 Hibernate 一样，也是一种 ORM 框架。因其性能优异，且具有高度的灵活性、可优化性和易于维护等特点，所以受到了广大互联网企业的青睐，是目前大型互联网项目的首选框架。</p><h2 id="1-MyBatis核心组件介绍"><a href="#1-MyBatis核心组件介绍" class="headerlink" title="1.MyBatis核心组件介绍"></a>1.MyBatis核心组件介绍</h2><p><strong>MyBatis简介</strong></p><p><code>MyBatis</code> 是一个支持普通 <code>SQL</code> 查询、存储过程以及高级映射的持久层框架；使用简单的 <code>XML</code> 或注解进行配置和原始映射，用以将接口和 Java 的 <code>POJO</code>（普通 Java 对象）映射成数据库中的记录，使得 Java 开发人员可以使用面向对象的编程思想来操作数据库。</p><p><strong>MyBatis 工作原理</strong></p><p><code>MyBatis</code> 框架在操作数据库时，大体经过了8个步骤，如图1所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Manchesterss/picx-image@main/2020/image.531wzrhgdtw0.png" alt="图1 MyBit 框架执行流程图"></p><ol><li>读取 MyBatis 配置文件 mybatis-config.xml。该文件配置了 MyBatis 的运行环境等信息（获取数据库连接）；</li><li>加载映射文件 Mapper.xml。该文件配置了操作数据库的SQL语句。需在 mybatis-config.xml 中加载才能执行，可加载多个配置文件，每个配置文件对应数据库中的一张表；</li><li>构建会话工厂。通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory；</li><li>创建 SqlSession 对象。由会话工厂创建 SqlSession对 象，该对象中包含了执行SQL的所有方法；</li><li>MyBatis 底层定义了一个 Executor 接口来操作数据库，其根据 SqlSession 传递的参数动态地生成需要执行的SQL语句，同时负责查询缓存的维护；</li><li>在 Executor 接口的执行方法中，包含一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等。Mapper.xml 文件中一个 SQL 对应一个 MappedStatement 对象， SQL 的 id 即是 MappedStatement 的 id；</li><li>输入参数映射。在执行方法时，Executor执行器会通过 MappedStatement 对象在执行SQL前，将输入的 Java 对象映射到SQL语句中；</li><li>输出结果映射。在数据库中执行完 SQL 语句后，Executor 执行器会通过 MappedStatement 对象在执行 SQL 语句后，将输出结果映射至 Java 对象中；</li></ol><p><strong>MyBatis 核心对象</strong></p><p>在使用 MyBatis 框架时，主要涉及两个核心对象 <code>SqlSessionFactory</code> 和 <code>SqlSession</code>，它们在 MyBatis 框架中起着至关重要的作用。</p><ul><li><p>SqlSessionFactory</p><p>  它是单个数据库映射关系经过编译后的内存镜像，其主要作用是创建 SqlSession。SqlSessionFactoryBuilder 通过 XML 配置文件或一个预先定义好的 Configuration 实例来构建 SqlSessionFactory 实例。其实例是线程安全的。示例代码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 读取配置文件</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;配置文件位置&quot;</span>);<br><span class="hljs-comment">// 根据配置文件构建SqlSessionFactory</span><br><span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">ssf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br></code></pre></td></tr></table></figure></li><li><p>SqlSession</p><p>  它是应用程序与持久层之间执行交互操作的一个单线程对象，其主要作用是执行持久化操作。SqlSession 对象包含了数据库中所有执行 SQL 操作的方法。其底层封装了 JDBC 连接，可直接使用其实例来执行已映射的 SQL 语句。其常用方法如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// statement参数是配置文件中定义的&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;和&lt;delete&gt;元素的id</span><br><span class="hljs-comment">// 单个查询</span><br>&lt;T&gt;T <span class="hljs-title function_">selectOne</span><span class="hljs-params">(String statement)</span>;<br>&lt;T&gt;T <span class="hljs-title function_">selectOne</span><span class="hljs-params">(String statement，Object parameter)</span>;<br><span class="hljs-comment">// 列表查询</span><br>&lt;E&gt;List&lt;E&gt; <span class="hljs-title function_">selectList</span><span class="hljs-params">(String statment)</span>;<br>&lt;E&gt;List&lt;E&gt; <span class="hljs-title function_">selectList</span><span class="hljs-params">(String statment, Object parameter)</span>;<br>&lt;E&gt;List&lt;E&gt; <span class="hljs-title function_">selectList</span><span class="hljs-params">(String statment, Object parameter, RowBounds rowBounds)</span>;<br><span class="hljs-comment">// 插入</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String statement)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String statement, Object parameter)</span>;<br><span class="hljs-comment">// 更新</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String stetement)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String statement, Object parameter)</span>;<br><span class="hljs-comment">// 删除</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String statement)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String statement, Object prameter)</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="任务代码"><a href="#任务代码" class="headerlink" title="任务代码"></a>任务代码</h3><p><strong><code>TestMybatis.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.educode.test;<br><span class="hljs-keyword">import</span> com.educode.model.Customer;<br><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMybatis</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        init();<br>        <span class="hljs-comment">// 1. 读取配置文件</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 2. 根据配置文件构建SqlSessionFactory,并赋值给sqlSessionFactory变量</span><br>        sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>        <span class="hljs-comment">// 3. 通过sqlSessionFactory创建sqlSession</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>        <span class="hljs-comment">// 4. 新增客户,sqlSession执行映射文件中定义的SQL,并返回映射结果</span><br>        <span class="hljs-type">Customer</span> <span class="hljs-variable">newCustomer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>(<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-string">&quot;teacher&quot;</span>, <span class="hljs-string">&quot;1888888888&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> sqlSession.insert(<span class="hljs-string">&quot;addCustomer&quot;</span>, newCustomer);<br>        <span class="hljs-keyword">if</span> (rows &gt; <span class="hljs-number">0</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;新增客户成功!&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">Customer</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">/********* Begin *********/</span><br>        <span class="hljs-comment">// 5. 查询客户,sqlSession执行映射文件中定义的SQL,并将返回映射结果赋值给customer变量</span><br>        customer = sqlSession.selectOne(<span class="hljs-string">&quot;findCustomerByName&quot;</span>, <span class="hljs-string">&quot;lisi&quot;</span>);<br>        <span class="hljs-comment">/********* End *********/</span><br>        System.out.println(customer);<br>        <span class="hljs-comment">// 6. 提交事务</span><br>        sqlSession.commit();<br>        <span class="hljs-comment">// 7. 关闭sqlSession</span><br>        sqlSession.close();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        <span class="hljs-comment">// 获取 jdbcTemplate 实例</span><br>        <span class="hljs-type">JdbcTemplate</span> <span class="hljs-variable">jdbcTemplate</span> <span class="hljs-operator">=</span> (JdbcTemplate) applicationContext.getBean(<span class="hljs-string">&quot;jdbcTemplate&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            jdbcTemplate.execute(<span class="hljs-string">&quot;DROP TABLE customer&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        &#125;<br>        <span class="hljs-comment">// 定义创建客户表SQL</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">createCustomerSQL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;CREATE TABLE customer(&quot;</span> +<br>                <span class="hljs-string">&quot;id INT PRIMARY KEY auto_increment,&quot;</span> +<br>                <span class="hljs-string">&quot;name VARCHAR(20),&quot;</span> +<br>                <span class="hljs-string">&quot;jobs VARCHAR(50),&quot;</span> +<br>                <span class="hljs-string">&quot;phone VARCHAR(50))&quot;</span>;<br>        jdbcTemplate.execute(createCustomerSQL);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-MyBatis配置文件"><a href="#2-MyBatis配置文件" class="headerlink" title="2.MyBatis配置文件"></a>2.MyBatis配置文件</h2><p>MyBatis 的核心配置文件中，包含了很多影响  MyBatis行为的重要信息。其中  configuration 元素是配置文件的根元素，其它元素都要在该元素内配置；</p><p><strong>properties</strong></p><p>该元素通常用于将内部的配置外在化，即通过外部的配置来动态地替换内部定义的属性。例如，数据库的连接等属性，就可以通过典型的 Java 属性文件中的配置来替换。示例如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">// 引入 db.properties 配置文件中的属性<br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;db.properties&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>settings</strong></p><p>该元素主要用于改变 MyBatis 运行时的行为，例如开启二级缓存、开启延迟加载等。</p><table><thead><tr><th>设置参数</th><th>描述</th><th>有效值</th></tr></thead><tbody><tr><td>cacheEnable</td><td>是否开启全局缓存</td><td>true|false（默认）</td></tr><tr><td>lazyLoadingEnable</td><td>是否开启全局延迟加载</td><td>true|false（默认）</td></tr><tr><td>multipleResultSetsEnable</td><td>是否允许单一语句返回多结果集</td><td>true（默认）|false</td></tr><tr><td>useColumnLabel</td><td>使用列标签代替列名</td><td>true（默认）|false</td></tr><tr><td>useGeneratedKeys</td><td>允许 JDBC 支持自动生成主键</td><td>true|false（默认）</td></tr><tr><td>defaultStatementTimeout</td><td>配置默认执行器</td><td>SIMPLE（默认）、REUSE（重用预处理语句）、BATCH（重用语句并执行批量执行）</td></tr><tr><td>mapUnderscoreToCamelCase</td><td>是否开启自动驼峰命名规则映射</td><td>true|false（默认）</td></tr><tr><td>jdbcTypeForNull</td><td>当参数没有指定 JDBC 类型时，设置默认 JDBC 类型</td><td>NULL、VARCHAR、OTHER（默认）</td></tr></tbody></table><p><strong>typeAliases</strong></p><p>该元素用于为配置文件中的 Java 类型设置一个简短的名字，即设置别名。别名的设置与 XML 配置相关，其使用的意义在于减少全限定类名的冗余。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 定义别名 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- alias指定自定义的别名，省略时，默认将类名首字母小写后的名称作为别名 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- type指定需要被定义别名的类的全限定名 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.educode.model.User&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用自动扫描包来定义别名 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- name指定要被定义别名的包，将包中所有的POJO类以首字母小写的非限定类名来作为它的别名 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.educode.model&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可使用注解定义类型别名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Alias(value=&quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p><strong>typeHandler</strong></p><p>typeHandler 的作用是将预处理语句中传入的参数从 javaType（Java 类型）转换为 jdbcType（JDBC 类型），或者从数据库取出结果时将 jdbcType 转换为 javaType。</p><p>MyBatis 框架提供的常用类型处理器</p><table><thead><tr><th>类型处理器</th><th>java 类型</th><th>JDBC 类型</th></tr></thead><tbody><tr><td>BooleanTypeHandle</td><td>java.lang.Boolean, boolean</td><td>数据库兼容的 BOOLEAN</td></tr><tr><td>ByteTypeHandle</td><td>java.lang.Byte, byte</td><td>数据库兼容的 NUMERIC 或 BYTE</td></tr><tr><td>ShortTypeHandle</td><td>java.lang.Short, short</td><td>数据库兼容的 NUMERIC 或 SHORT INTEGER</td></tr><tr><td>IntegerTypeHandle</td><td>java.lang.Integer, int</td><td>数据库兼容的 NUMERIC 或 INTEGER</td></tr><tr><td>LongTypeHandle</td><td>java.lang.Long, long</td><td>数据库兼容的 NUMERIC 或 LONG INTEGER</td></tr><tr><td>FloatTypeHandle</td><td>java.lang.Float, float</td><td>数据库兼容的 NUMERIC 或 FLOAT</td></tr><tr><td>DoubleTypeHandle</td><td>java.lang.Doubel, duoble</td><td>数据库兼容的 NUMERIC 或 DOUBLE</td></tr><tr><td>StringTypeHandle</td><td>java.lang.String</td><td>CHAR 或 VARCHAR</td></tr><tr><td>DateTypeHandle</td><td>java.util.Date</td><td>TIMESTAMP</td></tr></tbody></table><p>可以通过自定义的方式对类型处理器进行扩展，typeHandler 元素用于在配置文件中注册自定义的类型处理器.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeHandlers</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 以单个类的形式配置 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeHandler</span> <span class="hljs-attr">handler</span>=<span class="hljs-string">&quot;com.educode.handler.userTypeHandler&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 注册一个包中所有的typeHandler，系统在启动时会自动扫描包下的所有 --&gt;</span><br>    &lt;packagename=&quot;com.educode.handler&quot;/&gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">typeHandlers</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>objectFactory</strong></p><p>MyBatis 框架每次创建结果对象的新实例时，都会使用一个对象工厂 ObjectFactory 的实例来完成。MyBatis 中默认的 ObjectFactory 的作用就是实例化目标类，它既可以通过默认构造方法实例化，也可以在参数映射存在的时候通过参数构造方法来实例化。</p><p><strong>plugins</strong></p><p>MyBatis 允许在已映射语句执行过程中的某一点进行拦截调用，这种拦截调用是通过插件来实现的。plugins 元素的作用就是配置用户所开发的插件。</p><p><strong>environments</strong></p><p>该元素用于多种数据源配置，即配置多种数据库。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- default属性指定默认的环境ID --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 使用JDBC事务管理 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 配置数据源 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;product&quot;</span>&gt;</span><br>    ...<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 MyBatis 中，可以配置两种类型的事务管理器，分别是 JDBC 和 MANAGED。在 Spring + MyBatis 项目中，一般使用 Spring 自带的管理器来实现事务管理。</p><p>MyBatis 框架提供了 UNPOOLED 、POOLED 和 JNDI 三种数据源类型进行数据源配置。实际开发中，一般使用 POOLED 类型，此数据源利用池的概念将 JDBC 连接对象组织起来，避免了在创建新的连接实例时所需要初始化和认证的时间。这种方式使得并发 Web 应用可以快速地响应请求。配置属性说明如下:</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>poolMaximumActiveConnections</td><td>在任意时间可以存在的活动连接数，默认值：10</td></tr><tr><td>poolMaximumIdelConnections</td><td>任意时间可能存在的空闲连接数</td></tr><tr><td>poolMaximumCheckoutTime</td><td>在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000毫秒</td></tr><tr><td>poolTimeToWait</td><td>连接等待时间过长，重新尝试获取一个连接，默认值：20000毫秒</td></tr><tr><td>poolPingQuery</td><td>发送到数据库的侦测查询，用于检验连接是否正常工作</td></tr><tr><td>poolPingEnable</td><td>是否启用侦测查询，默认值：false</td></tr><tr><td>poolPingConnectionsNotUsedFor</td><td>配置 poolPingQuery 的使用频度。默认值：0</td></tr></tbody></table><p><strong>mappers</strong></p><p>该元素用于指定 MyBatis 映射文件的位置，具体指定方法如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用类路径引入 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/educode/mapper/UserMapper.xml&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用本地文件路径引入 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file:///D:/com/educode/mapper/UserMapper.xml&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用接口类引入 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.educode.mapper.UserMapper&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用包名引入 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.educode.mapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="任务代码-1"><a href="#任务代码-1" class="headerlink" title="任务代码"></a>任务代码</h3><p><strong><code>mybatisConfig.xml</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-comment">&lt;!-- ********* Begin ********* --&gt;</span><br><span class="hljs-comment">&lt;!-- 1. 引入 db.properties 配置文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;db.properties&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 2. ﻿使用自动扫描 com.educode.model 包来定义别名 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.educode.model&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 3.配置环境,默认环境 id 为 mysql --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 3.1 使用JDBC事务管理 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 3.2 配置数据源 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 4.配置 Mapper 的位置, 路径为: mapper/CustomerMapper.xml --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用类路径引入 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mapper/CustomerMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-comment">&lt;!-- ********* End ********* --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-MyBatis的映射器"><a href="#3-MyBatis的映射器" class="headerlink" title="3.MyBatis的映射器"></a>3.MyBatis的映射器</h2><p>MyBatis 框架的强大之处就体现在映射文件的编写上。mapper 元素是映射文件的根元素，其他元素都是它的子元素。这些子元素及其作用如图2所示：<br><img src="https://cdn.jsdelivr.net/gh/Manchesterss/picx-image@main/2020/image-(1).3ta7wwzwk5o0.png" alt="图2-映射文件主要元素"><br><strong>select</strong></p><p>该元素用于映射查询语句，示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findCustomerById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.educode.model.Customer&quot;</span>&gt;</span><br>    select * from t_customer where id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>该查询语句的唯一标识为 findCustomerById，它接收一个 Integer 类型的参数，并返回一个 Customer 类型的对象。</p><p>select常用可配置属性</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>表示命名空间中的唯一标识，常与命名空间组合起来使用</td></tr><tr><td>parameterType</td><td>传入 SQL 语句的参数类的全限定名或者别名</td></tr><tr><td>resultType</td><td>从 SQL 语句中返回的类型的类的全限定名或者别名</td></tr><tr><td>resultMap</td><td>表示外部 resultMap 的命名引用</td></tr><tr><td>flushCache</td><td>执行 SQL 语句后，是否需要清空之前查询的本地缓存和二级缓存，默认值：false</td></tr><tr><td>userCache</td><td>是否开启二级缓存，默认值：false</td></tr><tr><td>timeout</td><td>设置超时参数，单位为秒。超时将抛出异常</td></tr><tr><td>fetchSize</td><td>获取记录的总条数设定，默认值：unset（依赖于驱动）</td></tr><tr><td>statementType</td><td>设置 MyBatis 工作 JDBC 的 Statement</td></tr><tr><td>resultSet</td><td>表示结果集的类型，默认值：unset（依赖于驱动）</td></tr></tbody></table><p><strong>insert</strong></p><p>该元素用于映射插入语句，在执行完元素中定义的 SQL 语句后，会返回插入的记录数。该元素的属性与 select 元素的属性大部分相同，但还包含了3个特有属性.</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>keyProperty</td><td>将插入或更新操作时的返回值赋给指定返回类的某个属性，常设置为主键对应的属性</td></tr><tr><td>keyColumn</td><td>设置第几列是主键，当主键不是列表中第一列时需要设置</td></tr><tr><td>useGeneratedKeys</td><td>获取数据库内部生成的主键，如 MySQL 的自动递增字段，默认值：false</td></tr></tbody></table><p>当执行插入操作后需要返回插入成功的数据生成的主键值时，可通过以上3个属性实现，示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addCustomer&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.educode.model.Customer&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    insert into t_customer(name,jobs)values(#&#123;username&#125;,#&#123;jobs&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p>若使用数据库不支持主键自动增长或消除了主键自增的规则时，MyBatis 可自定义生成主键，示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertCustomer&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.educode.model.Customer&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Integer&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 如果t_customer表中没有记录，则将id设置为1，否则就将id的最大值加1，来作为新的主键 --&gt;</span><br>        select if(max(id) is null,1,max(id)+1) as newId from t_customer<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span><br>    insert into t_customer(id,name,jobs)values(#&#123;id&#125;,#&#123;name&#125;,#&#123;jobs&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中 order 属性如果设置为 BEFORE，那么它会首先执行 selectKey 元素中的配置来设置主键，然后执行插入语句；如果设置为 AFTER，那么它会先执行插入语句，然后执行 selectKey 元素中的配置内容。</p><p><strong>update、delete</strong></p><p>update 和 delete 元素的属性基本与 select 元素中的属性一致。在执行完元素中定义的 SQL 语句后，会返回影响的记录数。示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 更新信息 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateCustomer&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.educode.model.Customer&quot;</span>&gt;</span><br>    update t_customer set name=#&#123;name&#125;,jobs=#&#123;jobs&#125; where id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 删除信息 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteCustomer&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span>&gt;</span><br>    delete from t_customer where id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>sql</strong></p><p>该元素的作用就是定义可重用的 SQL 代码片段，然后在其他语句中引用这一代码片段。示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 定义一个包含id、username、jobs和phone字段的代码片段 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;customerColumns&quot;</span>&gt;</span>id,username,jobs,phone<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findCustomerById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.educode.Customer&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- refid属性引用了自定义的代码片段 --&gt;</span><br>    select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;customerColumns&quot;</span>/&gt;</span> from t_customer where id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>resultMap</strong></p><p>该元素表示结果映射集。主要作用是定义映射规则、级联的更新以及定义类型转化器等。其包含的子元素及结构说明如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- resultMap的元素结构 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 类在实例化时,用来注入结果到构造方法中 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- ID参数;标记结果作为ID --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">idArg</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 注入到构造方法的一个普通结果 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">arg</span>/&gt;</span>　　　<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">constructor</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 用于表示哪个列是主键 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>/&gt;</span>　　　　　<br>    <span class="hljs-comment">&lt;!-- 注入到字段或JavaBean属性的普通结果 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span>/&gt;</span>　　　<br>    <span class="hljs-comment">&lt;!-- 用于一对一关联 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span>　<br>    <span class="hljs-comment">&lt;!-- 用于一对多关联 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span>　<br>    <span class="hljs-comment">&lt;!-- 使用结果值来决定使用哪个结果映射 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">discriminator</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 基于某些值的结果映射 --&gt;</span><br>        &lt;casevalue=&quot;&quot;/&gt;　　　　<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">discriminator</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在默认情况下，MyBatis 程序在运行时会自动地将查询到的数据与需要返回的对象的属性进行匹配赋值（需要表中的列名与对象的属性名称完全一致）。然而实际开发时，数据表中的列和需要返回的对象的属性可能不会完全一致，这种情况下 MyBatis 是不会自动赋值的。此时，就可以使用 resultMap 元素进行处理。</p><h3 id="任务代码-2"><a href="#任务代码-2" class="headerlink" title="任务代码"></a>任务代码</h3><p><strong><code>CustomerMapper.xml</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;mapper.CustomerMapper.xml&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 新增客户 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addCustomer&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;customer&quot;</span>&gt;</span><br>        insert into customer(name,jobs,phone) value(#&#123;name&#125;,#&#123;jobs&#125;,#&#123;phone&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 根据客户姓名查找客户信息 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findCustomerByName&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;customer&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span>&gt;</span><br>        select * from customer where name = #&#123;name&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-comment">&lt;!-- ********* Begin ********* --&gt;</span><br><span class="hljs-comment">&lt;!-- 定义一个包含id、username字段的代码片段 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;customerColumns&quot;</span>&gt;</span>id,name<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 新增客户,需返回插入数据生成的主键值id, id=addCustomerKey  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addCustomerKey&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;customer&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    insert into customer(name,jobs)values(#&#123;name&#125;,#&#123;jobs&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 根据id查找客户信息,使用SQL代码片段设置返回属性, id=findCustomerById --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findCustomerById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;customer&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- refid属性引用了自定义的代码片段 --&gt;</span><br>    select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;customerColumns&quot;</span>/&gt;</span> from customer where id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 根据id更新客户name、jobs和phone信息, id=updateCustomer --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateCustomer&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;customer&quot;</span>&gt;</span><br>    update customer set name=#&#123;name&#125;,phone=#&#123;phone&#125;,jobs=#&#123;jobs&#125; where id=#&#123;id&#125; <br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 根据id删除客户信息, id=deleteCustomer --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteCustomer&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span>&gt;</span><br>    delete from customer where id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- ********* End ********* --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-动态SQL"><a href="#4-动态SQL" class="headerlink" title="4.动态SQL"></a>4.动态SQL</h2><p>开发人员在使用 JDBC 或其他类似的框架进行数据库开发时，通常都要根据需求去手动拼装 SQL，这样非常繁琐。而 MyBatis 提供的对 SQL 语句动态组装的功能很方便的完成 SQL 拼装。</p><p>MyBatis 采用了功能强大的基于 OGNL 的表达式来完成动态 SQL。其主要元素说明如下:</p><table><thead><tr><th>元素</th><th>说明</th></tr></thead><tbody><tr><td>if</td><td>判断语句，用于单条件分支判断</td></tr><tr><td>choose（when、otherwise）</td><td>用于多条件分支判断，相当于的 java 中 switch</td></tr><tr><td>where、trim、set</td><td>辅助元素、用于处理一些 SQL 拼装、特殊字符问题</td></tr><tr><td>foreach</td><td>循环语句，常用语in语句等列举条件中</td></tr><tr><td>bind</td><td>创建一个变量，并绑定到上下文中，常用于模糊查询</td></tr></tbody></table><p><strong>if</strong></p><p>该元素是最常用的判断语句，它类似于 Java 中的 if 语句，主要用于实现某些简单的条件选择。示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findCustomer&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.educode.Customre&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.educode.Customer&quot;</span>&gt;</span><br>    select * form t_customer where 1=1<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>        and name like = #&#123;name&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;jobs != null&quot;</span>&gt;</span><br>        and jobs like = #&#123;jobs&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用 if 元素的 test 属性分别对 name 和 jobs 进行了非空判断（test 属性多用于条件判断语句中，用于判断真假，大部分的场景中都是进行非空判断，有时候也需要判断字符串、数字和枚举等），如果传入的查询条件非空就进行动态 SQL 组装。</p><p><strong>choose、when、otherwise</strong></p><p>这些元素用于多条件分支判断，相当于的 java 中 switch 语句。示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findCustomerWhen&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;customer&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;customer&quot;</span>&gt;</span><br>    select * from customer where 1 = 1<br>    <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>            and name=#&#123;name&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;jobs != null&quot;</span>&gt;</span><br>            and jobs=#&#123;jobs&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span><br>            and phone is not null<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述代码中，使用了 choose 元素进行 SQL 拼接，当第一个 when 元素中的条件为真，则只动态组装第一个 when 元素内的 SQL 片段，否则就继续向下判断第二个 when 元素中的条件是否为真，以此类推。当前面所有 when 元素中的条件都不为真时，则只组装 otherwise 元素内的 SQL 片段。</p><p><strong>where、trim</strong></p><p>where、trim 元素用于处理一些 SQL 拼装。如使用 where、trim 元素替换映射文件中的<code>where 1=1</code>条件，示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findCustomerWhere&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;customer&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;customer&quot;</span>&gt;</span><br>    select * from customer<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>            and name=#&#123;name&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;jobs != null&quot;</span>&gt;</span><br>            and jobs=#&#123;jobs&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findCustomerTrim&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;customer&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;customer&quot;</span>&gt;</span><br>    select * from customer<br>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;where&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;and&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>            and name=#&#123;name&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;jobs != null&quot;</span>&gt;</span><br>            and jobs=#&#123;jobs&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>where元素会自动判断组合条件下拼装的 SQL 语句，只有 where 元素内的条件成立时，才会在拼接 SQL 中加入 where 关键字，否则将不会添加；即使 where 之后的内容有多余的AND或OR， where 元素也会自动将它们去除。</p><p>trim元素的作用是去除一些特殊的字符串，它的 prefix 属性代表的是语句的前缀（这里使用 where 来连接后面的 SQL 片段），而 prefixOverrides 属性代表的是需要去除的那些特殊字符串（这里定义了要去除 SQL 中的 and）。</p><p><strong>set</strong></p><p>该元素主要用于更新操作，其作用是在动态包含的 SQL 语句前输出一个 SET 关键字，并将 SQL 语句中最后一个多余的逗号去除。示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateCustomerSet&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;customer&quot;</span>&gt;</span><br>    update customer<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>            name=#&#123;name&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;jobs != null&quot;</span>&gt;</span><br>            jobs=#&#123;jobs&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;phone != null&quot;</span>&gt;</span><br>            phone=#&#123;phone&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    where id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述代码中，使用了 set 和 if 元素相结合的方式来组装 update 语句。其中 set 元素会动态前置 SET 关键字，同时也会消除 SQL 语句中最后一个多余的逗号；if 元素用于判断相应的字段是否传入值，如果传入的更新字段非空，就将此字段进行动态 SQL 组装，并更新此字段，否则此字段不执行更新。</p><p><strong>foreach</strong></p><p>该元素用于数组和集合循环的遍历，通常在构建 IN 条件语句时使用，其使用方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findCustomerByIds&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;customer&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;List&quot;</span>&gt;</span><br>    select * from customer where id in<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>        #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述代码中，使用了 foreach 元素对传入的集合进行遍历并进行了动态 SQL 组装，其中使用属性说明如下：</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>item</td><td>配置的是当前循环的元素</td></tr><tr><td>index</td><td>配置的是当前元素在集合的位置下班</td></tr><tr><td>collection</td><td>配置的list是传递过来的参数类型（如array、list、Map集合的键）</td></tr><tr><td>open、close</td><td>配置的是以什么符号将这些集合元素包装起来。</td></tr><tr><td>separator</td><td>配置的是各个元素的间隔符</td></tr></tbody></table><p><strong>bind</strong></p><p>该元素可以通过 OGNL 表达式来创建一个上下文变量。示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findCustomerByPatternName&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;customer&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;customer&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bind</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pattern_name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#x27;%&#x27;+ name +&#x27;%&#x27;&quot;</span>/&gt;</span><br>    select * from customer where name like #&#123;pattern_name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述代码中，使用 bind 元素定义了一个 name 为 pattern_username 的变量， bind 元素中 value 的属性值就是拼接的查询字符串，其中<code>_parameter.getUsername()</code>表示传递进来的参数（也可以直接写成对应的参数变量名，如 username）。在 SQL 语句中，直接引用 bind 元素的 name 属性值即可进行动态 SQL 组装。</p><h3 id="任务代码-3"><a href="#任务代码-3" class="headerlink" title="任务代码"></a>任务代码</h3><p><strong><code>CustomerMapper.xml</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;mapper.CustomerMapper.xml&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 新增客户 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addCustomer&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Customer&quot;</span>&gt;</span><br>        insert into customer(name,jobs,phone) value(#&#123;name&#125;,#&#123;jobs&#125;,#&#123;phone&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 根据客户姓名查找客户信息 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findCustomerByName&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Customer&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span>&gt;</span><br>        select * from customer where name = #&#123;name&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- *********  Begin ********* --&gt;</span><br><span class="hljs-comment">&lt;!-- ﻿使用 if 元素编写根据客户姓名和职业组合条件查询客户信息的动态SQL, id=findCustomerIf --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findCustomerIf&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Customer&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Customer&quot;</span> &gt;</span><br>    select * from customer where 1 = 1<br><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>and name=#&#123;name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;jobs != null&quot;</span>&gt;</span><br>and jobs=#&#123;jobs&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 使用 where 元素编写编写根据客户姓名和职业组合条件查询客户信息的动态SQL, id=findCustomerWhere --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findCustomerWhere&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Customer&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Customer&quot;</span>&gt;</span><br>select * from customer<br><span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>and name=#&#123;name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;jobs != null&quot;</span>&gt;</span><br>and jobs=#&#123;jobs&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 使用 trim 元素编写编写根据客户姓名和职业组合条件查询客户信息的动态SQL, id=findCustomerTrim --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findCustomerTrim&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Customer&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Customer&quot;</span>&gt;</span><br>    select * from customer<br>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;where&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;and&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>            and name=#&#123;name&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;jobs != null&quot;</span>&gt;</span><br>            and jobs=#&#123;jobs&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 使用 foreach 元素编写根据用户id列表查询客户信息的动态SQL, id=findCustomerByIds --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findCustomerByIds&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Customer&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;List&quot;</span>&gt;</span><br>select * from customer where id in<br><span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 使用 bind 元素编写根据客户名模糊查询客户信息的动态SQL, id=findCustomerByPatternName --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findCustomerByPatternName&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Customer&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Customer&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bind</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pattern_name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#x27;%&#x27;+ name +&#x27;%&#x27;&quot;</span>/&gt;</span><br>select * from customer where name like #&#123;pattern_name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-comment">&lt;!-- ********* End ********* --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-Mybatis的关联映射"><a href="#5-Mybatis的关联映射" class="headerlink" title="5.Mybatis的关联映射"></a>5.Mybatis的关联映射</h2><p>针对多表之间的操作，MyBatis 提供了关联映射，可以很好地处理对象与对象之间的关联关系。</p><p><strong>一对一</strong></p><p>一对一的关系就是在本类中定义对方类型的对象，如 A 类中定义 B 类类型的属性 b，B 类中定义 A 类类型的属性 a。MyBatis 通过 resultMap 元素的子元素 association 元素来处理一对一关联关系，通常可以配置以下属性：</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>property</td><td>指定映射到的实体类对象属性，与表字段一一对应</td></tr><tr><td>column</td><td>指定表中对应的字段</td></tr><tr><td>javaType</td><td>指定映射到实体对象属性的类型</td></tr><tr><td>select</td><td>指定引入嵌套查询的子 SQL 语句，该属性用于关联映射中的嵌套查询</td></tr><tr><td>fetchType</td><td>指定在关联查询时是否启用延迟加载，属性值：lazy（默认）、eager</td></tr></tbody></table><p>association 元素的使用可参考如下两种示例配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 嵌套查询 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;idCard&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;IdCard&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.educode.mapperIdCardMapper.findCodeById&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 嵌套结果 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;idCard&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;IdCard&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;card_id&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;code&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;code&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br></code></pre></td></tr></table></figure><p>MyBatis 嵌套查询的方式要执行多条 SQL 语句，这对于大型数据集合和列表展示不是很好，因为这样可能会导致成百上千条关联的 SQL 语句被执行，从而极大地消耗数据库性能并且会降低查询效率。所以通常使用 MyBatis 提供的嵌套结果方式，来进行关联查询。</p><p>以个人和身份证之间的一对一关联关系为例，示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findPersonCard&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;IdCardWithPersonResult&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br>    select p.*,card.code<br>    from person p,idcard card<br>    where p.card_id=card.id<br>    and p.id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;IdCardWithPersonResult&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Person&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;idCard&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;IdCard&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;card_id&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;code&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;code&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>一对多</strong></p><p>一对多的关系就是一个 A 类类型对应多个 B 类类型的情况，需要在 A 类中以集合的方式引入 B 类类型的对象，在 B 类中定义 A 类类型的属性 a。</p><p>MyBatis 通过 resultMap 元素的子元素 collection 元素来处理一对多关联关系。其属性大部分与 association 元素相同，但其还包含一个特殊属性 ofType，ofType 属性与 javaType 属性对应，用于指定实体对象中集合类属性所包含的元素类型。</p><p>collection 元素的使用可参考如下两种示例配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 嵌套查询 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;ordersList&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Orders&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">selett</span>=<span class="hljs-string">&quot;com.educode.mapper.OrdersMapper.selectOrders&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 嵌套结果 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;ordersList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Orders&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;orders_id&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;number&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以一个用户可以有多个订单为例，示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findPersonOrders&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;OrdersWithPersonResult&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br>    select p.*,o.id as orders_id,o.number,o.person_id<br>    from person p,orders o<br>    where p.id=o.person_id<br>    and p.id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;OrdersWithPersonResult&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Person&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;ordersList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Orders&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;orders_id&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;personId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;person_id&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;number&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>多对多</strong></p><p>多对多的关系就是在A类中定义B类类型的集合，在 B 类中定义 A 类类型的集合。在实际项目开发中，多对多的关联关系也是非常常见的。</p><p>以订单和商品为例，一个订单可以包含多种商品，而一种商品又可以属于多个订单，订单和商品就属于多对多的关联关系。示例代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 多对多嵌套结果查询：查询某订单及其关联的商品详情 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findOrders&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;OrdersWithProductResult&quot;</span>&gt;</span><br>    select * from orders where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;OrdersWithProductResult&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Orders&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;number&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;productList&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Product&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.educode.mapper.ProductMapper.findProductById&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findProductById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Product&quot;</span>&gt;</span><br>    select * from product where<br>        id=(selete product_id from ordersitem where orders_id=#&#123;id&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述代码中，使用嵌套查询的方式定义了一个 id 为 findOrdersWithPorduct 的 select 语句来查询订单及其关联的商品信息。在 resultMap 元素中使用了 collection 元素来映射多对多的关联关系，其中 property 属性表示订单持久化类中的商品属性，ofType 属性表示集合中的数据为 Product 类型，而 column 的属性值会作为参数执行 ProductMapper 中定义的 id 为 findProductById 的执行语句来查询订单中的商品信息。</p><p>定义了一个 id 为 findProductById 的执行语句，该执行语句中的 SQL 会根据订单 id 查询与该订单所关联的商品信息。由于订单和商品是多对多的关联关系，所以需要通过中间表 ordersitem 来查询商品信息。</p><h3 id="任务代码-4"><a href="#任务代码-4" class="headerlink" title="任务代码"></a>任务代码</h3><p><strong><code>PersonMapper.xml</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;mapper.PersonMapper.xml&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- ********* Begin ********* --&gt;</span><br><span class="hljs-comment">&lt;!-- 根据 id 查找个人信息与身份证号 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findPersonCard&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;IdCardWithPerson&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br>select p.*,card.code<br>from person p,idcard card<br>where p.card_id=card.id<br>and p.id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;IdCardWithPerson&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Person&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;idCard&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;IdCard&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;card_id&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;code&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;code&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 根据 id 查找个人信息与订单信息 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findPersonOrders&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;OrdersWithPersonResult&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br>select p.*,o.id as orders_id,o.number,o.person_id<br>from person p,orders o<br>where p.id=o.person_id<br>and p.id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;OrdersWithPersonResult&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Person&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;ordersList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Orders&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;orders_id&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;personId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;person_id&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;number&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-comment">&lt;!-- ********* End ********* --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="6-MyBatis的插件开发"><a href="#6-MyBatis的插件开发" class="headerlink" title="6.MyBatis的插件开发"></a>6.MyBatis的插件开发</h2><p>Mybatis 插件也叫 Mybatis 拦截器，实际上它就是一个拦截器，通过应用代理模式，在方法级别上进行拦截。</p><p>它支持拦截以下方法：</p><ul><li>执行器 Executor（update、query、commit、rollback 等方法）；</li><li>参数处理器 ParameterHandler（getParameterObject、setParameters方法）；</li><li>结果集处理器 ResultSetHandler（handleResultSets、handleOutputParameters 等方法）；<br>SQL </li><li>语法构建器 StatementHandler（prepare、parameterize、batch、update、query 等方法）。</li></ul><p><strong>拦截器接口介绍</strong><br>MyBatis 插件需要实现拦截器接口 <strong>Interceptor (org.apache.ibatis.plugin Interceptor ）</strong>，在实现类中对拦截对象和方法进行处理，该接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>  Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable;<br>  Object <span class="hljs-title function_">plugin</span><span class="hljs-params">(Object target)</span>;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProperties</span><span class="hljs-params">(Properties properties)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码可以看出，该接口有三个方法：</p><ul><li>intercept 方法：该方法是 MyBatis 运行时要执行的拦截的方法，通过该方法的参数 invocation 可以得到很多有用的信息，该参数的 getTarget() 方法可以获取当前被拦截的对象，getMethod() 方法可以获取当前被拦截的方法，getArgs() 方法可以获取被拦截方法中的参数。通过调用 invocation.proceed() 方法可以执行被拦截对象真正的方法；</li><li>plugin 方法：target 是被拦截的对象，它的作用是给被拦截对象生成一个代理对象，只需要调用 Mybatis 提供的 Plugin 类的 wrap 静态方法就可以通过 Java 的动态代理拦截目标对象；</li><li>setProperties 方法：允许在 plugin 元素中配置所需参数，该方法在插件初始化的时候会被调用一次。</li></ul><p><strong>拦截器签名</strong></p><p>除了需要实现拦截器接口外，还需要给实现类配置以下拦截器注解。<br>比如想拦截 StatementHandler 对象的 prepare 方法，该方法有一个参数Connection 对象，可以这样声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Intercepts(&#123;</span><br><span class="hljs-meta">    @Signature(</span><br><span class="hljs-meta">        type =StatementHandler.class,</span><br><span class="hljs-meta">        method=&quot;prepare&quot; , </span><br><span class="hljs-meta">        args=&#123;Connection.class&#125;)&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span>&#123;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，<code>@Signature</code> 注解包含以下三个属性：</p><ul><li>type：设置拦截的接口；</li><li>method:设置拦截接口中的方法名；</li><li>args:设置拦截方法的参数类型数组，通过方法名和参数类型可以确定唯一一个方法。</li><li><strong>自定义插件示例</strong></li></ul><p>编写类 MyInterceptor 实现拦截器接口 Interceptor，设置拦截器签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yy;<br><span class="hljs-keyword">import</span> org.apache.ibatis.executor.statement.StatementHandler;<br><span class="hljs-keyword">import</span> org.apache.ibatis.plugin.*;<br><span class="hljs-keyword">import</span> org.apache.ibatis.reflection.MetaObject;<br><span class="hljs-keyword">import</span> org.apache.ibatis.reflection.SystemMetaObject;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><span class="hljs-comment">//完成插件签名，用于拦截StatementHandler对象的parameterize方法</span><br><span class="hljs-meta">@Intercepts(@Signature(type = StatementHandler.class,method = &quot;parameterize&quot;,args=java.sql.Statement.class))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> invocation.getTarget();<br>        <span class="hljs-comment">// 获取MetaObject对象</span><br>        <span class="hljs-type">MetaObject</span> <span class="hljs-variable">metaObject</span> <span class="hljs-operator">=</span> SystemMetaObject.forObject(target);<br>        <span class="hljs-comment">// 获取参数值       </span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> metaObject.getValue(<span class="hljs-string">&quot;parameterHandler.parameterObject&quot;</span>);<br>        <span class="hljs-comment">// 设置参数值 </span><br>        metaObject.setValue(<span class="hljs-string">&quot;parameterHandler.parameterObject&quot;</span>, <span class="hljs-number">3</span>);<br>        <span class="hljs-comment">//执行目标方法</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">proceed</span> <span class="hljs-operator">=</span> invocation.proceed();<br>        <span class="hljs-comment">//返回执行后的返回值</span><br>        <span class="hljs-keyword">return</span> proceed;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">plugin</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">wrap</span> <span class="hljs-operator">=</span> Plugin.wrap(o, <span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">//返回为当前target创建的动态代理</span><br>        <span class="hljs-keyword">return</span> wrap;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProperties</span><span class="hljs-params">(Properties properties)</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，插件签名用于拦截 StatementHandler 对象的 parameterize方法，该插件拦截器可以实现将参数值改为 3。</p><p>在 mybatis 的全局配置文件配置我们自定义的插件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;plugins&gt;<br>  &lt;plugin interceptor=<span class="hljs-string">&quot;com.yy.MyInterceptor&quot;</span>&gt;<br>  &lt;/plugin&gt;<br>&lt;/plugins&gt;<br></code></pre></td></tr></table></figure><p>配置完自定义插件后，当我们执行我们的 mybatis 代码时，会自动加载该插件，执行拦截任务。</p><h3 id="任务代码-5"><a href="#任务代码-5" class="headerlink" title="任务代码"></a>任务代码</h3><p><strong><code>MyInterceptor.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yy;<br><br><span class="hljs-keyword">import</span> org.apache.ibatis.executor.statement.StatementHandler;<br><span class="hljs-keyword">import</span> org.apache.ibatis.plugin.*;<br><span class="hljs-keyword">import</span> org.apache.ibatis.reflection.MetaObject;<br><span class="hljs-keyword">import</span> org.apache.ibatis.reflection.SystemMetaObject;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-comment">// 完成插件签名，用于拦截StatementHandler对象的parameterize方法</span><br><span class="hljs-meta">@Intercepts(@Signature(type = StatementHandler.class,method = &quot;parameterize&quot;,args=java.sql.Statement.class))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> invocation.getTarget();<br>        <span class="hljs-type">MetaObject</span> <span class="hljs-variable">metaObject</span> <span class="hljs-operator">=</span> SystemMetaObject.forObject(target);<br>        <span class="hljs-comment">// 获取参数值</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> metaObject.getValue(<span class="hljs-string">&quot;parameterHandler.parameterObject&quot;</span>);<br>        <span class="hljs-comment">/********* 请在此编写代码 **********/</span><br>        <span class="hljs-comment">/********* Begin **********/</span><br>        <span class="hljs-type">int</span> id=Integer.parseInt(String.valueOf(value));<br>        metaObject.setValue(<span class="hljs-string">&quot;parameterHandler.parameterObject&quot;</span>, id+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">/********* End **********/</span><br>        <span class="hljs-comment">// 执行目标方法</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">proceed</span> <span class="hljs-operator">=</span> invocation.proceed();<br>        <span class="hljs-comment">// 返回执行后的返回值</span><br>        <span class="hljs-keyword">return</span> proceed;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">plugin</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">wrap</span> <span class="hljs-operator">=</span> Plugin.wrap(o, <span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">// 返回为当前target创建的动态代理</span><br>        <span class="hljs-keyword">return</span> wrap;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProperties</span><span class="hljs-params">(Properties properties)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>mybatis_config.xml</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置参件 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- Begin --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.yy.MyInterceptor&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- End --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 和spring整合后 environments配置将废除 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 使用JDBC事务管理 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- 数据库连接池 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mydb?useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf-8&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123123&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 加载映射文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;UserMapper.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- mybatis-config.xml  注册插件--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="MyBatis的解析和运行原理"><a href="#MyBatis的解析和运行原理" class="headerlink" title="MyBatis的解析和运行原理"></a>MyBatis的解析和运行原理</h1><h2 id="1-构建SqlSessionFactory过程"><a href="#1-构建SqlSessionFactory过程" class="headerlink" title="1.构建SqlSessionFactory过程"></a>1.构建SqlSessionFactory过程</h2><p><strong>MyBatis运行过程</strong><br><img src="https://cdn.jsdelivr.net/gh/Manchesterss/picx-image@main/2020/image-(2).3lg7vqmrg2w0.png" alt="图3-MyBatis 的运行过程"><br>上图中各个对象的解释如下：<br><img src="https://cdn.jsdelivr.net/gh/Manchesterss/picx-image@main/2020/image-(3).61faa7gew3g.png" alt="图4-解释"></p><p><strong>SqlSessionFactory 创建</strong></p><p>SqlSessionFactory 是 MyBatis 的核心类之一，它最重要的功能就是提供 MyBatis 的核心接口 SqlSession。MyBatis 使用了 Builder 模式去创建 SqlSessionFactory，在开发中我们可以通过 SqlSessionFactoryBuilder 去构建，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 读取MyBatis核心配置文件</span><br><span class="hljs-type">Reader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span>Resources.getResourceAsReader(<span class="hljs-string">&quot;mybatis_config.xml&quot;</span>);<br><span class="hljs-comment">// 通过reader实例化sqlSessionFactory对象</span><br><span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(reader);<br></code></pre></td></tr></table></figure><p>上述构建步骤分为两步，第一步使通过 org.apache.ibatis builder.xml.XMLConfigBuilder 解析配置的 XML 文件,读出所配置的参数，并将读取的内容存入 org.apache.ibatis.session.Configuration 类对象中。</p><p>第二步使用 Confinguration 对象去创建 SqlSessionFactory。SqlSessionFactory 是一个接口，而不是一个实现类，为此 MyBatis 提供了一个默认的实现类<code>org.apache.ibatis.session.defaults.DefaultSqlSessionFactory</code>。在大部分情况下都没有必要自己去创建新 SqlSessionFactory 实现类。</p><p><strong>Configuration的作用</strong></p><p>SqlSessionFactory 构建中，Configuration 是最重要的，它的作用是:</p><ul><li>读入配置文件，包括基础配置的 XML 和映射器 XML（或注解〉。</li><li>初始化一些基础配置，比如 MyBatis 的别名等，一些重要的类对象（比如插件、映射器、Object 工厂、typeHandlers 对象等）。</li><li>提供单例，为后续创建 SessionFactory 服务，提供配置的参数。</li><li>执行一些重要对象的初始化方法。</li></ul><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p><img src="https://cdn.jsdelivr.net/gh/Manchesterss/picx-image@main/2020/QQ%E5%9B%BE%E7%89%8720211002003109.6cc345qt9r00.png" alt="图5-构建 SqlSessionFactory"></p><h2 id="2-SqlSession运行过程"><a href="#2-SqlSession运行过程" class="headerlink" title="2.SqlSession运行过程"></a>2.SqlSession运行过程</h2><p><strong>获取SqlSession对象</strong></p><p>获取 SqlSession 对象我们用的是以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sqlSession = sqlSessionFactory.openSession();<br></code></pre></td></tr></table></figure><p>上述代码执行后，SqlSessionFactory 的 openSession 方法会获取 SqlSession 接口的实现类 DefaultSqlSession 对象。</p><p>有了 DefaultSqlSession 对象，我们以查询一条数据为例，讲解一下整个处理过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-type">BlogMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(BlogMapper.class);<br>  <span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> mapper.selectBlog(<span class="hljs-number">101</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  session.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们首先获取了 SqlSession 对象，然后通过该对象调用 Mapper 接口中的 selectBlog 方法实现对数据库的操作。</p><p>通过 DefaultSqlSession 对象的 getMapper 方法获取的是一个 MapperProxy 代理对象，这也是 Mapper 接口不用实现类的原因。当调用 BlogMapper 中的方法时，由于 BlogMapper 是一个 JDK 动态代理对象，它会运行 invoke 方法。</p><p>invoke 方法会判断代理的对象是否是一个类，由于代理对象是一个接口，所以通过 cachedMapperMethod 生成一个 MappedMethod 对象，然后执行 execute 方法。</p><p><strong>SqlSession 下的四大对象</strong></p><p>映射器就是一个动态代理对进入到了 MapperMethod 的 execute 方法，然后它经过简单地判断就进入了 SqlSession 的 delete、update、insert、select 等方法，那么这些方法是如何执行呢？<br>实际上 SqlSession 是通过 Executor、StatementHandle、ParamterHandler、ResultSetHandler 来完成数据库操作和结果返回的。</p><ul><li><p>Executor 代表执行器，由它调度 StatementHandler、ParameterHandler、 ResultSetHandler 等来执行对应的 SQL 。其中 StatementHandler 是最重要；</p></li><li><p>StatementHandler 的作用是使用数据库 Statement ( PreparedStatement) 执行操作，它是四大对象的核心，起到承上启下的作用，许多重要的插件都是通过拦截它来实现的；</p></li><li><p>ParameterHandle 是用来处理 SQL 参数的；</p></li><li><p>ResultSetHandl 是进行数据集 (ResultSet) 封装返回处理的。</p></li></ul><p>执行过程如下：</p><p>SqlSession 是通过执行器 Executor 调度 StatementHandler 来运行的，而 StatementHandler 经过以下 3 步：</p><ul><li>prepared 预编译 SQL；</li><li>parameterize 设置参数；</li><li>query／update 执行 SQL。</li></ul><p>其中，parameterize 是调用 parameterHandler 的方法设置的，而参数是根据类型处理器 typeHandler 处理的。query&#x2F;update 方法通过 ResultSetHandler 进行处理结果的封装，如果是 update 语旬，就返回整数，否则就通过 typeHandler 处理结果类型，然后用 ObjectFactory 提供的规则组装对象，返回给调用者。</p><h3 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h3><p><img src="https://cdn.jsdelivr.net/gh/Manchesterss/picx-image@main/2020/QQ%E5%9B%BE%E7%89%8720211002003104.6xhb81g080w0.png" alt="图6-SqlSession 运行过程"></p><blockquote><p>MyBatis: <a href="https://www.educoder.net/shixuns/xmphs457/challenges">1-5</a></p><p>MyBatis的插件开发：<a href="https://www.educoder.net/shixuns/685b94pi/challenges">6</a></p><p>MyBatis 的解析和运行原理：<a href="https://www.educoder.net/shixuns/ovfpnxuy/challenges">1-2</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>SSM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSM框架-Spring Bean的装配方式</title>
    <link href="/2021/09/10/SpringBean%E7%9A%84%E8%A3%85%E9%85%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/09/10/SpringBean%E7%9A%84%E8%A3%85%E9%85%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Bean的装配方式"><a href="#Spring-Bean的装配方式" class="headerlink" title="Spring Bean的装配方式"></a>Spring Bean的装配方式</h1><p>在 Spring 中，对象无需自己查找或创建与其关联的其他对象。而是由容器负责把需要相互协作的对象引用赋予各个对象。创建应用对象之间的协作关系的行为通常称为装配，这也是依赖注入的本质。<br><img src="https://cdn.jsdelivr.net/gh/Manchesterss/picx-image@main/2020/image.g272wz92t8w.png"></p><h2 id="1-基于-XML-的-Bean-装配简介"><a href="#1-基于-XML-的-Bean-装配简介" class="headerlink" title="1.基于 XML 的 Bean 装配简介"></a>1.基于 XML 的 Bean 装配简介</h2><p>Spring 基于 XML 的装配通常有两种实现方式，一是设值注入，二是构造注入。</p><p>在 Spring 实例化 Bean 的过程中，首先会调用默认的构造方法实例化 Bean 对象，然后通过 Java 的反射机制调用 setXxx() 方法进行属性的注入。因此，设值注入要求一个 Bean 的对应类必须满足两个要求：</p><p>一是提供一个无参构造方法；二是为需要注入的属性提供对应的 setter 方法。</p><p>使用设值注入时，在配置文件 <code>applicationContext.xml</code> 中需要使用 bean 元素的子元素 <code>property</code> 为每个属性注入值。</p><p>使用构造注入时，在配置文件中，需要使用 <code>constructor-arg</code> 标签定义构造方法的参数，可以使用其 <code>value</code> 属性设置该参数的值。</p><h3 id="任务代码"><a href="#任务代码" class="headerlink" title="任务代码"></a>任务代码</h3><p><code>Person.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> educoder;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 属性值 name</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// 属性值 age</span><br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-comment">// 请在此处编写代码</span><br>    <span class="hljs-comment">/********* Begin *********/</span><br>    <span class="hljs-comment">//无参构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>    <span class="hljs-comment">//有参构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name,String sex)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>        <span class="hljs-built_in">this</span>.sex=sex;<br>    &#125;<br>    <span class="hljs-comment">/********* End *********/</span><br><br>    <span class="hljs-comment">// 重写 toString 方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-comment">//get和set方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSex</span><span class="hljs-params">(String sex)</span>&#123;<br>        <span class="hljs-built_in">this</span>.sex=sex;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>applicationContext.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 请在此处编写代码 --&gt;</span><br>    <span class="hljs-comment">&lt;!--********* Begin *********--&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用设值注入方式装配Person实例 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;educoder.Person&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;男&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用构造方法装配Person实例 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;educoder.Person&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;李四&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;女&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--********* End *********--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-基于注解的Bean装配"><a href="#2-基于注解的Bean装配" class="headerlink" title="2.基于注解的Bean装配"></a>2.基于注解的Bean装配</h2><p>在 Spring 中，尽管使用 XML 配置文件可以实现 Bean 的装配工作，但如果配置文件中 Bean 的数量较多，会导致 XML 配置文件过于臃肿，从而给维护和升级带来一定的困难。因此，基于注解的 Bean 装配应运而生。</p><p><strong>常用的注解</strong></p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Component 注解</td><td>该注解可以作用在任何层次（Dao 层、Controller 层等），它用来描述 Spring 中的 Bean，但它是一个泛化的概念，仅仅表示一个组件（Bean），使用时只需将该注解标注在相应类上。</td></tr><tr><td>@Repository 注解</td><td>该注解通常作用在数据访问层（DAO 层），用来标识 Spring 中的 Bean，其功能与 @Component 相同。</td></tr><tr><td>@Service 注解</td><td>该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td></tr><tr><td>@Controller 注解</td><td>该注解通常作用在控制层，用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td></tr><tr><td>@Autowired 注解</td><td>用于对 Bean 的属性变量、属性的 Set 方法及构造函数进行标注，配合对应的注解处理器完成 Bean 的自动配置工作。默认按照 Bean 的类型进行装配。</td></tr><tr><td>@Resource 注解</td><td>其作用与 Autowired 一样。其区别在于 @Autowired 默认按照 Bean 类型装配，而 @Resource 默认按照 Bean 实例名称进行装配，该注解有两个重要属性：name 和 type。Spring 将 name 属性解析为 Bean 实例名称，type 属性解析为 Bean 实例类型。如果指定 name 属性，则按实例名称进行装配；如果指定 type 属性，则按 Bean 类型进行装配。如果都不指定，则先按 Bean 实例名称装配，如果不能匹配，则再按照 Bean 类型进行装配；如果都无法匹配，则抛出 NoSuchBeanDefinitionException 异常。</td></tr></tbody></table><h3 id="任务代码-1"><a href="#任务代码-1" class="headerlink" title="任务代码"></a>任务代码</h3><p><code>StudentDaoImpl.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.educoder.springtest;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><span class="hljs-comment">// 请在此处编写代码</span><br><span class="hljs-comment">/********* Begin *********/</span><br><span class="hljs-meta">@Repository(&quot;studentDao&quot;)</span><br><span class="hljs-comment">/********* End *********/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StudentDao</span>&#123;<br>    <span class="hljs-comment">// 重写 showTables 方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showTables</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行Dao层的showTables()方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>StudentServiceImpl.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.educoder.springtest;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><span class="hljs-comment">// 请在此处编写代码</span><br><span class="hljs-comment">/********* Begin *********/</span><br><span class="hljs-meta">@Service(&quot;studentService&quot;)</span><br><span class="hljs-comment">/********* End *********/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StudentService</span> &#123;<br>    <span class="hljs-comment">// 请在此处编写代码</span><br>    <span class="hljs-comment">/********* Begin *********/</span><br>    <span class="hljs-meta">@Resource(name = &quot;studentDao&quot;)</span><br>    <span class="hljs-comment">/********* End *********/</span><br><br>    <span class="hljs-keyword">private</span> StudentDao studentDao;<br>    <span class="hljs-keyword">public</span> StudentDao <span class="hljs-title function_">getStudentDao</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> studentDao;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStudentDao</span><span class="hljs-params">(StudentDao studentDao)</span>&#123;<br>        <span class="hljs-built_in">this</span>.studentDao=studentDao;<br>    &#125;<br>    <span class="hljs-comment">// 重写 toTime 方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">toTime</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 调用 studentDao 中的 showTables() 方法</span><br>        studentDao.showTables();<br>        System.out.println(<span class="hljs-string">&quot;执行Service层的toTime()方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>StudentAction.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.educoder.springtest;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><span class="hljs-comment">// 请在此处编写代码</span><br><span class="hljs-comment">/********* Begin *********/</span><br><span class="hljs-meta">@Controller(&quot;studentAction&quot;)</span><br><span class="hljs-comment">/********* End *********/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentAction</span> &#123;<br>    <span class="hljs-comment">// 请在此处编写代码</span><br>    <span class="hljs-comment">/********* Begin *********/</span><br>    <span class="hljs-meta">@Resource(name = &quot;studentService&quot;)</span><br>    <span class="hljs-comment">/********* End *********/</span><br><br>    <span class="hljs-keyword">private</span> StudentService studentService;<br>    <span class="hljs-keyword">public</span> StudentService <span class="hljs-title function_">getStudentService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> studentService;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStudentService</span><span class="hljs-params">(StudentService studentService )</span>&#123;<br>        <span class="hljs-built_in">this</span>.studentService=studentService;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 调用 personService 中的 toTime() 方法</span><br>        studentService.toTime();<br>        System.out.println(<span class="hljs-string">&quot;执行Action层的show()方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-自动装配-Bean"><a href="#3-自动装配-Bean" class="headerlink" title="3.自动装配 Bean"></a>3.自动装配 Bean</h2><p>自动装配就是指 Spring 容器可以自动装配相互协作的 Bean 之间的关联关系，将一个 Bean 注入其他 Bean 的 Property 中。</p><p><strong>Bean 元素的 autowire 属性</strong></p><p>如果要使用自动装配，需要配置 Bean 元素的 autowire 属性。</p><table><thead><tr><th align="center">名称</th><th>说明</th></tr></thead><tbody><tr><td align="center">byName</td><td>根据 Property 的 name 自动装配，如果一个 Bean 的 name 和另一个 Bean 中的 Property 的 name 相同，则自动装配这个 Bean 到 Property 中。当一个 Bean 节点带有 autowire 的属性时，将查找其类中所有的 set 方法名，获得将 set 去掉并且首字母小写的字符串，然后去 spring 容器中寻找是否有此字符串名称 id 的对象。如果有，就取出注入；如果没有，就报空指针异常。</td></tr><tr><td align="center">byType</td><td>根据 Property 的数据类型（Type）自动装配，如果一个 Bean 的数据类型兼容另一个 Bean 中 Property 的数据类型，则自动装配。</td></tr><tr><td align="center">constructor</td><td>根据构造方法的参数的数据类型，进行 byType 模式的自动装配。</td></tr><tr><td align="center">autodetect</td><td>如果发现默认的构造方法，则用 constructor 模式，否则用 byType 模式。</td></tr><tr><td align="center">no</td><td>默认情况下，不使用自动装配，Bean 依赖必须通过 ref 元素定义。</td></tr></tbody></table><h3 id="任务代码-2"><a href="#任务代码-2" class="headerlink" title="任务代码"></a>任务代码</h3><p>先把在第2关<code>StudentDaoImpl.java</code>、<code>StudentServiceImpl.java</code>、<code>StudentAction.java</code>中的添加的注解去掉或者注释。</p><p><code>applicationContext.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/aop</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/aop/spring-aop-2.5.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/tx</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/tx/spring-tx-2.5.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 请在此处编写代码 --&gt;</span><br>    <span class="hljs-comment">&lt;!--********* Begin *********--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.educoder.springtest.StudentDaoImpl&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.educoder.springtest.StudentServiceImpl&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentAction&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.educoder.springtest.StudentAction&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--********* End *********--&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>实训地址：<a href="https://www.educoder.net/shixuns/rzfygwhv/challenges">头歌编程</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>SSM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSM框架-Spring 面向切面编程</title>
    <link href="/2021/09/09/Spring%20%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%20copy/"/>
    <url>/2021/09/09/Spring%20%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%20copy/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-面向切面编程"><a href="#Spring-面向切面编程" class="headerlink" title="Spring 面向切面编程"></a>Spring 面向切面编程</h1><p><code>OOP</code>允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（<code>cross-cutting</code>）代码，在<code>OOP</code>设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p><p><code>AOP</code>（面向切面编程）技术则恰好解决了这些不足，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为 “<code>Aspect</code>”，即切面。所谓“切面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</p><h2 id="1-使用前后置通知统计所有方法的执行时间"><a href="#1-使用前后置通知统计所有方法的执行时间" class="headerlink" title="1.使用前后置通知统计所有方法的执行时间"></a>1.<strong>使用前后置通知统计所有方法的执行时间</strong></h2><p><strong>AOP基本概念</strong></p><ul><li><p><code>Aspect</code>（切面）： 切面由切点 (<code>Pointcut</code>) 和增强&#x2F;通知 (Advice) 组成，它既包括了横切逻辑的定义、也包括了连接点的定义；</p></li><li><p><code>Joint point</code>（连接点）：能够被拦截的地方：<code>Spring AOP</code> 是基于动态代理的，所以是方法拦截的。每个成员方法都可以称之为连接点；</p></li><li><p><code>Pointcut</code>（切点）：具体定位的连接点，上面也说了，每个方法都可以称之为连接点，我们具体定位到某一个方法就成为切点；</p></li><li><p><code>Advice</code>（通知&#x2F;增强）：表示添加到切点的一段逻辑代码，并定位连接点的方位信息。简单来说就定义了是干什么的，具体是在哪干；</p></li><li><p><code>Spring AOP</code>提供了5种 <code>Advice</code>类型给我们，分别是：前置（<code>Before</code>）、后置（<code>After</code>）、返回（<code>AfterReturning</code>）、异常（<code>AfterThrowing</code>）、环绕（<code>Around</code>）；</p></li><li><p><code>Target</code>（目标对象）：织入<code>Advice</code>的目标对象；</p></li><li><p><code>Weaving</code>（织入）：将增强&#x2F;通知添加到目标类的具体连接点上的过程。</p></li></ul><p><strong>切点完整表达式</strong></p><p><code>execution（modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern（param-pattern）throws-pattern?）</code></p><table><thead><tr><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>modifiers-pattern</td><td>修饰符 可选 public private protected</td></tr><tr><td>declaring-type-pattern</td><td>方法的声明类型</td></tr><tr><td>name-patterm</td><td>方法名称类型，例 set* 则表示以set开头的所有的方法名称</td></tr><tr><td>param-pattern</td><td>参数匹配：(..) 表示任意多个参数，每个参数任意多个类型，(*,String) 表示两个参数，第一个是任意类型，第二个是String</td></tr><tr><td>throws-pattern</td><td>异常的匹配模式</td></tr><tr><td>ret-type-pattern</td><td>返回类型 必选 * 代表任意类型</td></tr></tbody></table><p><strong>五种通知</strong></p><p>前置通知：在连接点前面执行，前置通知不会影响连接点的执行；</p><p>后置通知：在连接点执行完成后执行，不管是正常执行完成，还是抛出异常，都会执行返回通知中的内容；</p><p>异常返回通知：在连接点抛出异常后执行；</p><p>正常返回通知：在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行；</p><p>环绕通知：最为强大的通知，它能够让你编写的逻辑将被通知的目标方法完全包裹起来。实际上就像在一个通知方法中同时编写前置通知和后置通知。定义通知的时候在通知方法中添加了入参<code>ProceedingJoinPoint</code>，这个参数是必须写的。因为需要在通知中使用<code>ProceedingJoinPoint.proceed()</code>调用目标方法。</p><h3 id="任务代码"><a href="#任务代码" class="headerlink" title="任务代码"></a>任务代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Educoder;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.*;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.text.ParseException;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><br><span class="hljs-meta">@Component(&quot;BlogAdvice&quot;)</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogAdvice</span> &#123;<br>    <span class="hljs-comment">//定义切点</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* Educoder.BlogService.service*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">My</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><span class="hljs-comment">//定义前置通知，输出当前时间2019.1.1 00:00:00</span><br> <span class="hljs-comment">/**********   Begin   **********/</span><br>    <span class="hljs-meta">@Before(&quot;execution(* Educoder.BlogService.service*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;当前时间2019.1.1 00:00:00&quot;</span>);<br>    &#125;<br> <span class="hljs-comment">/**********   End   **********/</span><br>    <span class="hljs-comment">//定义后置通知，输出当前时间2019.1.1 00:01:00，执行耗时60000</span><br> <span class="hljs-comment">/**********   Begin   **********/</span><br>     <span class="hljs-meta">@After(&quot;execution(* Educoder.BlogService.service*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">After</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;当前时间2019.1.1 00:01:00，执行耗时60000&quot;</span>);<br>    &#125;<br> <span class="hljs-comment">/**********   End   **********/</span> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-使用环绕通知统计所有带参方法的执行时间"><a href="#2-使用环绕通知统计所有带参方法的执行时间" class="headerlink" title="2.使用环绕通知统计所有带参方法的执行时间"></a>2.使用环绕通知统计所有带参方法的执行时间</h2><p><strong>环绕通知和前后通知的区别</strong></p><ul><li><p>目标方法的调用由环绕通知决定，即你可以决定是否调用目标方法，而前置和后置通知是不能决定的，他们只是在方法的调用前后执行通知而已，即目标方法肯定是要执行的；</p></li><li><p>环绕通知可以控制返回对象，即你可以返回一个与目标对象完全不同的返回值，虽然这很危险，但是你却可以办到。而后置方法是无法办到的，因为他是在目标方法返回值后调用。</p></li></ul><h3 id="任务代码-1"><a href="#任务代码-1" class="headerlink" title="任务代码"></a>任务代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Educoder;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.*;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.text.ParseException;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><br><span class="hljs-meta">@Component(&quot;BlogAdvice&quot;)</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogAdvice</span> &#123;<br>    <span class="hljs-comment">//定义切点</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* Educoder.BlogService.service*(String))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">My</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br><br><span class="hljs-comment">//定义环绕通知，实现统计目标类所有带参方法运行时长</span><br>    <span class="hljs-meta">@Around(&quot;My()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint point)</span> <span class="hljs-keyword">throws</span> ParseException, InterruptedException &#123;<br>        <span class="hljs-comment">/**********   Begin   **********/</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            point.proceed();  <br>            &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            throwable.printStackTrace();<br>        &#125;<br>        System.out.print(<span class="hljs-string">&quot;程序a执行耗时60000&quot;</span>);<br><span class="hljs-comment">/**********   End   **********/</span><br><br>    &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>第二关有点问题，我看评论区，大家都不知道怎么让<code>Pointcut</code>只锁定输出业务管理一的，网上也没找到答案，所以要在命令行里面打开<code>BlogService</code>类把业务功能2的输出语句注释掉。</p><p><img src="https://cdn.jsdelivr.net/gh/Manchesterss/picx-image@main/2020/%E6%8D%95%E8%8E%B7.4jnly8mkv8u0.PNG"></p><h2 id="3-AOP实现原理-JDK动态代理"><a href="#3-AOP实现原理-JDK动态代理" class="headerlink" title="3.AOP实现原理-JDK动态代理"></a>3.AOP实现原理-JDK动态代理</h2><p><strong>代理模式(Proxy)</strong></p><p>代理模式就是给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用，在不改变目标对象方法的情况下对方法进行增强。</p><p><strong>AOP实现的两种方式</strong></p><p>切面类中的方法会根据相应的策略对目标对象进行增强，<code>Spring AOP</code>使用<code>JDK</code>动态代理或<code>CGLIB</code>为给定目标对象创建代理。如果要代理的目标对象实现了至少一个接口，则<code>AOP</code>默认使用<code>JDK</code>动态代理，否则使用<code>CGLIB</code>代理。</p><p><strong>JDK动态代理步骤</strong></p><p><code>Proxy.newInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code></p><ul><li>第一个参数<code>ClassLoader loader</code>：类加载器，一般写当前类;</li><li>第二个参数<code>Class&lt;?&gt;[] interfaces</code>：代理类所需要实现的接口;</li><li>第三个参数<code>InvocationHandler h</code>：处理类，一般写匿名类。</li></ul><p><strong>步骤</strong></p><ul><li>定义一个<code>java.lang.reflect.InvocationHandler</code>接口的实现类，重写<code>invoke</code>方法;</li><li>将<code>InvocationHandler</code>对象作为参数传入<code>java.lang.reflect.Proxy</code>的<code>newProxyInstance</code>方法中；</li><li>通过调用<code>java.lang.reflect.Proxy</code>的<code>newProxyInstance</code>方法获得动态代理对象；</li><li>通过代理对象调用目标方法。</li></ul><h3 id="任务代码-2"><a href="#任务代码-2" class="headerlink" title="任务代码"></a>任务代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> educoder;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProxy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  UserService <span class="hljs-title function_">createUserService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//请在以下提示框内填写你的代码</span><br>        <span class="hljs-comment">/**********Begin**********/</span><br>        <span class="hljs-comment">//目标类</span><br>        <span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">userserviceImpl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>        <span class="hljs-comment">//切面类</span><br>        <span class="hljs-type">Authority</span> <span class="hljs-variable">authority</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Authority</span>();<br>        <span class="hljs-comment">//代理类：将目标类与切面类结合</span><br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">proxyUserService</span> <span class="hljs-operator">=</span> (UserService) Proxy.newProxyInstance(MyProxy.class.getClassLoader(), userserviceImpl.getClass().getInterfaces(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                <span class="hljs-comment">//目标方法执行前</span><br>                authority.before();<br>                <span class="hljs-comment">//放行目标方法</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> method.invoke(userserviceImpl, args);<br>                <span class="hljs-keyword">return</span> invoke;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//返回代理对象</span><br>        <span class="hljs-keyword">return</span> proxyUserService;<br><br>        <span class="hljs-comment">/**********End**********/</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-AOP实现原理-CgLib动态代理"><a href="#4-AOP实现原理-CgLib动态代理" class="headerlink" title="4.AOP实现原理-CgLib动态代理"></a>4.AOP实现原理-CgLib动态代理</h2><p><code>CGLIB</code>代理模拟<code>AOP</code>实现主要是采用字节码增强框架<code>cglib</code>，在运行时创建目标类的子类，从而对目标类进行增强。</p><p><strong>CGLIB动态代理步骤</strong></p><ul><li>定义一个<code>org.springframework.cglib.proxy.MethodInterceptor</code>接口的实现类，重写<code>intercept</code>方法;</li><li>获取<code>org.springframework.cglib.proxy.Enhancer</code>类的对象;</li><li>分别调用<code>Enhancer</code>对象的<code>setSuperclass</code>和<code>setCallback</code>方法，使用<code>create</code>方法获取代理对象;</li><li>通过代理对象调用目标方法。</li></ul><h3 id="任务代码-3"><a href="#任务代码-3" class="headerlink" title="任务代码"></a>任务代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> educoder;<br><span class="hljs-keyword">import</span> org.springframework.cglib.proxy.Enhancer;<br><span class="hljs-keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.cglib.proxy.MethodProxy;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProxy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  UserServiceImpl <span class="hljs-title function_">createUserService</span><span class="hljs-params">()</span>&#123;<br> <span class="hljs-comment">//请在以下提示框内填写你的代码</span><br> <span class="hljs-comment">/**********Begin**********/</span><br>        <span class="hljs-comment">//目标类</span><br>        UserServiceImpl user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>        <span class="hljs-comment">//切面类</span><br>Authority authority=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Authority</span>();<br>        <span class="hljs-comment">//cglib核心类</span><br>Enhancer enhancer=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        enhancer.setSuperclass(user.getClass());<br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodInterceptor</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>             <span class="hljs-comment">//目标方法执行前</span><br>             authority.before();                <br>             <span class="hljs-comment">//放行目标方法</span><br>             <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> methodProxy.invokeSuper(o,objects);<br>             <span class="hljs-keyword">return</span>  invoke;<br>             &#125;<br>     &#125;);<br><span class="hljs-comment">//获取代理对象</span><br><span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (UserServiceImpl) enhancer.create();<br><span class="hljs-comment">//返回代理对象</span><br><span class="hljs-keyword">return</span> proxy;<br>    <span class="hljs-comment">/**********End**********/</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实训地址：<a href="https://www.educoder.net/shixuns/xrmyf479/challenges">头歌编程</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>学习笔记，SSM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSM框架-Spring 面向切面编程</title>
    <link href="/2021/09/09/Spring%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/09/09/Spring%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-面向切面编程"><a href="#Spring-面向切面编程" class="headerlink" title="Spring 面向切面编程"></a>Spring 面向切面编程</h1><p><code>OOP</code>允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（<code>cross-cutting</code>）代码，在<code>OOP</code>设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p><p><code>AOP</code>（面向切面编程）技术则恰好解决了这些不足，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为 “<code>Aspect</code>”，即切面。所谓“切面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</p><h2 id="1-使用前后置通知统计所有方法的执行时间"><a href="#1-使用前后置通知统计所有方法的执行时间" class="headerlink" title="1.使用前后置通知统计所有方法的执行时间"></a>1.<strong>使用前后置通知统计所有方法的执行时间</strong></h2><p><strong>AOP基本概念</strong></p><ul><li><p><code>Aspect</code>（切面）： 切面由切点 (<code>Pointcut</code>) 和增强&#x2F;通知 (Advice) 组成，它既包括了横切逻辑的定义、也包括了连接点的定义；</p></li><li><p><code>Joint point</code>（连接点）：能够被拦截的地方：<code>Spring AOP</code> 是基于动态代理的，所以是方法拦截的。每个成员方法都可以称之为连接点；</p></li><li><p><code>Pointcut</code>（切点）：具体定位的连接点，上面也说了，每个方法都可以称之为连接点，我们具体定位到某一个方法就成为切点；</p></li><li><p><code>Advice</code>（通知&#x2F;增强）：表示添加到切点的一段逻辑代码，并定位连接点的方位信息。简单来说就定义了是干什么的，具体是在哪干；</p></li><li><p><code>Spring AOP</code>提供了5种 <code>Advice</code>类型给我们，分别是：前置（<code>Before</code>）、后置（<code>After</code>）、返回（<code>AfterReturning</code>）、异常（<code>AfterThrowing</code>）、环绕（<code>Around</code>）；</p></li><li><p><code>Target</code>（目标对象）：织入<code>Advice</code>的目标对象；</p></li><li><p><code>Weaving</code>（织入）：将增强&#x2F;通知添加到目标类的具体连接点上的过程。</p></li></ul><p><strong>切点完整表达式</strong></p><p><code>execution（modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern（param-pattern）throws-pattern?）</code></p><table><thead><tr><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>modifiers-pattern</td><td>修饰符 可选 public private protected</td></tr><tr><td>declaring-type-pattern</td><td>方法的声明类型</td></tr><tr><td>name-patterm</td><td>方法名称类型，例 set* 则表示以set开头的所有的方法名称</td></tr><tr><td>param-pattern</td><td>参数匹配：(..) 表示任意多个参数，每个参数任意多个类型，(*,String) 表示两个参数，第一个是任意类型，第二个是String</td></tr><tr><td>throws-pattern</td><td>异常的匹配模式</td></tr><tr><td>ret-type-pattern</td><td>返回类型 必选 * 代表任意类型</td></tr></tbody></table><p><strong>五种通知</strong></p><p>前置通知：在连接点前面执行，前置通知不会影响连接点的执行；</p><p>后置通知：在连接点执行完成后执行，不管是正常执行完成，还是抛出异常，都会执行返回通知中的内容；</p><p>异常返回通知：在连接点抛出异常后执行；</p><p>正常返回通知：在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行；</p><p>环绕通知：最为强大的通知，它能够让你编写的逻辑将被通知的目标方法完全包裹起来。实际上就像在一个通知方法中同时编写前置通知和后置通知。定义通知的时候在通知方法中添加了入参<code>ProceedingJoinPoint</code>，这个参数是必须写的。因为需要在通知中使用<code>ProceedingJoinPoint.proceed()</code>调用目标方法。</p><h3 id="任务代码"><a href="#任务代码" class="headerlink" title="任务代码"></a>任务代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Educoder;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.*;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.text.ParseException;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><br><span class="hljs-meta">@Component(&quot;BlogAdvice&quot;)</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogAdvice</span> &#123;<br>    <span class="hljs-comment">//定义切点</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* Educoder.BlogService.service*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">My</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><span class="hljs-comment">//定义前置通知，输出当前时间2019.1.1 00:00:00</span><br> <span class="hljs-comment">/**********   Begin   **********/</span><br>    <span class="hljs-meta">@Before(&quot;execution(* Educoder.BlogService.service*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;当前时间2019.1.1 00:00:00&quot;</span>);<br>    &#125;<br> <span class="hljs-comment">/**********   End   **********/</span><br>    <span class="hljs-comment">//定义后置通知，输出当前时间2019.1.1 00:01:00，执行耗时60000</span><br> <span class="hljs-comment">/**********   Begin   **********/</span><br>     <span class="hljs-meta">@After(&quot;execution(* Educoder.BlogService.service*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">After</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;当前时间2019.1.1 00:01:00，执行耗时60000&quot;</span>);<br>    &#125;<br> <span class="hljs-comment">/**********   End   **********/</span> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-使用环绕通知统计所有带参方法的执行时间"><a href="#2-使用环绕通知统计所有带参方法的执行时间" class="headerlink" title="2.使用环绕通知统计所有带参方法的执行时间"></a>2.使用环绕通知统计所有带参方法的执行时间</h2><p><strong>环绕通知和前后通知的区别</strong></p><ul><li><p>目标方法的调用由环绕通知决定，即你可以决定是否调用目标方法，而前置和后置通知是不能决定的，他们只是在方法的调用前后执行通知而已，即目标方法肯定是要执行的；</p></li><li><p>环绕通知可以控制返回对象，即你可以返回一个与目标对象完全不同的返回值，虽然这很危险，但是你却可以办到。而后置方法是无法办到的，因为他是在目标方法返回值后调用。</p></li></ul><h3 id="任务代码-1"><a href="#任务代码-1" class="headerlink" title="任务代码"></a>任务代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Educoder;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.*;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.text.ParseException;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><br><span class="hljs-meta">@Component(&quot;BlogAdvice&quot;)</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogAdvice</span> &#123;<br>    <span class="hljs-comment">//定义切点</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* Educoder.BlogService.service*(String))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">My</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br><br><span class="hljs-comment">//定义环绕通知，实现统计目标类所有带参方法运行时长</span><br>    <span class="hljs-meta">@Around(&quot;My()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint point)</span> <span class="hljs-keyword">throws</span> ParseException, InterruptedException &#123;<br>        <span class="hljs-comment">/**********   Begin   **********/</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            point.proceed();  <br>            &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            throwable.printStackTrace();<br>        &#125;<br>        System.out.print(<span class="hljs-string">&quot;程序a执行耗时60000&quot;</span>);<br><span class="hljs-comment">/**********   End   **********/</span><br><br>    &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>第二关有点问题，我看评论区，大家都不知道怎么让<code>Pointcut</code>只锁定输出业务管理一的，网上也没找到答案，所以要在命令行里面打开<code>BlogService</code>类把业务功能2的输出语句注释掉。</p><p><img src="https://cdn.jsdelivr.net/gh/Manchesterss/picx-image@main/2020/%E6%8D%95%E8%8E%B7.4jnly8mkv8u0.PNG"></p><h2 id="3-AOP实现原理-JDK动态代理"><a href="#3-AOP实现原理-JDK动态代理" class="headerlink" title="3.AOP实现原理-JDK动态代理"></a>3.AOP实现原理-JDK动态代理</h2><p><strong>代理模式(Proxy)</strong></p><p>代理模式就是给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用，在不改变目标对象方法的情况下对方法进行增强。</p><p><strong>AOP实现的两种方式</strong></p><p>切面类中的方法会根据相应的策略对目标对象进行增强，<code>Spring AOP</code>使用<code>JDK</code>动态代理或<code>CGLIB</code>为给定目标对象创建代理。如果要代理的目标对象实现了至少一个接口，则<code>AOP</code>默认使用<code>JDK</code>动态代理，否则使用<code>CGLIB</code>代理。</p><p><strong>JDK动态代理步骤</strong></p><p><code>Proxy.newInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code></p><ul><li>第一个参数<code>ClassLoader loader</code>：类加载器，一般写当前类;</li><li>第二个参数<code>Class&lt;?&gt;[] interfaces</code>：代理类所需要实现的接口;</li><li>第三个参数<code>InvocationHandler h</code>：处理类，一般写匿名类。</li></ul><p><strong>步骤</strong></p><ul><li>定义一个<code>java.lang.reflect.InvocationHandler</code>接口的实现类，重写<code>invoke</code>方法;</li><li>将<code>InvocationHandler</code>对象作为参数传入<code>java.lang.reflect.Proxy</code>的<code>newProxyInstance</code>方法中；</li><li>通过调用<code>java.lang.reflect.Proxy</code>的<code>newProxyInstance</code>方法获得动态代理对象；</li><li>通过代理对象调用目标方法。</li></ul><h3 id="任务代码-2"><a href="#任务代码-2" class="headerlink" title="任务代码"></a>任务代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> educoder;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProxy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  UserService <span class="hljs-title function_">createUserService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//请在以下提示框内填写你的代码</span><br>        <span class="hljs-comment">/**********Begin**********/</span><br>        <span class="hljs-comment">//目标类</span><br>        <span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">userserviceImpl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>        <span class="hljs-comment">//切面类</span><br>        <span class="hljs-type">Authority</span> <span class="hljs-variable">authority</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Authority</span>();<br>        <span class="hljs-comment">//代理类：将目标类与切面类结合</span><br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">proxyUserService</span> <span class="hljs-operator">=</span> (UserService) Proxy.newProxyInstance(MyProxy.class.getClassLoader(), userserviceImpl.getClass().getInterfaces(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                <span class="hljs-comment">//目标方法执行前</span><br>                authority.before();<br>                <span class="hljs-comment">//放行目标方法</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> method.invoke(userserviceImpl, args);<br>                <span class="hljs-keyword">return</span> invoke;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//返回代理对象</span><br>        <span class="hljs-keyword">return</span> proxyUserService;<br><br>        <span class="hljs-comment">/**********End**********/</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-AOP实现原理-CgLib动态代理"><a href="#4-AOP实现原理-CgLib动态代理" class="headerlink" title="4.AOP实现原理-CgLib动态代理"></a>4.AOP实现原理-CgLib动态代理</h2><p><code>CGLIB</code>代理模拟<code>AOP</code>实现主要是采用字节码增强框架<code>cglib</code>，在运行时创建目标类的子类，从而对目标类进行增强。</p><p><strong>CGLIB动态代理步骤</strong></p><ul><li>定义一个<code>org.springframework.cglib.proxy.MethodInterceptor</code>接口的实现类，重写<code>intercept</code>方法;</li><li>获取<code>org.springframework.cglib.proxy.Enhancer</code>类的对象;</li><li>分别调用<code>Enhancer</code>对象的<code>setSuperclass</code>和<code>setCallback</code>方法，使用<code>create</code>方法获取代理对象;</li><li>通过代理对象调用目标方法。</li></ul><h3 id="任务代码-3"><a href="#任务代码-3" class="headerlink" title="任务代码"></a>任务代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> educoder;<br><span class="hljs-keyword">import</span> org.springframework.cglib.proxy.Enhancer;<br><span class="hljs-keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.cglib.proxy.MethodProxy;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProxy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  UserServiceImpl <span class="hljs-title function_">createUserService</span><span class="hljs-params">()</span>&#123;<br> <span class="hljs-comment">//请在以下提示框内填写你的代码</span><br> <span class="hljs-comment">/**********Begin**********/</span><br>        <span class="hljs-comment">//目标类</span><br>        UserServiceImpl user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>        <span class="hljs-comment">//切面类</span><br>Authority authority=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Authority</span>();<br>        <span class="hljs-comment">//cglib核心类</span><br>Enhancer enhancer=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        enhancer.setSuperclass(user.getClass());<br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodInterceptor</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>             <span class="hljs-comment">//目标方法执行前</span><br>             authority.before();                <br>             <span class="hljs-comment">//放行目标方法</span><br>             <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> methodProxy.invokeSuper(o,objects);<br>             <span class="hljs-keyword">return</span>  invoke;<br>             &#125;<br>     &#125;);<br><span class="hljs-comment">//获取代理对象</span><br><span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (UserServiceImpl) enhancer.create();<br><span class="hljs-comment">//返回代理对象</span><br><span class="hljs-keyword">return</span> proxy;<br>    <span class="hljs-comment">/**********End**********/</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实训地址：<a href="https://www.educoder.net/shixuns/xrmyf479/challenges">头歌编程</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>SSM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python练习笔记</title>
    <link href="/2021/09/07/Python%E7%BB%83%E4%B9%A0/"/>
    <url>/2021/09/07/Python%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Python练习笔记"><a href="#Python练习笔记" class="headerlink" title="Python练习笔记"></a>Python练习笔记</h1><p>最近在学习&#x3D;&#x3D;Python&#x3D;&#x3D;，所幸将练习记录一下:)</p><h2 id="1-完美数"><a href="#1-完美数" class="headerlink" title="1.完美数"></a>1.完美数</h2><p>对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。</p><p>给定一个 整数 <code>n</code>， 如果是完美数，返回 <code>true</code>，否则返回 <code>false</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkPerfectNumber</span>(<span class="hljs-params">self, num</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type num: int </span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        s=<span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,num/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> num%i==<span class="hljs-number">0</span>:<br>                s+=i;<br>        <span class="hljs-keyword">if</span> s==num <span class="hljs-keyword">and</span> s!=<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>这是我的答案，但是并没有通过，超出时间限制了。。。<br><img src="https://cdn.jsdelivr.net/gh/Manchesterss/picx-image@main/2020/%E5%B9%BB%E6%83%B3%E9%80%8D%E9%81%A5%E4%BE%A0_20210907_191550.7eshnl3j6gc0.gif"></p><p>看了题解发现问题出现在</p><ol><li>如果<code>num</code> 过大的话，每次从1开始循环，等待时间太久</li><li><code>Math.sqrt</code>,我们需要计算 num 除了它自身以外的所有正因子之和 sum，正因子必然是成对出现的，故而我们只需要遍历到 num 的平方根 sqrt 即可</li></ol><p>以<code>36</code> 为例，它的非自身外正因子有1、2、3、4、6、9、12、18，其中 1 和 6 单独计算，[2, 18]、[3, 12]、[4, 9]都是对应关系、<br>所以只需要遍历到 36 的平方根 6 就可以获取全部正因子,1单独计算的原因是要排除自身,6单独计算的原因是 6 * 6 &#x3D; 36，两个值相同，故而只能计算一遍.<a href="https://leetcode-cn.com/problems/perfect-number/solution/hua-jie-suan-fa-507-wan-mei-shu-by-guanpengchn/">题解</a></p><p><strong>新的答案！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkPerfectNumber</span>(<span class="hljs-params">self, num</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type num: int </span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        s=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-built_in">int</span>(math.sqrt(num))+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> num%i==<span class="hljs-number">0</span>:<br>                s+=i<br>                s+=num/i<br>            <span class="hljs-keyword">if</span> i*i==num:<br>                s-=i     <br>        <span class="hljs-keyword">if</span> s==num <span class="hljs-keyword">and</span> s!=<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>时间复杂度 O(n**0.5),n 为 num 的大小<br><img src="https://cdn.jsdelivr.net/gh/Manchesterss/picx-image@main/2020/%E5%B9%BB%E6%83%B3%E9%80%8D%E9%81%A5%E4%BE%A0_20210907_192000.5m9iztax4b40.gif"></p><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2><blockquote><p>题目<code>1</code>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/perfect-number">https://leetcode-cn.com/problems/perfect-number</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>leetcode编程练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSM框架-Spring 获取对象原理</title>
    <link href="/2021/09/05/SSM%E6%A1%86%E6%9E%B6%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    <url>/2021/09/05/SSM%E6%A1%86%E6%9E%B6%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-获取对象原理"><a href="#Spring-获取对象原理" class="headerlink" title="Spring 获取对象原理"></a>Spring 获取对象原理</h1><h2 id="1-Dom4j的基本使用"><a href="#1-Dom4j的基本使用" class="headerlink" title="1.Dom4j的基本使用"></a>1.Dom4j的基本使用</h2><p>Dom4j是一个易于使用的开源库，用于<code>Java</code>平台,采用了<code>Java</code>集合框架并完全支持 DOM , SAX , JAXP </p><p>  注意：使用Dom4j前我们需要先去官网下载Dom4j包，<a href="https://dom4j.github.io/">下载地址</a>。</p><p>  Dom4j中，获得<code>Document</code>对象的方式有三种：</p><ol><li>读取<code>XML</code>文件，获得<code>document</code>对象；(常用)</li><li>解析<code>XML</code>形式的文本，得到<code>document</code>对象；</li><li>主动创建<code>document</code>对象。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Info.xml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">students</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">student</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Mary&quot;</span>&gt;</span>大家好,我是Mary<span class="hljs-tag">&lt;/<span class="hljs-name">student</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">students</span>&gt;</span><br></code></pre></td></tr></table></figure><code>SAX</code>是一种<code>XML</code>解析的替代方法。相比于<code>DOM</code>，<code>SAX</code>是一种速度更快，更有效的方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SAXReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br><span class="hljs-comment">//解析文档这里需要抛出DocumentException异常。</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Document</span>   <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> reader.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Info.xml&quot;</span>));<br>&#125; <span class="hljs-keyword">catch</span> (DocumentException e) &#123;<br>    e.printStackT\frace();<br>&#125;<br></code></pre></td></tr></table></figure><strong>节点对象的操作</strong></li></ol><p>当我们取得Document对象后，我们就可以获取它的每一个节点了。</p><ol><li><p>获取文档的<strong>根节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//读取后的第二步，就是得到 Root节点。一切XML分析都是从Root元素开始的</span><br><span class="hljs-type">Element</span> <span class="hljs-variable">rootElm</span> <span class="hljs-operator">=</span> document.getRootElement();<br></code></pre></td></tr></table></figure></li><li><p>获取某节点的<strong>单个子节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Element elm=rootElm.element(<span class="hljs-string">&quot;student&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>获取某节点的<strong>所有子节点元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Element&gt; elms=rootElm.elements(<span class="hljs-string">&quot;student&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>获取某节点的<strong>内容</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取节点内容有两种方式：</span><br><span class="hljs-comment">//通过元素获取</span><br>String text=document.getRootElement().element(<span class="hljs-string">&quot;student&quot;</span>).getText();<br><span class="hljs-comment">//通过根节点直接获取元素内容</span><br>String elementText=document.getRootElement().elementText(<span class="hljs-string">&quot;student&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上两种方式输出结果均为：<code>大家好,我是Mary</code></p></li></ol><p><strong>节点对象的属性方法操作</strong></p><ol><li>取得某节点下的某属性<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Element</span> <span class="hljs-variable">rootElement</span> <span class="hljs-operator">=</span> saxRead.getRootElement().element(<span class="hljs-string">&quot;student&quot;</span>);<br><span class="hljs-type">Attribute</span> <span class="hljs-variable">attribute</span> <span class="hljs-operator">=</span> rootElement.attribute(<span class="hljs-string">&quot;name&quot;</span>);<br></code></pre></td></tr></table></figure></li><li>取得某节点属性的内容<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取节点属性内容也有两种方式：</span><br><span class="hljs-type">Element</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> document.getRootElement().element(<span class="hljs-string">&quot;student&quot;</span>);<br><span class="hljs-comment">//通过节点属性获取内容</span><br><span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> element.attribute(<span class="hljs-string">&quot;name&quot;</span>).getText();<br><span class="hljs-comment">//通过元素获取内容</span><br><span class="hljs-type">String</span> <span class="hljs-variable">attributeValue</span> <span class="hljs-operator">=</span> element.attributeValue(<span class="hljs-string">&quot;name&quot;</span>);<br></code></pre></td></tr></table></figure>以上两种方式输出结果均为：<code>Mary</code></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot学习笔记</title>
    <link href="/2021/09/03/Springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/09/03/Springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot学习笔记"><a href="#Spring-Boot学习笔记" class="headerlink" title="Spring Boot学习笔记"></a>Spring Boot学习笔记</h1><p><strong>Spring的体系结构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Manchesterss/picx-image@main/2020/image-20210318193325775.3i71ofs9s100.png" alt="image-20210318193325775"></p><h2 id="Spring基础"><a href="#Spring基础" class="headerlink" title="Spring基础"></a>Spring基础</h2><p><strong>Spring开发环境搭建</strong></p><pre><code class=" mermaid">graph LRA[SpringBoot]--IDE--&gt;B[Eclipse]B--&gt;C[JDK]B--&gt;D[Web服务器]C--&gt;CA[配置环境变量]D--&gt;DA[Tomcat]DA--&gt;BDAB--&gt;BDA[集成Tomcat]S[Spring的JAR包]COM[commons.logging的JAR包]</code></pre><p><strong>版本：</strong></p><ul><li>JDk:jdk-16_windows-x64_bin :arrow_right:jdk-15.0.2</li><li>Eclipse:Eclipse-2021-03#</li><li>Tomcat:apache-tomcat-9.0.44</li><li>Spring:spring-framework-5.1.4.RELEASE-dist.zip</li><li>commons.logging:commons-logging-1.2-bin.zip</li></ul><p><strong>第一个Spring入门程序</strong></p><blockquote><p>Spring解决的是业务逻辑层和其他各层的耦合问题，面向接口的编程思想</p></blockquote><pre><code class=" mermaid">graph LRTestDao[接口]--&gt;TestDaoImpl[接口的实现类]--&gt;applicationContext[配置文件]--&gt;test[测试类]</code></pre><h3 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h3><p>Spring的核心容器是其他模块建立的基础</p><p><strong>Spring-core模块</strong></p><p><strong>Spring IoC<code>控制反转</code></strong> :<strong>Inversion of Control</strong>：用来消减计算机程序的耦合问题</p><p>  <strong>BeanFactory</strong></p><pre><code class="hljs">  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建BeanFactory实例时，需要提供XML文件的绝对路径</span><br><span class="hljs-type">BeanFactory</span> <span class="hljs-variable">beanFac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanFactory</span>(<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSystemResource</span>(<span class="hljs-string">&quot;D:\\eclipse-workspace\\ch1\\src\\applicationContext.xml&quot;</span>)<br>);<br><span class="hljs-comment">//通过容器获取test实例</span><br><span class="hljs-type">TestDao</span> <span class="hljs-variable">tt</span> <span class="hljs-operator">=</span> (TestDao)beanFac.getBean(<span class="hljs-string">&quot;test&quot;</span>);<br>tt.sayHello();<br></code></pre></td></tr></table></figure></code></pre><p> <strong>ApplicationContext</strong></p><p>创建ApplicationContext接口实例通常有三种方法：</p><ol><li><p>ClassPathXmlApplicationContext</p><pre><code class="hljs"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从类路径classPath目录（src根目录）寻找指定的XML配置文件</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">appCon</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br></code></pre></td></tr></table></figure></code></pre></li><li><p>FileSystemXmlApplicationContext</p><pre><code class="hljs"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从指定文件的绝对路径中寻找XML配置文件</span><br><span class="hljs-comment">//找到并装载完成ApplicationContext的实例化工作</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">appCon</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSystemXmlApplicationContext</span>(<span class="hljs-string">&quot;D:\\eclipse-workspace\\ch1\\src\\applicationContext.xml&quot;</span>);<br></code></pre></td></tr></table></figure></code></pre></li><li><p>Web服务器实例化ApplicationContext容器</p><pre><code class="hljs"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--web.xml&gt;</span><br><span class="hljs-comment">&lt;!--一般使用基于org.springframework.web.context.ContextLoaderListener的实现方式.（需要将spring-web-5.0.2.RELEASE.jar复制到WEB-INF/lib目录中）--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 加载src目录下的applicationContext.xml文件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span><br>  classpath:applicationContext.xml<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 指定以ContextLoaderListener方式启动Spring容器 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span><br>  org.springframework.web.context.ContextLoaderListener<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br></code></pre></td></tr></table></figure></code></pre></li></ol><p> ​<strong>DI<code>依赖注入</code></strong> :<strong>Dependency Injection</strong>：是IoC的另外一种说法，使用Spring框架创建对象时，动态地将其所依赖的对象（如属性值）注入Bean组件中，通常有两种实现方式。</p><p>  构造方法注入：Spring框架可以采用Java的反射机制，通过构造方法完成依赖注入。在配置文件<code>applicationContext.xml</code>中，首先，将<code>dao.TestDIDaoImpl</code>类托管给Spring，让Spring创建其对象。其次，将<code>service.TestDIServiceImpl</code>类托管给Spring，让Spring创建其对象，同时给构造方法传递实参。</p><pre><code class="hljs">  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初始化Spring容器ApplicationContext，加载配置文件</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">appCon</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><span class="hljs-comment">//通过容器获取testDIService实例，测试构造方法注入</span><br><span class="hljs-type">TestDIService</span> <span class="hljs-variable">ts</span> <span class="hljs-operator">=</span> (TestDIService)appCon.getBean(<span class="hljs-string">&quot;testDIService&quot;</span>);<br></code></pre></td></tr></table></figure></code></pre><p> setter方法注入</p><pre><code class="hljs">  1. 创建接口实现类  2. 将接口类托管给Spring，让Spring创建其对象  3. 调用接口类的setter方法完成依赖注入  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml">      <span class="hljs-comment">&lt;!-- 使用setter方法注入 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;testDIService1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;service.TestDIServiceImpl1&quot;</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 调用TestDIServiceImpl1类的setter方法，将myTestDIDao注入到 TestDIServiceImpl1类的属性testDIDao上--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;testDIDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;myTestDIDao&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><br>&gt; 反射机制：指在运行状态中,对于任意一个类,都能够知道这个类的所有属性和方法,对于任意一个对象,都能调用它的任意一个方法.这种动态获取信息,以及动态调用对象方法的功能叫java语言的反射机制.<br>      &gt;<br>      &gt; newInstance: 弱类型。低效率。只能调用无参构造。<br>      &gt;<br>      &gt; new: 强类型。相对高效。能调用任何public构造<br></code></pre></td></tr></table></figure></code></pre><ul><li><p><strong>Spring-beans模块</strong></p><ul><li><strong>BeanFactory</strong>:工厂模式的一个经典实现</li></ul></li><li><p><strong>Spring-context模块</strong>：建立在Core和Beans模块基础上，提供一个框架式的对象访问方式，是访问定义和配置的任何对象的媒介。ApplicationContext接口是Context模块的焦点。 </p></li><li><p><strong>Spring-context-support模块</strong>：支持整合第三方库到Spring应用程序上下文，特别是用于<code>高速缓存</code>（EhCache，JCache）和<code>任务调度</code>（CommonJ，Quartz）的支持。</p></li><li><p><strong>Spring-expression模块</strong>:提供了强大的表达式语言去支持运行时查询和操作对象图。</p></li></ul><h3 id="Spring的常用注解"><a href="#Spring的常用注解" class="headerlink" title="Spring的常用注解"></a>Spring的常用注解</h3><p>1.声明<strong>Bean</strong>的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> 该注解是一个泛化的概念，仅仅表示一个组件对象（Bean），可以作用在任何层次上<br><span class="hljs-meta">@Repository</span> 数据访问层(DAO) <span class="hljs-meta">@Service</span> 业务逻辑层 (Service) <span class="hljs-meta">@Controller</span> 控制器层<br><span class="hljs-meta">@ComponentScan</span>:扫描含有<span class="hljs-meta">@Component</span>，<span class="hljs-meta">@Controller</span>，<span class="hljs-meta">@Service</span>和<span class="hljs-meta">@Repository</span>的类，并将其注入到spring容器中<br></code></pre></td></tr></table></figure><p>2.注入<strong>Bean</strong>的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>:类成员变量、方法及构造方法进行标注，完成自动装配的工作,消除setter和getter方法，默认按照Bean类型进行装配<br><span class="hljs-meta">@Resource</span>：功能和<span class="hljs-meta">@Autowired</span>一样，默认按照名称来装配注入,只有当找不到与名称匹配的Bean才会按照类型来装配注入,<span class="hljs-meta">@Resource</span>注解有两个属性：name和type。<br><span class="hljs-meta">@Qualifier</span>:当<span class="hljs-meta">@Autowired</span>需要按照名称来装配注入时，需要结合该注解一起<br></code></pre></td></tr></table></figure><p>3.基于注解的依赖注入</p><ol><li>省略set方法</li><li>省略XML文件中的<bean></li><li>基于java配置的</li></ol><h3 id="Spring-AOP和instrumentation"><a href="#Spring-AOP和instrumentation" class="headerlink" title="Spring AOP和instrumentation"></a>Spring AOP和instrumentation</h3><ul><li><strong>Spring-aop</strong>模块：提供了一个符合AOP要求的面向切面的编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以便干净地解耦。</li><li><strong>Spring-aspects</strong>模块：提供了与AspectJ的集成功能，AspectJ是一个功能强大且成熟的AOP框架。</li><li><strong>Spring-instrument</strong>模块：提供了类植入（instrumentation）支持和类加载器的实现，可以在特定的应用服务器中使用。</li><li><strong>Spring-messaging模块</strong>：提供了对消息传递体系结构和协议的支持。</li></ul><h3 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h3><p>Bean的配置：Spring框架支持<code>XML</code>和<code>Properties</code>两种格式的配置文件</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 使用id属性定义myTestDIDao，其对应的实现类为dao.TestDIDaoImpl--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myTestDIDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dao.TestDIDaoImpl&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 使用构造方法注入 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;testDIService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;service.TestDIServiceImpl&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--给构造方法传引用类型的参数值myTestDIDao--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;myTestDIDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p> Bean的实例化</p><p><strong>1.构造方法实例化</strong></p><pre><code class="hljs"><pre><code class=" mermaid">graph LRBeanClass--id=constructorInstance--&gt;applocatationContext.xml--&gt;测试类</code></pre></code></pre><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;constructorInstance&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;instance.BeanClass&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//TestInstanse.class</span><br><span class="hljs-comment">//初始化Spring容器ApplicationContext，加载配置文件</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">appCon</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><span class="hljs-comment">//测试构造方法实例化Bean</span><br><span class="hljs-type">BeanClass</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> (BeanClass)appCon.getBean(<span class="hljs-string">&quot;constructorInstance&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>2.静态工厂实例化</strong></p><p>要求开发者在工厂类中创建一个静态方法来创建Bean的实例。配置Bean时，class属性指定静态工厂类，同时还需要使用<code>factory-method</code>属性指定工厂类中的静态方法。</p><pre><code class="hljs"><pre><code class=" mermaid">graph LR工厂类--&gt;配置文件--&gt;测试类</code></pre></code></pre> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 静态工厂方法实例化Bean，createInstance为静态工厂类BeanStaticFactory中的静态方法--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;staticFactoryInstance&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;instance.BeanStaticFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createInstance&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>3.实例工厂实例化</strong></p><p>要求开发者在工厂类中创建一个实例方法来创建Bean的实例。配置Bean时，需要使用<code>factory-bean</code>属性指定配置的实例工厂，同时还需要<code>factory-method</code>属性指定实例工厂中的实例方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanInstanceFactory</span> &#123;<br><span class="hljs-keyword">public</span> BeanClass <span class="hljs-title function_">createBeanClassInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanClass</span>(<span class="hljs-string">&quot;调用实例工厂方法实例化Bean&quot;</span>);<br>    &#125;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--applicationContext.xml--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;instance.BeanInstanceFactory&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 使用factory-bean属性指定配置工厂 ，</span><br><span class="hljs-comment">使用factory-method属性指定使用工厂中哪个方法实例化Bean--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;instanceFactoryInstance&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;myFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createBeanClassInstance&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p> Bean的作用域</p><p>  <img src="https://cdn.jsdelivr.net/gh/Manchesterss/picx-image@main/2020/image-20210516174148628.6h8qb6haryo0.png" alt="image-20210516174148628"></p><ul><li><p><strong>singleton作用域</strong>:由于singleton是scope的默认方式，因此有两种方式将bean的scope设置为singleton。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;constructorInstance&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;instance.BeanClass&quot;</span>/&gt;</span><br>或<br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;constructorInstance&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;instance.BeanClass&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>prototype作用域</strong></p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;constructorInstance&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;instance.BeanClass&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>Bean的生命周期</p><p>1．根据Bean的配置情况，实例化一个Bean。</p><p>2．根据Spring上下文对实例化的Bean进行依赖注入，即对Bean的属性进行初始化。</p><p>3．如果Bean实现了BeanNameAware接口，将调用它实现的setBeanName(String beanId)方法，此处参数传递的是Spring配置文件中Bean的ID。</p><p>4．如果Bean实现了BeanFactoryAware接口，将调用它实现的setBeanFactory()方法，此处参数传递的是当前Spring工厂实例的引用。</p><p>5．如果Bean实现了ApplicationContextAware接口，将调用它实现的setApplicationContext(ApplicationContext)方法，此处参数传递的是Spring上下文实例的引用。</p><p>6．如果Bean关联了BeanPostProcessor接口，将调用预初始化方法postProcessBeforeInitialization(Object obj, String s)对Bean进行操作。</p><p>7．如果Bean实现了InitializingBean接口，将调用afterPropertiesSet()方法。</p><p>8．如果Bean在Spring配置文件中配置了init-method属性，将自动调用其配置的初始化方法。</p><p>9．如果Bean关联了BeanPostProcessor接口，将调用postProcessAfterInitialization(Object obj, String s)方法，由于是在Bean初始化结束时调用After方法，也可用于内存或缓存技术。<br>以上工作（1至9）完成以后就可以使用该Bean，由于该Bean的作用域是singleton，所以调用的是同一个Bean实例。</p><p>10．当Bean不再需要时，将经过销毁阶段，如果Bean实现了DisposableBean接口，将调用其实现的destroy方法将Spring中的Bean销毁。<br>11．如果在配置文件中通过destroy-method属性指定了Bean的销毁方法，将调用其配置的销毁方法进行销毁。</p></li></ul><p>Bean的装配方式:Bean的装配方式即Bean依赖注入的方式。Spring容器支持基于<strong>XML配置的装配</strong>、<strong>基于注解的装配</strong>以及<strong>自动装配</strong>等多种装配方式。</p><h3 id="数据访问-x2F-集成"><a href="#数据访问-x2F-集成" class="headerlink" title="数据访问&#x2F;集成"></a>数据访问&#x2F;集成</h3><p>数据访问&#x2F;集成层由JDBC、ORM、OXM、JMS和事务模块组成。</p><ul><li><strong>Spring-jdbc模块</strong>：提供了一个JDBC 的抽象层，消除了繁琐的JDBC编码和数据库厂商特有的错误代码解析。</li><li><strong>Spring-tx模块（事务模块）</strong>：支持用于实现特殊接口和所有POJO（普通Java对象）类的编程和声明式事务管理。</li><li><strong>Spring-orm模块</strong>：为流行的对象关系映射(Object-Relational Mapping )API提供集成层，包括JPA和Hibernate。使用Spring-orm模块，可以将这些O&#x2F;R映射框架与Spring提供的所有其他功能结合使用，例如声明式事务管理功能。</li><li><strong>Spring-oxm模块</strong>：提供了一个支持对象&#x2F;XML映射的抽象层实现，如JAXB、Castor、JiBX和XStream。</li><li><strong>Spring-jms模块(Java Messaging Service)</strong> ：指Java消息传递服务，包含用于生产和使用消息的功能。自Spring 4.1后，提供了与Spring-messaging模块的集成。</li></ul><h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><p>Web层由Spring-web、Spring-webmvc、Spring-websocket和Portlet模块组成。</p><ul><li><strong>Spring-web模块</strong>：提供了基本的Web开发集成功能。例如：多文件上传功能、使用Servlet监听器初始化一个IoC容器以及Web应用上下文。</li><li><strong>Spring-webmvc模块</strong>：也称为Web-Servlet模块，包含用于Web应用程序的Spring MVC和REST Web Services实现。 Spring MVC框架提供了领域模型代码和Web表单之间的清晰分离，并与  Spring Framework的所有其他功能集成。</li><li><strong>Spring-websocket模块</strong>：Spring 4.0后新增的模块，它提供了WebSocket和SockJS的实现。</li><li><strong>Portlet模块</strong>：类似于Servlet模块的功能，提供了在Portlet环境中使用MVC实现。</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li><strong>Spring-test模块</strong>：支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--applicationContext.xml--&gt;</span><br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 将指定类TestDaoImpl配置给Spring，让Spring创建其实例 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dao.TestDaoImpl&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试类</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-comment">//初始化Spring容器ApplicationContext，加载配置文件</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">appCon</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span>         <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><span class="hljs-comment">//通过容器获取test实例</span><br><span class="hljs-type">TestDao</span> <span class="hljs-variable">tt</span> <span class="hljs-operator">=</span> (TestDao)appCon.getBean(<span class="hljs-string">&quot;test&quot;</span>);<br><span class="hljs-comment">//test为配置文件中的id</span><br>tt.sayHello();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*放射机制简单实例代码</span><br><span class="hljs-comment">**/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">_14_ReflectTest07</span><br><br>&#123;<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><br>         <span class="hljs-comment">//1.获取类</span><br><br>         <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;_12_CustomerService&quot;</span>);<br><br>         <span class="hljs-comment">//获取某个特定的方法</span><br><br>         <span class="hljs-comment">//通过：方法名+形参列表</span><br><br>         <span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;login&quot;</span>,String.class,String.class);<br><br>         <span class="hljs-comment">//通过反射机制执行login方法.</span><br><br>         <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> c.newInstance();<br><br>         <span class="hljs-comment">//调用o对象的m方法,传递&quot;admin&quot;&quot;123&quot;参数，方法的执行结果是retValue</span><br><br>         <span class="hljs-type">Object</span> <span class="hljs-variable">retValue</span> <span class="hljs-operator">=</span> m.invoke(o, <span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);<br><br>         System.out.println(retValue); <span class="hljs-comment">//true</span><br><br>     &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">_12_CustomerService</span><br><br>&#123;<br><br>     <span class="hljs-comment">//登录</span><br><br>     <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">login</span><span class="hljs-params">(String name,String pwd)</span>&#123;<br><br>         <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;admin&quot;</span>.equals(name) &amp;&amp; <span class="hljs-string">&quot;123&quot;</span>.equals(pwd))&#123;<br><br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>         &#125;<br><br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>     &#125;<br><br>     <span class="hljs-comment">//退出</span><br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logout</span><span class="hljs-params">()</span>&#123;<br><br>         System.out.println(<span class="hljs-string">&quot;系统已安全退出！&quot;</span>);<br><br>     &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Spring-MVC基础"><a href="#Spring-MVC基础" class="headerlink" title="Spring MVC基础"></a>Spring MVC基础</h2><p><img src="https://cdn.jsdelivr.net/gh/Manchesterss/picx-image@main/2020/P2.4o43tc7gmaw0.PNG" alt="P2"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 前缀 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 后缀 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="1-基于注解的控制器"><a href="#1-基于注解的控制器" class="headerlink" title="1.基于注解的控制器"></a>1.基于注解的控制器</h3><h3 id="2-MVC"><a href="#2-MVC" class="headerlink" title="2.MVC"></a>2.MVC</h3><h4 id="视图解析器"><a href="#视图解析器" class="headerlink" title="视图解析器"></a>视图解析器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 配置视图解析器</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> InternalResourceViewResolver <span class="hljs-title function_">getViewResolver</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">InternalResourceViewResolver</span> <span class="hljs-variable">viewResolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalResourceViewResolver</span>();<br>viewResolver.setPrefix(<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>);<br>viewResolver.setPrefix(<span class="hljs-string">&quot;.jsp&quot;</span>);<br><span class="hljs-keyword">return</span> viewResolver;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 配置静态资源</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> &#123;<br>registry.addResourceHandler(<span class="hljs-string">&quot;/html/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;/html/&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 配置拦截器Bean</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MyInteceptor <span class="hljs-title function_">myInteceptor</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInteceptor</span>();<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 重写addInterceptors方法注册拦截器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span>&#123;<br>registry.addInterceptor(myInteceptor());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="MultipartResolver配置"><a href="#MultipartResolver配置" class="headerlink" title="MultipartResolver配置"></a>MultipartResolver配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * MultipartResolver配置</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MultipartResolver <span class="hljs-title function_">multipartResolver</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">CommonsMultipartResolver</span> <span class="hljs-variable">multipartResolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonsMultipartResolver</span>();<br><span class="hljs-comment">//设置上传文件的最大值，单位为字节</span><br>multipartResolver.setMaxUploadSize(<span class="hljs-number">5400000</span>);<br><span class="hljs-comment">//设置请求的编码格式，默认为iso-8859-1</span><br>multipartResolver.setDefaultEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br><span class="hljs-keyword">return</span> multipartResolver();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="SpringMVC的常用注解"><a href="#SpringMVC的常用注解" class="headerlink" title="SpringMVC的常用注解"></a>SpringMVC的常用注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@ModelAttribute</span>:<br><span class="hljs-meta">@RequestParam</span>:<span class="hljs-meta">@RequestParam(defaultValue=&quot;&quot;)</span><br><span class="hljs-meta">@RestController</span>:<br></code></pre></td></tr></table></figure><h3 id="5-重定向和转发"><a href="#5-重定向和转发" class="headerlink" title="5.重定向和转发"></a>5.重定向和转发</h3><pre><code class=" mermaid">graph LRforward---u1[user]--&gt;i1[index]--&gt;t1[test]redirect---u2[user]--&gt;indexu2--&gt;test</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//转发：地址无变化，一个请求，同一服务器</span><br><span class="hljs-meta">@RequestMapping(&quot;/forward&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">tiaozhuan</span><span class="hljs-params">()</span>&#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/index/redirect&quot;</span><br>&#125;<br><span class="hljs-comment">//重定向：地址变化，不同服务器</span><br><span class="hljs-meta">@RequestMapping(&quot;/redirect&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">red</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/index/redirect&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-文件上传"><a href="#6-文件上传" class="headerlink" title="6.文件上传"></a>6.文件上传</h3><pre><code class=" mermaid">graph LRjsp--&gt;MultiFileDomain--&gt;MultiFileConcroller</code></pre><ol><li>实体类</li></ol><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;form action enctype=<span class="hljs-string">&quot;multipart/form-data&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>&lt;/form&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>边界类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//MultifileDomain</span><br></code></pre></td></tr></table></figure><ol start="3"><li>控制类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//MultifileController</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiFileController</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">multFileUpload</span><span class="hljs-params">()</span>&#123;<br>        String realPath;<br>        File targerDir=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(realPath);<br>        <span class="hljs-comment">//判断保存的文件夹是否存在</span><br>        <span class="hljs-keyword">if</span>(!targerDir.exists())&#123;<br>            targerDir.mkdir();<span class="hljs-comment">//创建文件夹</span><br>        &#125;<br>        <span class="hljs-comment">//MultipartFile自动匹配页面的file对象</span><br>        List&lt;MultipartFile&gt; files=multiFileDomain.getMyfile();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;files.size();i++)&#123;<br>            MultipartFile file=files.get(i);<span class="hljs-comment">//取索引赋值给 MultipartFile</span><br>            String filename=file.getOriginalFilename();<br>            File targetFile=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(realpath,filename);<br>            <span class="hljs-keyword">try</span>&#123;<br>                file.tarnsferTo(targetFile);<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        Logger.info(<span class="hljs-string">&quot;上传成功&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;showMulti&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//SpringMVCConfig</span><br>MultipatrResolver <br>MultipentFile<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * MultipartResolver配置</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MultipartResolver <span class="hljs-title function_">multipartResolver</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">CommonsMultipartResolver</span> <span class="hljs-variable">multipartResolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonsMultipartResolver</span>();<br><span class="hljs-comment">//设置上传文件的最大值，单位为字节,5400000=5.4M</span><br>multipartResolver.setMaxUploadSize(<span class="hljs-number">5400000</span>);<br><span class="hljs-comment">//设置请求的编码格式，默认为iso-8859-1</span><br>multipartResolver.setDefaultEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br><span class="hljs-keyword">return</span> multipartResolver;<br>&#125;<br></code></pre></td></tr></table></figure><p>jsp–div–&gt;file[input type&#x3D;’file’ name&#x3D;’myfile’]–&gt;MultipentFile<br>jsp–&gt;text[description]–&gt;description</p><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="Spring-AOP的基本概念"><a href="#Spring-AOP的基本概念" class="headerlink" title="Spring AOP的基本概念"></a>Spring AOP的基本概念</h3><p>AOP采取横向抽取机制，即将分散在各个方法中的重复代码提取出来，然后在程序编译或运行阶段，再将这些抽取出来的代码应用到需要执行的地方。降低模块之间的耦合度，OOP实现的是父子关系的纵向重用。但是AOP不是OOP的替代品，而是OOP的补充，它们相辅相成。</p><p><img src="https://cdn.jsdelivr.net/gh/Manchesterss/picx-image@main/2020/image-20210516180453543.3v9pd5gsb4q0.png" alt="image-20210516180453543"></p><p>横向抽取机制</p><pre><code class=" mermaid">graph LRA[类]--抽象--&gt;B[对象]B--实例--&gt;Ac[关注点]--抽象--&gt;d[切面]</code></pre><p><img src="https://cdn.jsdelivr.net/gh/Manchesterss/picx-image@main/2020/image-20210516181041922.kub7xhn17a8.png" alt="image-20210516181041922"></p><p>1．<strong>切面</strong><br>切面（Aspect）是指封装横切到系统功能（如事务处理）的类。</p><p>2．<strong>连接点</strong><br>一连接点（Joinpoint）是指程序运行中的一些时间点，如方法的调用或异常的抛出。</p><p>3．<strong>切入点</strong><br>切入点（Pointcut）是指那些需要处理的连接点。一个匹配连接点的正则表达式。在Spring AOP 中，所有的方法执行都是连接点，而切入点是一个描述信息，它修饰的是连接点，通过切入点确定哪些连接点需要被处理。</p><p>4．<strong>通知（增强处理）</strong><br>由切面添加到特定的连接点（满足切入点规则）的一段代码，即在定义好的切入点处所要执行的程序代码。可以将其理解为切面开启后，切面的方法。因此，通知是切面的具体实现。</p><p>5．<strong>引入</strong><br>引入（Introduction）允许在现有的实现类中添加自定义的方法和属性。</p><p>6．<strong>目标对象</strong><br>目标对象（Target Object）是指所有被通知的对象。如果AOP 框架使用运行时代理的方式（动态的AOP）来实现切面，那么通知对象总是一个代理对象。</p><p>7．<strong>代理</strong><br>代理（Proxy）是通知应用到目标对象之后，被动态创建的对象。</p><p>8．<strong>组入(织入)</strong><br>组入（Weaving）是将切面代码插入到目标对象上，从而生成代理对象的过程。根据不同的实现技术，AOP织入有三种方式：</p><ul><li>编译器织入，需要有特殊的Java编译器；-</li><li>类装载期织入，需要有特殊的类装载器；</li><li>动态代理织入，在运行期为目标类添加通知生成子类的方式。</li></ul><p>Spring AOP框架默认采用动态代理织入，而AspectJ（基于Java语言的AOP框架）采用编译器织入和类装载期织入。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p> <strong>JDK动态代理</strong>：JDK动态代理是<code>java.lang.reflect.*</code>包提供的方式，它必须借助一个接口才能产生代理对象。因此，对于使用业务接口的类，Spring默认使用JDK动态代理实现AOP。</p><p> <strong>CGLIB动态代理</strong>：一个高性能开源的代码生成包，采用非常底层的字节码技术，对指定的目标类生成一个子类，并对子类进行增强。在Spring Core包中已经集成了<code>CGLIB</code>所需要的JAR包，不需要另外导入JAR包。</p><h3 id="基于代理类的AOP实现"><a href="#基于代理类的AOP实现" class="headerlink" title="基于代理类的AOP实现"></a>基于代理类的AOP实现</h3><p>Spring中默认使用JDK动态代理实现AOP编程。使用<code>org.springframework.aop.framework.ProxyFactoryBean</code>创建代理是Spring AOP实现的最基本方式。</p><blockquote><p>AOP的术语</p><p>AOP实战-AspectJ</p><p>AOP(Aspect-Oriented Programming, &#x3D;&#x3D;面向切面编程&#x3D;&#x3D;): 是一种新的方法论, 是对传统 OOP(Object-Oriented Programming, 面向对象编程) 的补充。</p><p>AOP 的主要编程对象是切面(aspect), 而切面是把横切关注点&#x3D;&#x3D;模块化&#x3D;&#x3D;!</p><p>在应用 AOP 编程时, 需要定义公共功能, 但可以明确的定义这个功能在哪里应用, 并且不必修改需要使用公共功能的类。 这样以来横切关注点就被模块化到特殊的对象(切面)里.</p><p>面向AOP编程程序员参与的3个部分：</p><ul><li>定义普通业务组件</li><li>定义切入点</li><li>定义通知，也叫增强处理</li></ul></blockquote><p>Spring通知的类型，前置通知，正常返回通知取决于在连接点执行前后时间，此为还有异常返回通知，连接点执行完成后执行最终通知。环绕通知，围绕在连接点前后，如一个方法调用的前后<br>切入点的定义</p><p>Spring Aop中切入点表达式大量使用execution表达式:<br>modifiers-pattern指定方法的修饰符(可省略)<br>ret-type-pattern<br>declaring-type-pattern</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//任意公共方法的执行</span><br>execution(<span class="hljs-keyword">public</span> * *(..))<br><span class="hljs-comment">//任何一个以‘set’开始的方法的执行</span><br>execution(*set*(..))<br><span class="hljs-comment">//AccountService接口的任意方法的执行</span><br>execution(*com.xyz.service.AccountService)<br><span class="hljs-comment">//定义在service包里的任意方法的执行</span><br>execution(*com.xyz.servuce.*.*(..))<br><span class="hljs-comment">//定义在service包或者子包里的任意方法的执行</span><br>execution(*com.xyz.servuce..*.*(..))<br></code></pre></td></tr></table></figure><h3 id="基于XML配置的AOP编程"><a href="#基于XML配置的AOP编程" class="headerlink" title="基于XML配置的AOP编程"></a>基于XML配置的AOP编程</h3><ol><li><p>添加支持AOP编程的JAR包</p></li><li><p>配置切面</p></li><li></li></ol><h2 id="Spring-Boot入门​和​核心"><a href="#Spring-Boot入门​和​核心" class="headerlink" title="Spring Boot入门​和​核心"></a>Spring Boot入门​和​核心</h2><p>​&#x3D;&#x3D;SpringBoot的基本配置、自动配置原理、条件注解&#x3D;&#x3D;</p><h3 id="MAVEN配置"><a href="#MAVEN配置" class="headerlink" title="MAVEN配置"></a>MAVEN配置</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">MAVEN_HOME</span>-&gt;目录<br><span class="hljs-attribute">path</span>=%MAVEN_HOME%\bin<br><span class="hljs-attribute">cmd</span>-&gt;mvn -v<br><span class="hljs-attribute">maven</span>.rar-&gt;D:<br><span class="hljs-attribute">apache</span>-maven-<span class="hljs-number">3</span>.<span class="hljs-number">6</span>.<span class="hljs-number">3</span>&gt;conf&gt;settings&gt;&lt;localRepository&gt;d:\maven&lt;/localRepository&gt;<br><span class="hljs-attribute">Maven4MyEclipse</span>&gt;User Settings&gt;apache-maven-<span class="hljs-number">3</span>.<span class="hljs-number">6</span>.<span class="hljs-number">3</span>&gt;conf&gt;settings.xml<br></code></pre></td></tr></table></figure><p><strong>优点</strong></p><ol><li>编码简单</li><li>配置快捷</li><li>部署简便：内嵌Tomcat、Jetty等Web容器</li><li>监控容易</li></ol><p><strong>主要特性</strong></p><ol><li>&#x3D;&#x3D;约定优于配置&#x3D;&#x3D;</li><li>独立运行的Spring应用</li><li>内嵌Web容器</li><li>提供starter简化Maven配置</li><li>自动配置Spring</li><li>提供准生产的应用监控</li><li>无代码生成和XML配置</li></ol><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p>基于项目对象模型(Project Object Model，POM)</p><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 核心启动器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>//IDEA<br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-comment">//组合注解，组合了@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan</span><br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-comment">//because:该注解是一个组合注解，替代@Configuration</span><br><span class="hljs-meta">@SpringBootConfiguration</span>包含&#123;<br><br>&#125;<br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-comment">//读pom.xml文件,让SpringBoot根据当前应用项目所依赖的jar自动配置项目的相关配置。</span><br><span class="hljs-meta">@ComponentScan</span><br><span class="hljs-comment">//让SpringBoot自动扫描@SpringBootApplication所在类的同级别以及它的子包中的配置</span><br><span class="hljs-comment">//建议将@SpringBootApplication注解的入口类放置在项目包下，保证SpringBoot自动扫描项目所有包中的配置</span><br></code></pre></td></tr></table></figure><p><strong>全局配置文件</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">全局配置文件:放置在SB项目的resources目录下或者类路径的/config目录下<br>banner.txt<br>application.properties<br>&#123;<br>server.<span class="hljs-attribute">port</span>=8888<br>server.servlet.<span class="hljs-attribute">context-path</span>=/ch3_1<br>spring.main.<span class="hljs-attribute">banner-mode</span>=off<br>&#125;<br>application.yml<br></code></pre></td></tr></table></figure><p><strong>读取应用配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Environment</span><br><span class="hljs-comment">//通用的读取应用程序运行时的环境变量的类，通过key-value方式读取application.properties、命令行输入参数、系统属性、操作系统环境变量等。</span><br><span class="hljs-meta">@Value(&quot;$&#123;test.msg&#125;&quot;)</span><br><span class="hljs-comment">//test.msg为配置文件application.properties中的key</span><br><span class="hljs-keyword">private</span> String msg;<br><span class="hljs-comment">//通过@Value注解将配置文件中的key对应的Value赋值给变量msg</span><br><span class="hljs-meta">@ConfigurationProperties(prefix=&quot;obj&quot;)</span><span class="hljs-comment">//obj为配置文件中key的前缀</span><br><span class="hljs-meta">@PropertySource(&#123;&quot;my.properties&quot;,&quot;your.properties&quot;&#125;)</span><br><span class="hljs-comment">//读取项目的其他配置文件</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix=&quot;&quot;)</span><br><span class="hljs-comment">//读取Application的信息</span><br><span class="hljs-comment">//开启属性配置类MyProperties提供参数</span><br><span class="hljs-meta">@EnableConfigurationProperties(MyProperties.class)</span><br><span class="hljs-comment">//类加载器中是否存在对应的类</span><br><span class="hljs-meta">@ConditionalOnClass(MyService.class)</span><br><span class="hljs-comment">//应用环境中属性是否存在指定的值</span><br><span class="hljs-meta">@ConditionalOnPropert(prefix=&quot;my&quot;,value=&quot;enabled&quot;,matchIfMissing=true)</span><br></code></pre></td></tr></table></figure><h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Log log=LogFactory.getLog(LogTestController.class);<br>log.info(<span class="hljs-string">&quot;测试日志&quot;</span>);<br><span class="hljs-comment">//日志级别有ERROR、WARN、INFO、DEBUG、TRACE</span><br><span class="hljs-comment">//设置日志的默认级别为info</span><br>logging.level.root=info<br></code></pre></td></tr></table></figure><h2 id="Spring-Boot的web开发"><a href="#Spring-Boot的web开发" class="headerlink" title="Spring Boot的web开发"></a>Spring Boot的web开发</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在pom.xml文件中添加依赖配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Thymeleaf模板引擎"><a href="#Thymeleaf模板引擎" class="headerlink" title="Thymeleaf模板引擎"></a>Thymeleaf模板引擎</h3><p>Thymeleaf是一个Java类库，是一个XML&#x2F;XHTML&#x2F;HTML5的模板引擎</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--pom.xml配置thymeleaf--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span><span class="hljs-params">(HttpSession session,HttpServletRequest request)</span>&#123;<br>    session.setAttribute(<span class="hljs-string">&quot;skey&quot;</span>,<span class="hljs-string">&quot;session范围的值&quot;</span>);<br>    request.setAttribute(<span class="hljs-string">&quot;rkey&quot;</span>,<span class="hljs-string">&quot;request范围的值&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;test&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--Thymeleaf基础语法--&gt;</span><br><span class="hljs-comment">&lt;!--1.引入Thymeleaf--&gt;</span><br><span class="hljs-comment">&lt;!--2.输出内容--&gt;</span><br><span class="hljs-comment">&lt;!--3.基本表达式--&gt;</span><br><span class="hljs-comment">&lt;!--4.引入URL--&gt;</span><br><span class="hljs-comment">&lt;!--5.访问WebContext对象中的属性--&gt;</span><br><span class="hljs-comment">&lt;!--6.运算符--&gt;</span><br><span class="hljs-comment">&lt;!--7.条件判断--&gt;</span><br><span class="hljs-comment">&lt;!--8.循环--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;user,usStat:$&#123;users&#125;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;usStat.index&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;user.uname&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;user.upass&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-comment">&lt;!--9.内置对象--&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Bootstrap框架"><a href="#Bootstrap框架" class="headerlink" title="Bootstrap框架"></a>Bootstrap框架</h3><p>静态文件,<code>样式表都用id取名</code></p><p><img src="https://cdn.jsdelivr.net/gh/Manchesterss/picx-image@main/2020/image-20210514082442063.5q5qniu7oxc0.png" alt="image-20210514082442063"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--pom.xml--&gt;</span><br><span class="hljs-comment">&lt;!-- 配置将哪些资源文件(静态文件/模板文件/mapper文件)加载到tomcat输出目录里 --&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><span class="hljs-comment">&lt;!--java文件的路径--&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                 <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.*<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>             <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>             <span class="hljs-comment">&lt;!-- &lt;filtering&gt;false&lt;/filtering&gt;--&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><span class="hljs-comment">&lt;!--资源文件的路径--&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                 <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.*<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>             <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>             <span class="hljs-comment">&lt;!-- &lt;filtering&gt;false&lt;/filtering&gt;--&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h3><p><code>异步通信</code> <code>局部刷新</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;js/jquery.js&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>$.ajax(&#123;<br>key : &quot;value&quot;,<br>url : &quot;textJson&quot;,<br>dataType ：&quot;json&quot;,<br>type : &quot;post&quot;,<br>contentType : &quot;application/json&quot;,<br>data : JSON.stringify(&#123;&#125;),<br>&#125;);<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph LRa[ajax]--&gt;url--&gt;Controller</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收页面请求的JSON数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(&quot;/testJson&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-comment">/*@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用。</span><br><span class="hljs-comment">1) 如果只是使用@RestController注解Controller，则Controller中的方法无法返回jsp页面或者html，</span><br><span class="hljs-comment">返回的内容就是Return的内容。</span><br><span class="hljs-comment">2) 如果需要返回到指定页面，则需要用 @Controller注解。如果需要返回JSON，XML或自定义mediaType内容到页面，</span><br><span class="hljs-comment">则需要在对应的方法上加上@ResponseBody注解。</span><br><span class="hljs-comment">   */</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ajax function()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">testJson</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-comment">//取页面信息,$()</span><br><span class="hljs-keyword">var</span> pname=$(<span class="hljs-string">&quot;#pname).val();</span><br><span class="hljs-string">var password=$(&quot;</span>#password).<span class="hljs-title function_">val</span>();<br><span class="hljs-keyword">var</span> page=$(<span class="hljs-string">&quot;#page).val();</span><br><span class="hljs-string">alert(panme);</span><br><span class="hljs-string">$.ajax(&#123;</span><br><span class="hljs-string">//Controller虚拟地址</span><br><span class="hljs-string">url : &quot;</span>testJson<span class="hljs-string">&quot;,</span><br><span class="hljs-string">dataType : &quot;</span><span class="hljs-title class_">Json</span><span class="hljs-string">&quot;,</span><br><span class="hljs-string">type : &quot;</span>post<span class="hljs-string">&quot;,</span><br><span class="hljs-string">contentType : &quot;</span>application/json<span class="hljs-string">&quot;,</span><br><span class="hljs-string">data : JSON.stringify(&#123;pname:pname,password:password,page:page&#125;),</span><br><span class="hljs-string">success:function(listdata)&#123;</span><br><span class="hljs-string">var txt=&quot;</span><span class="hljs-string">&quot;;</span><br><span class="hljs-string">if(listdata!=null)&#123;</span><br><span class="hljs-string">for(var i=0;i&lt;listdata.length;i++)&#123;</span><br><span class="hljs-string">txt+=`&lt;tr&gt;</span><br><span class="hljs-string">&lt;td&gt;$&#123;listdata[].pname&#125;&lt;/td&gt;</span><br><span class="hljs-string">&lt;td&gt;$&#123;listdata[].password&#125;&lt;/td&gt;</span><br><span class="hljs-string">&lt;td&gt;$&#123;listdata[].page&#125;&lt;/td&gt;</span><br><span class="hljs-string">&lt;/tr&gt;`</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">var tbody=$(&quot;</span>&lt;tbody&gt;&lt;/tbody&gt;<span class="hljs-string">&quot;).html(txt);</span><br><span class="hljs-string">$(&#x27;#allp).html(tbody);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;,</span><br><span class="hljs-string">error:function()&#123;</span><br><span class="hljs-string">alert(&quot;</span>访问失败<span class="hljs-string">&quot;);</span><br><span class="hljs-string">&#125;,</span><br><span class="hljs-string">&#125;);</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Spring-Boot的数据访问"><a href="#Spring-Boot的数据访问" class="headerlink" title="Spring Boot的数据访问"></a>Spring Boot的数据访问</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--pom.xml--&gt;</span><br><span class="hljs-comment">&lt;!-- 添加MySQL依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.45<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-comment">&lt;!-- MySQL8.x时，请使用8.x的连接器 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--添加Oracle的依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.oracle<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ojdbc6<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>11.2.0.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- MyBatis-Spring，Spring Boot应用整合MyBatis框架的核心依赖配置 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.oracle<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ojdbc6<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>11.2.0.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="hljs-comment">#spring.datasource.url=jdbc:mysql://localhost:3306/ems</span><br><span class="hljs-comment">#spring.datasource.username=root</span><br><span class="hljs-comment">#spring.datasource.password=root</span><br><span class="hljs-attr">mybatis.mapper-locations</span>=<span class="hljs-string">classpath:/static/Mapper/*.xml</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">8080</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">oracle.jdbc.driver.OracleDriver</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:oracle:thin:@localhost:1521/ORCLLZD</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">students</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">123456       </span><br><span class="hljs-attr">server.servlet.context-path</span>=<span class="hljs-string">/testdb</span><br></code></pre></td></tr></table></figure><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>​&#96;&#96;&#96;xml</p><!--pom.xml--><!--添加lombok的依赖--><pre><code class="hljs">    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;</code></pre><!--热部署--><pre><code class="hljs">  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;  &lt;/dependency&gt;</code></pre><!--freemarker模板引擎--><pre><code class="hljs">  &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;  &lt;/dependency&gt;</code></pre><p>&#96;&#96;&#96;</p><h1 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h1>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>SSM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔记</tag>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客美化之路</title>
    <link href="/2021/09/01/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"/>
    <url>/2021/09/01/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="记录博客改造的进程"><a href="#记录博客改造的进程" class="headerlink" title="记录博客改造的进程"></a>记录博客改造的进程</h2><p>一点一点的完善其他功能</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello Blog</title>
    <link href="/2021/09/01/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/09/01/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h2><p>我的个人博客，从今天正式营业了，其实博客两年前搭起来了，一直不知道该写些什么，内容就随性一点，尽量多记录一下自己学习的过程吧。</p><p>欢迎各位朋友留下脚印：）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Oracle复习题</title>
    <link href="/2021/08/23/Oracle%E5%A4%8D%E4%B9%A0%E9%A2%98/"/>
    <url>/2021/08/23/Oracle%E5%A4%8D%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="Oracle复习题"><a href="#Oracle复习题" class="headerlink" title="Oracle复习题"></a>Oracle复习题</h2><p>1、同义词是模式对象的一个别名，模式对象包括表、索引、视图等。</p><p>2、Oracle 11g的全局数据库名称由数据库名称和网域名称组成。</p><p>3、Oracle 11g数据库服务器由Oracle数据库软件和Oracle实例组成。</p><p>4、总体来说，数据库系统由数据库、硬件、软件和数据库管理员组成。</p><p>5、表空间有三种类型：永久性、临时性和还原性。</p><p>6、状态选项用于设置表空间状态，状态有读写、只读和脱机三种。</p><p>7、在Order By子句中，用于升序排列的关键字是ASC。</p><p>8、用户账号拥有的对象集称为用户的方案。</p><p>9、用于指出一个字符串是否与指定的字符串相匹配的谓词是Like。</p><p>10、禁用约束所使用的关键字是Disable。</p><p>11、段空间管理又分为手工段和自动段两种空间管理方式。</p><p>12、在Oracle系统中，为列指定别名既可以使用AS关键字，也可以不使用任何关键字而直接指定。</p><p>13、在Order By子句中，用于降序排列的关键字是DESC。</p><p>14、如果要在Oracle中另外创建索引，一般有两种方法：使用SQL Developer和PL&#x2F;SQL命令。</p><p>15、激活约束所使用的关键字是Enable。</p><p>16、Oracle提供了3类运算符：算数运算符、关系运算符和逻辑运算符。</p><p>17、整个PL&#x2F;SQL块分3部分：声明部分、执行部分和异常处理部分。</p><p>18、表空间有三种类型：永久性、临时性和还原性。</p><p>19、Oracle的自定义异常可以分为错误编号异常和业务逻辑异常两种。</p><p>20、能够引起触发器运行的操作就被称为触发事件。</p><p>21、一般情况下，Oracle的锁可以分为：DML锁、DDL锁和内部锁。</p><p>22、数据字典是Oracle存放数据库内部信息的地方，用来描述数据库内部的运行和管理情况。</p><p>23、用于消除结果集中的重复行的关键字是DISTINCT。</p><p>24、在Oracle中，通过游标操作数据主要使用显示游标和隐式游标。</p><p>25、事务的提交方式包括：显式提交、自动提交和隐式提交。</p><p>26、DDL锁有独占DDL锁、共享DDL锁和可破的分析DDL锁。</p><p>27、根据系统管理方式的不同，在Oracle数据库中将权限分为两大类：系统权限和对象权限。</p><p>28、角色是一个独立的数据库实体，它包括一组权限。</p><p>29、数据字典是Oracle存放数据库内部信息的地方，用来描述数据库内部的运行和管理情况。</p><p>30、按照索引列的个数又可以将索引分为单列索引和复合索引。</p><p>31、事务的状态分为：活动状态、部分提交状态、失败状态、提交状态和中止状态。</p><p>32、在建立数据库之前，必须指定数据库实例的系统表示符，此系统标识符就是SID。</p><p>33、PL&#x2F;SQL中的循环语句主要包括：Loop语句、While语句和for语句3种。</p><p>34、根据异常产生的机理和原理，可将Oracle系统异常分为两大类：预定义异常和自定义异常。</p><p>35、审计用来监视和记录所选用的数据活动。</p><p>36、视图是一个虚拟表，它由存储的查询构成，可以将它的输出看作一个表。</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>1、非归档模式。</p><p>非归档模式就是指在系统运行期间，所产生的日志信息不断地记录到日志文件组中，当所有重做日志组被写满后，又重新从第一个日志组开始覆写。</p><p>非归档模式的运行机制是：不备份，恢复能力有限。</p><p><strong>特点是：</strong>缺点 占空间小 优点 恢复能力差。</p><p>2、归档模式。</p><p>归档模式就是指各个日志文件都被写满并即将被覆盖之前，先由递归进程将即将被覆盖的日志文件中的日志信息读出，并将“读出的日志信息”写入归档日志文件中，这个过程又被称为归档操作。</p><p>归档模式运行机制是：重复写数据，当文件写满重新备份再写、恢复强、占空间。</p><p><strong>特点是：</strong>缺点 占地方 优点 恢复能力强。</p><p>3、B树索引。</p><p>Oracle的标准索引结构是是一个典型的B树结构，其包含的组件主要是:</p><ol><li><p>叶子结点：包含条目直接指向表里的数据行</p></li><li><p>分支结点：包含的条目指向索引里其他的分支节点或者叶子节点</p></li><li><p>根节点：一个B树索引只有一个根节点，它实际就是位于树的最顶端的分支节点</p><p><img src="https://ewr1.vultrobjects.com/imgspice/000/000/619/956_43e_8ee.jpg" alt="B树索引"></p></li></ol><p>4、外键。</p><p>外键（foreign key）是指“当前表”引用“另外一个表”的某个列或某几个列，而“另外一个表”中被引用的列必须具有主键约束或者唯一性约束。</p><p>5、回退事务。</p><p>回退事务（rollback语句）是指撤销对数据库进行的全部操作，Oracle利用回退段来存储修改前的数据，通过重做日志来记录对数据所做的修改。</p><p>回退点又称为保存点,指在含有较多SQL语句的事务中间设定的回滚标记，其作用类似于调试程序的中断点。利用保存点可以将事务划分为若干部分,可以回滚到指定的保存点，保存点记录的是当前数据库的状态</p><blockquote><p>在事务commit提交前,可以使用rollback 到指定的保存点,来回退到指定的保存点</p><p>在事务commit提交后,保存点会被删除,这个时候,就无法进行回退了</p><p>这里在使用保存点之前,强调一点,任何commit操作,也就是事务提交操作,都会导致savepoint的被删除!!!</p></blockquote><p>6、提交事务</p><p>当执行使用commit语句可以提交事务.当执行了commit语句后,会确认事务的变化、结束事务、删除保存点、释放锁。在此之前,与当前事务相关的数据都会被加锁,直到当前事务进行了commit操作,如果在这个过程中有其他回话试图操作相关数据,(这些数据已经被当前事务加锁),那么其他回话会进行等待,或者直接返回错误。</p><p>注意:只有在提交事务之后也就是进行commit操作之后,数据才会真正的发生改变,在commit提交之前操作,全部被记录入Oracle日志系统</p><p>7、视图。</p><p>视图是一个虚拟表，它由存储的查询构成，可以将它的输出看作一个表。视图同真的表一样，也可以包含一系列带有名称的列和行数据，但是视图并不在数据库中存储数据值，其数据值来自定义视图的查询语句所引用的表，数据库只在数据字典中存储视图的定义信息。</p><p>视图是一个逻辑表，是查看表的一种方式。视图是对根据预定义的选择标准、由一个或者多个行的集合建立起来的动态表的静态定义。</p><p>8、变量。</p><p>变量是指其值在程序运行过程中可以改变的数据存储结构，定义变量必需的元素就是变量名和数据类型.另外还有可选择的初始值，其标准语法格式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&lt;变量名&gt; &lt;数据类型&gt; [(长度):=&lt;初始值&gt;];<br></code></pre></td></tr></table></figure><p>9、常量。</p><p>常量是指其值在程序运行过程中不可改变的数据存储结构，定义常量必需的元素包括常量名、数据类型、常量值和constant关键字，例如一年四个季度，9月有30天，圆周率等，其标准语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&lt;常量名&gt; constant &lt;数据类型&gt;:=&lt;常量值&gt;;<br></code></pre></td></tr></table></figure><p>10、连接。</p><p>连接（Join）是把两个表中的行按照给定的条件进行拼接而形成新表。</p><p>多个数据表，每个表的信息不是独立存在，而是存在一定关系，当用户查询某个表的信息时，很可能需要查询关联数据表的信息，这就是多表关联查询。</p><h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><p>1、在Oracle 11g系统中，约束的类型包括哪几种？</p><p>约束分为5种： 非空（NOT NULL）约束、 唯一性（UNIQUE）约束、主键（PRIMARY KEY）约束、外键（FOREIGN KEY）约束、检查（CHECK）约束。</p><blockquote><p>　　非空（NOT NULL）约束：顾名思义，所约束的列不能为NULL值。否则就会报错<br>　　唯一（UNIQUE）约束：在表中每一行中所定义的这列或这些列的值都不能相同。必须保证唯一性。否则就会违法约束条件。</p><p>　　主键（PRIMARY KEY）约束：唯一的标识表中的每一行，不能重复，不能为空。 创建主键或唯一约束后，ORACLE会自动创建一个与约束同名的索引（UNIQUENES为UNIQUE唯一索引）。需要注意的是：每个表只能有且有一个主键约束。</p><p>　　外键（FOREIGN KEY）约束：用来维护从表（Child Table）和主表（Parent Table）之间的引用完整性. 外键约束是个有争议性的约束，它一方面能够维护数据库的数据一致性，数据的完整性。防止错误的垃圾数据入库； 另外一方面它会增加表插入、更新等SQL性能的额外开销，不少系统里面通过业务逻辑控制来取消外键约束。例如在数据仓库中，就推荐禁用外键约束。</p><p>　　检查（CHECK）约束：表中每行都要满足该约束条件。条件约束既可以在表一级定义也可以在列一级定义。在一列上可以定义任意多个条件约束。<br>　　REF约束的定义：REF column by definition references an object in another object type or in a relational table. A REF constraint lets you further describe the relationship between the REF column and the object it references.</p></blockquote><p>2、Oracle 11g默认创建的主要表空间有哪些？</p><p>SYSTEM、USERS、TEMP、SYSAUX、UNDOTBS1、EXAMPLE</p><blockquote><p>SYSTEM：system表空间是永久表空间，用于存储SYS用户的表、视图、存储过程对象。</p><p>每个ORACLE数据库至少有一个SYSTEM表空间,这是数据库创建时自动创建的。</p><p>USERS：users表空间是永久表空间，存储数据库用户创建的数据库对象</p><p>TEMP：temp表空间是临时表空间，用户存储SQL语句处理的表示索引信息。</p><p>SYSAUX：作为SYSTEM的辅助表空间。</p><p>UNDOTBS1：Undotbs1表空间是存储撤销信息的undo表空间。</p><p>EXAMPLE：安装Oracle数据库示例的表空间</p></blockquote><p>3、Oracle的系统全局（SGA）的主要部件有哪些？</p><p>SGA是所有用户进程共享的一块内存区域，主要部件有高速数据缓冲区、共享池、重做日志缓冲区、Java池和大型池。</p><blockquote><p>（1）<strong>数据高速缓冲区</strong>：存放着Oracle系统最近使用过的数据库数据块。</p><p>（2）<strong>共享池</strong>：相当于程序高速缓冲区，所有的用户程序都存放在共享SQL池中。</p><p>（3）<strong>重做日志缓冲区</strong>：用于缓冲区在对数据进行修改的操作过程中生成的重做记录.<br>（4）<strong>大型池</strong>：在SGA区中不是必需的内存结构，只在某些特殊情况下，实例需要使用大型池来减轻共享池的访问压力，常用情况有：备份和恢复、执行具有大量排序操作的SQL语句、使用并行查询时。</p></blockquote><p>4、在哪些情况下，实例需要使用大型池来减轻共享池的访问压力？</p><p>(1)使用恢复管理器进行备份和恢复操作时，大型池将作为I&#x2F;O缓冲区使用。</p><p>(2)使用I&#x2F;O Slave仿真异步I&#x2F;O功能时，大型池将被作为I&#x2F;O缓冲区使用。</p><p>(3)执行具有大量排序操作的SQL语句。 　　　　</p><p>(4)当使用并行查询时，大型池作为并行查询进程彼此交换信息的地方。 </p><p>5、回滚到指定保存点时，将完成哪些主要的工作？</p><ol><li>回滚保存点之后的部分事务。</li><li>删除在该保存点之后建立的全部保存点，但保留该保存点，以便多次回避。</li><li>解除保存点之后表的封锁或行的封锁。</li></ol><p>6、自治事务提供了一种利用PL&#x2F;SQL控制事务的新方法，可以用于哪几种情况？</p><ul><li>顶层匿名块</li><li>本地（过程中的过程）、独立或打包的函数和过程</li><li>对象类型的方法</li><li>数据库触发器</li></ul><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><p>1、在scott模式下，创建学生表（XSB），其表结构如下：</p><table><thead><tr><th>列名</th><th>数据类型</th><th>是否可空</th><th>默认值</th><th>说明</th><th>列名含义</th></tr></thead><tbody><tr><td>XH</td><td>char(6)</td><td>╳</td><td>无</td><td>主键</td><td>学号</td></tr><tr><td>Xm</td><td>char(8)</td><td>╳</td><td>无</td><td></td><td>姓名</td></tr><tr><td>Xb</td><td>char(2)</td><td>╳</td><td>“男”</td><td></td><td>性别</td></tr><tr><td>Cssj</td><td>date</td><td>╳</td><td>无</td><td></td><td>出生日期</td></tr><tr><td>Zy</td><td>char(12)</td><td>√</td><td>无</td><td></td><td>专业</td></tr><tr><td>Zxf</td><td>number(2)</td><td>√</td><td>0</td><td></td><td>总学分</td></tr><tr><td>Bz</td><td>varchar2(200)</td><td>√</td><td>无</td><td></td><td>备注</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> XSB(<br>  XH <span class="hljs-type">char</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>  XM <span class="hljs-type">char</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  XB <span class="hljs-type">char</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  CSSJ <span class="hljs-type">date</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  ZY <span class="hljs-type">char</span>(<span class="hljs-number">12</span>) <span class="hljs-keyword">NULL</span>,<br>  zxf number(<span class="hljs-number">2</span>) <span class="hljs-keyword">NULL</span>,<br>  BZ varchar2(<span class="hljs-number">200</span>) <span class="hljs-keyword">NULL</span><br>   );<br></code></pre></td></tr></table></figure><p>2、在scott模式下，创建课程表（KCB），其表结构如下：</p><table><thead><tr><th>列名</th><th>数据类型</th><th>是否可空</th><th>默认值</th><th>说明</th><th>列名含义</th></tr></thead><tbody><tr><td>KCH</td><td>char(3)</td><td>╳</td><td>无</td><td>主键</td><td>课程号</td></tr><tr><td>KCM</td><td>char(16)</td><td>╳</td><td>无</td><td></td><td>课程名</td></tr><tr><td>KKXQ</td><td>number(1)</td><td>√</td><td>1</td><td></td><td>开课学期</td></tr><tr><td>XS</td><td>number(2)</td><td>√</td><td>0</td><td></td><td>学时</td></tr><tr><td>XF</td><td>number(1)</td><td>╳</td><td>0</td><td></td><td>学分</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> KCB(<br> KCH <span class="hljs-type">char</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br> KCM <span class="hljs-type">char</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br> KKXQ number(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;1&#x27;</span>,<br> XS number(<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span>,<br> XF number(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span><br> );<br></code></pre></td></tr></table></figure><p>3、假设有一个与jobs表结构一样的表jobs_temp，然后将jobs表中最高工资额（max_salary）大于10000的记录插入到新表jobs_temp中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> jobs_temp <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> jobs <span class="hljs-keyword">where</span> jobs.max_salary<span class="hljs-operator">&gt;</span><span class="hljs-number">10000</span>;<br></code></pre></td></tr></table></figure><p>4、在scott模式下，把emp表中职务为销售员（SALESMAN）的工资上调20%。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> emp <span class="hljs-keyword">set</span> sal<span class="hljs-operator">=</span>sal<span class="hljs-operator">*</span>(<span class="hljs-number">1</span><span class="hljs-operator">+</span><span class="hljs-number">0.2</span>) <span class="hljs-keyword">where</span> job<span class="hljs-operator">=</span><span class="hljs-string">&#x27;SALESMAN&#x27;</span>;<br></code></pre></td></tr></table></figure><p>5、在emp表中，查询工资大于部门编号为10的任意一个员工工资的其他部门的员工信息（包括部门编号，员工名和工资）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> deptno,ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal<span class="hljs-operator">&gt;</span><span class="hljs-keyword">any</span>(<span class="hljs-keyword">select</span> sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> DEPTNO<span class="hljs-operator">=</span><span class="hljs-number">10</span>)<span class="hljs-keyword">and</span> deptno<span class="hljs-operator">!=</span><span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>6、在Scott模式下，查询emp表中所有管理者所管理的下属员工信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> e2.ename <span class="hljs-keyword">as</span> 上层管理层,e1.ename <span class="hljs-keyword">as</span> 下属员工 <span class="hljs-keyword">from</span> emp e1 <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> emp e2 <span class="hljs-keyword">on</span> e1.mgr<span class="hljs-operator">=</span>e2.empno <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> e1.mgr<br></code></pre></td></tr></table></figure><p>7、声明一个检索emp表中雇员信息的游标，该游标名为cur_emp，然后打开游标，并指定检索职务是“MANAGER”的雇员信息（包括：empno,ename,sal），接着使用fetch…into语句和while循环读取游标中的所有雇员信息，最后输出读取的雇员信息。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">set</span> serveroutput <span class="hljs-keyword">on</span><span class="hljs-comment">/**/</span><br><span class="hljs-keyword">declare</span><br><span class="hljs-comment">/*声明游标，检索信息*/</span><br><span class="hljs-keyword">cursor</span> cur_emp(var_job <span class="hljs-keyword">in</span> varchar2:=<span class="hljs-string">&#x27;SALESMAN&#x27;</span>)<br><span class="hljs-keyword">is</span> <span class="hljs-keyword">select</span> empno,ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> job=var_job;<br><span class="hljs-keyword">type</span> record_emp <span class="hljs-keyword">is</span> <span class="hljs-type">record</span> <span class="hljs-comment">/*声明一个记录类型（RECORD类型）*/</span><br>(<br><span class="hljs-comment">/*定义当前记录的成员变量*/</span><br>var_empno emp.empno<span class="hljs-meta">%type</span>,<br>var_ename emp.ename<span class="hljs-meta">%type</span>,<br>var_sal emp.sal<span class="hljs-meta">%type</span><br>);<br>emp_row record_emp; <span class="hljs-comment">/*声明一个RECORD——emp类型的变量*/</span><br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">open</span> cur_emp(<span class="hljs-string">&#x27;MANAGER&#x27;</span>); <span class="hljs-comment">/*打开游标*/</span><br><span class="hljs-keyword">fetch</span> cur_emp <span class="hljs-keyword">into</span> emp_row; <span class="hljs-comment">/*先让指针指向结果集中的第一行，并将值保存到emp_row*/</span><br><span class="hljs-keyword">while</span> cur_emp%<span class="hljs-built_in">found</span> <span class="hljs-keyword">loop</span><br>dbms_output.put_line(emp_row.var_ename||<span class="hljs-string">&#x27;的编号是&#x27;</span>||emp_row.var_empno||<span class="hljs-string">&#x27;,工资是&#x27;</span>||emp_row.var_sal);<br><span class="hljs-keyword">fetch</span> cur_emp <span class="hljs-keyword">into</span> emp_row; <span class="hljs-comment">/*让指针指向结果集中的下一行，并将值保存到emp_row中*/</span><br><span class="hljs-keyword">end</span> <span class="hljs-keyword">loop</span>;<br><span class="hljs-keyword">close</span> cur_emp; <span class="hljs-comment">/*关闭游标*/</span><br><span class="hljs-keyword">end</span>;<br>/<br></code></pre></td></tr></table></figure><p>8、在Scott模式下，把emp表中销售员（即SALESMAN）的工资上调20%，然后使用隐式游标sql的%rowcount属性输出上调工资的员工数量。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">set</span> serveroutput <span class="hljs-keyword">on</span><span class="hljs-comment">/**/</span><br><span class="hljs-keyword">begin</span> <br><span class="hljs-keyword">update</span> emp <span class="hljs-keyword">set</span> sal=sal*(<span class="hljs-number">1</span>+<span class="hljs-number">0.2</span>) <span class="hljs-keyword">where</span> job=<span class="hljs-string">&#x27;SALESMAN&#x27;</span>;<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">sql</span>%notfound <span class="hljs-keyword">then</span>  <span class="hljs-comment">/*若update语句没有影响到任何一行数据*/</span><br>dbms_output.put_line(<span class="hljs-string">&#x27;无员工上调工资&#x27;</span>);<br><span class="hljs-keyword">else</span>                  <span class="hljs-comment">/*若update语句至少影响到一行数据*/</span><br>dbms_output.put_line(<span class="hljs-string">&#x27;有&#x27;</span>||<span class="hljs-keyword">sql</span>%rowcount||<span class="hljs-string">&#x27;个雇员工资上调20%&#x27;</span>);<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;<br><span class="hljs-keyword">end</span>;<br>/<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Oarcle</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
